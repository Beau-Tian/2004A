1.写一个链式调用的Promise
var promise = new Promise(resolve,reject){
	
}.then(res=>{
 	console.log(res)
).catch(error=>{
	console.log(error)
}
2.使用async await写一个案例
	async function fn(){
		console.log(1)
		await setTimeout(()=>{
			console.log(2)
			},1000)
		console.log(3)
}
fn()
不加 async await 运行结构是 1，3，2；
添加 async await 之后运行结构是 1,2,3

3.==和===的区别
 == 是比较时候相等，如果数据类型不同，== 会强制转变成同一种数据类型。
 ===全等，如果数据类型不同，也会是false。
4.var name='';let name = '';会发生什么事？
	会取let 的name 的赋值。不会报错
5.const obj = {a:1};var b = 1; obj.a = 2;b = 2; 会发生什么事？
	b会改变。最后打印的值会是b
6.var age = 12;
var obj = {
  age: 13,
  tellMe() {
    console.log('我今年' + this.age);
  }
}
var obj1 = {
  age: 15,
  tellMe: () => {
    console.log('我今年' + this.age);
  }
}
obj.tellMe();
obj1.tellMe();
var tell = obj.tellMe;
tell();
tell = obj1.tellMe;
tell();

写出运行结果和为什么？

我觉得 var age=12；最上面的var定义的变量age 不会起作用。因为obj obj1 是一个对象。他们三者是相互独立的，
 var tell = 匿名函数；；；第一个tell() 打印的结果是  我今年13   第二个tell() 打印的结果是 我今年15.。。
但是不理解。定义变量之后，下面的没有定义的 tell =obj1.tellMe;;;是什么意思
obj.tellMe() 结果是 我今年13 ；；；obj1.tellMe() 结果是 我今年15；；；

7.function person() {
  this.name = '张三';
}
person.prototype.name = '李四';
var p = new person();
console.log(p.name);  
delete p.name;
console.log(p.name);
写出打印结果

console.log(p.name);  ----张三
delete p.name; ？？？没明白是什么意思
如果是删除了p.name 那就是p没有name属性，因为是实力化的p，所以console.log(p.name)返回undefined


8.function human(name, age) {
  this.name = name;
  this.age = age;
}
human.prototype.eat = function () {
  console.log(`我叫${this.namee}，会吃饭了`);
}
human.prototype.tell = function () {
  console.log(`我叫${this.namee}，今年${this.age}岁`);
}
human.isHuman = function (obj) {
  if (obj instanceof human) {
    console.log('这是一个human的实例');
  } else {
    console.log('这不是一个human的实例');
  }
}
//请使用class定义一个功能一样的human对象
class human{
	constructor(name,age){
		this.name = name;
		this.age= age;
	}
	eat(){
		return `（我叫${this.name},今天${this.age}岁了）`
	}
	isHuman(){
		if(obj instanceof human){
			return `这是一个human实例`
		}else{
			return `这不是一个human的实例`
		}
	}
}