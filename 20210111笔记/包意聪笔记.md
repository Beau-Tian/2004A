## 笔记

原型和原型链：

```
关于原型和原型链 prototype属性和 __proto__ 属性理解；
以生产车举例：
当卡宴出现一款新的车型ky1，这时候众泰就会模仿卡宴的车ky1，生产同样的一款车zt1 (同样的意思是：模仿就是要把ky1的车型完全仿制过来，外形，颜色，性能等仿制过来)。
那么就是说zt1的原型是ky1...
zt1,制造出仿制的ky1，讲过审查之后，可以批量生成了，，，那么就生成出了 zt11,zt12,zt13,zt14...。(也就是news实例化对象，每个实例化对象都有一个__proto__属性，将__proto__想象成编号，通过编号可以找到他的原型车)。
所以当车间主任问 生产出的 zt13的原型车是谁的时候，应该回答是 zt1, 
那么zt1的原型是谁，应该是ky1...
生产的车投入市场后，卡宴的看到仿制ky1的众泰zt1时候，追究法律责任，这时候，产品经理 增加车的功能，比如是增加车灯，换颜色等等。这样众泰推出新的车型，zt2(那么zt2是在zt1是基础上生成出来的，所以zt2的原型是zt1),,,
那么zt2 经过审查批准后，批量生成（实例化对象的过程) 生成出 zt21,zt22,zt23,zt24,...


__proto__ 指向构造函数的原型，那么zt21 指向zt2。。。 zt21不能随意添加属性,修改属性。。。。
```

### 基本数据类型（简单）：

```
null、undefined、boolean、string、number、Symbol
引用数据类型（复杂）：
Object
```

### 堆和栈的理解：

```
为了更好的来阐述栈和堆，我们先来了解一下数据类型：
基本类型：String，Number，Boolean，Null，Undefined，这5种基本数据类型它们是直接按值存放的，所以可以直接访问。
引用类型：Function，Array，Object，当我们需要访问这三种引用类型的值时，首先得从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。

栈(stack):由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
堆(heap)：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
```

###  闭包：	

```
  1. 闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过外部函数访问这个函数的内部的变量。闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
  2. 不适合场景：返回闭包的函数是个非常大的函数。
    闭包的典型框架应该就是jquery了。
    闭包是javascript语言的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。
    这在做框架的时候体现更明显，有些方法和属性只是运算逻辑过程中的使用的，不想让外部修改这些属性，因此就可以设计一个闭包来只提供方法获取。
  3. 不必纠结到底怎样才算闭包，其实你写的每一个函数都算作闭包，即使是全局函数，你访问函数外部的全局变量时，就是闭包的体现。
```

### 解构赋值：

```
解构赋值是什么:解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。解构赋值 的特性很强大，它可以帮我们从一堆嵌套很深的对象属性中，很方便地拿到我们想要的那一个

数组的解构赋值：
let a, b, rest;
[a, b] = [10, 20];

console.log(a);
// expected output: 10

console.log(b);
// expected output: 20

[a, b, ...rest] = [10, 20, 30, 40, 50];

console.log(rest);
// expected output: Array [30,40,50]

对象的解构赋值：
({ a, b } = { a: 10, b: 20 });
console.log(a); // 10
console.log(b); // 20

({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});
console.log(a); // 10
console.log(b); // 20
console.log(rest); // {c: 30, d: 40}

常规用法：
使用解构赋值经常使用到默认值的赋值，和使用 function的默认参数一样，使用 = 来添加属性的默认值
let a, b;
[a=5, b=7] = [1];
console.log(a); // 1
console.log(b); // 7

let {a = 10, b = 5} = {a: 3};
console.log(a); // 3
console.log(b); // 
```

### 计时器：

```
setInterval() 每隔一段延迟时间，就会去调用回调函数，会持续的去调用
setTimeout（）是延迟时间到了之后，就回去回调函数，只会调用1次，就结束这个定时器
setimmediate:在循环事件任务完成后马上运行指定代码，和setTimeout差不多
```

### 预编译：

```
1）创建AO对象（Activation Object）（执行上下文）；
2）找函数形参和函数内变量声明，将形参名和变量名作为AO对象的属性名，值为undefined；
3）将实参值和形参统一，实参值赋给形参；
4）在函数体里面找函数声明，值赋予函数体。
```

### this的指向问题

```
全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）
方法调用中谁调用this指向谁
构造函数中this指向构造函数的实例
```

### call apply bind

```
call，apply 会自动执行函数，bind不会自动执行需要手动执行
call 方法 传递的参数是以参数列表的形式传递
apply 传递参数是以数组的形式传递
```

### 递归：

```
1）声明一个具名函数，通过函数名调用
2）使用arguments.callee代替函数名
3）使用函数表达式
```

### 严格模式：

```
严格模式，写在哪个作用域下，在那个作用域生效(尽量不要全局使用),使用后代码更加规范、更合理、更安全、更严谨。
    "use strict" 
    严格模式消除了js语法的一些不合理、不严谨之处、减少了怪异行为；消除了代码运行的不安全之处；提高编译器效率，提高运行速度；为未来新版本js做好铺垫
    用了严格模式，代码的变化：
    1.全局变量 必须用var声明变量
    2.this无法指向全局对象
    3.函数内重名属性(形参名字不能相同)
    4.arguments不允许动态修改，在严格模式下，argument保证了它的本质功能（arguments只存储在实际调用函数时实际传入的参数）
    5.新增保留字：impletents interface let package private protected public static yield
```

### 解析promise链式调用

```
Proimse能够将多个异步请求变为同步请求，但前提是，这些异步请求必须以.then的链式调用来使用才可以
Promise可以链式.then是因为，.then回调返回的也是一个Promise，所以才可以一直.then
```

### js的this指向：

```
哪个对象调用函数，函数里面的this指向哪个对象。在箭头函数里面，没有 this ，箭头函数里面的 this 是继承外面的环境。
```

### var、let、const

```
var声明变量可以重复声明，而let不可以重复声明
var是不受限于块级的，而let是受限于块级
var会与window相映射（会挂一个属性），而let不与window相映射
var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错
const声明之后必须赋值，否则会报错
const定义不可变的量，改变了就会报错
const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错
```

### 模板字符串

```
模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串
```

### 箭头函数：

```
箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种只包含一个表达式，省略掉了{ ... }和return。还有一种可以包含多条语句，这时候就不能省略{ ... }和return   

箭头函数没有它自己的this值，箭头函数内的this值继承自外作用域
```

### 扩展运算符：

```
扩展运算符（ spread ）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于函数调用。
```

