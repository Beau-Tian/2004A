#  									JavaScript笔记



##  什么是JS？JS的组成？

#### 	   ECMAScript 核心        						数据类型  运算符  语句  函数  数组   字符串 

####        DOM 文档对象模型

####        BOM 浏览器对象模型

#### 		JS就是属性和方法的集合。

##  四种输出方式

####   1) 打印到页面上

​            document.write("输出的内容");     识别HTML标签

####       2) 在控制台中输出

​            console.log("输出的内容");    字符串

####       3）输出到浏览器的提示框

​            alert（"输出的内容"）;     弹框

####       4）输入到浏览器的输入提示框

​            prompt(“输入的内容”，默认值)     对话框

##  注释和引入

js注释：  单行注释   // （快捷键 Ctrl+?）       多行注释 /*  注释的内容   */

```js
    js引入：  内部引入    直接在页面的script标签对里面写代码     
    					一般情况下script标签放在body的最下面 
              外部引入    head标签里面  
                 <script src='文件路径.js'><\/script>
```
##  标识符

####  1.概念  变量、函数、属性的名字，或者函数的参数   

####  2.命名规则  a.字母数字下划线$组成，不能以数字开头， b.严格区分大小写  c.不能是JS关键字和保留字   



##  变量及变量声明    

#### // 变量   可变的量              var 变量名 = 变量值

  1. #### 先声明，后赋值   2.边声明，边赋值    3.一次性声明多个变量并赋值



## Js数据类型 

  6种数据类型  

5种简单数据类型   String(字符串)   Number(数值)   Boolean(布尔)   Undefined(未定义)   Null(空)   
 复杂数据类型  1种   Object(对象) 

##  运算符

```js
用于做运算的符号就叫运算符

      算术运算符 + - * / %  ++ --
      逻辑运算符  &&  ||  !
      比较运算符  > <  >=   <=   ==  ===  !=   !==
      赋值运算符  = += -= *= /= %=
      其他运算符 - 三元运算符 条件表达式 ? 条件表达式为真执行的语句 : 条件表达式为假执行的语句

      表达式：
      把相同类型的数据用运算符按照一定的顺序拼接起来的，有意义的式子就是表达式


 &&  并且    全真为真（ 左右的结果都为真），其余为假   
        ||  或      全假为假，其余为真 ,只要有一个为真，就是true
        !   取反    - 真变假，假变真
```

##  语句

####  js里面的一整句话或者表达式,以分号结尾

####  分号：代表一个语句执行结束

####  分支/条件语句：条件语句是通过判断指定表达式的值来决定执行还是跳过某些语句

####  单分支、双分支、多分支

```javascript


      if(表达式){

      }


      if(表达式){
         表达式为真
      }else{
         表达式为假
      }


      if(表达式1){
        表达式1为真
      }else if(表达式2){
          表达式1为假2为真
      }else{
          表达式1、2都为假
      }



 for(var a = 3;a<10;a++){
        循环体 ----循环执行的语句
 }


     执行顺序： 1.变量初始化  2.判断条件是否满足  3.执行循环体 {}里面的语句   4.变量更新
     
                2.判断条件是否满足  3.执行循环体 {}里面的语句   4.变量更新
                
                直到条件不满足结束循环


      switch (key) {
        case value:
          //代码块1          
          break;
        case value:
          //代码块2         
          break;     
        default:
          break;
      }  
         
if(表达式){
   表达式的结果为真
}

if (表达式) {
      表达式为真
} else {
      表达式为假
}

if (表达式1) {
      表达式1为真
} else if(表达式2) {
      表达式1假 - 表达式2真
} else{
      表达式1假 - 表达式2假
}

switch (表达式/变量) {
      	case 变量的值:
         // 执行语句1
            break;
         case 变量的值:
         // 执行语句2
            break;
            
         default:
         // 其他条件都不满足，执行语句end
            break;
 }

switch的条件---变量不会发生数据类型转换    ===

循环语句就是程序执行的一个回路，可以让一部分代码重复执行
        for 
           for(初始化变量;循环条件检测;更新变量值){
	
           }

        while

           while(条件){
             //条件为true执行的代码
          }
        
        do while

          do {
             //先执行一次再判断条件
          } while (条件);

        当表达式条件不满足的 while不会执行，但是do-while会执行一次



 while (条件) {
           条件为真执行,条件为假的时候跳出循环
         }


   do {
        循环体
     } while (条件);     // 条件为真执行循环体，条件为假结束循环

      while 与 do while区别    while先判断条件，条件为真才执行  dowhile无论条件真假，都要先执行一次





 break      结束退出循环

       continue    跳过当次循环，执行下一次

       Break会影响后面循环的执行，执行后直接结束整个循环，但是continue不会影响后面循环的继续执行
```

# 函数（function）

函数概念：函数是由事件驱动或者被调用的时候执行的可被重复利用的代码块

函数是一组可以随时随地运行的语句
作用：
 使程序变得简洁清晰
 易于代码维护
 提高了代码的复用性，提高程序开发的效率

函数定义

   function 函数名(参数1，参数2){
       函数体 ---函数里面要执行的代码块
   }

函数命名

  标识符：变量、函数、属性的名字，或者函数的参数名

函数创建--
第一种创建函数的方式 （- 具名函数-- - 函数声明）
function 函数名(参数1，参数2) { 函数体 }

​    

​    


```js
    第二种创建函数的方式  函数表达式-- 匿名函数
    var fun = function (参数1，参数2) { 函数体 }

    var fun = function (a, b) {
        return a * b;
    }

    console.log(fun(5, 3))
```


```js
    第三种创建函数的方式，不常用。了解

    var fun1 = new Function('a', 'b', 'alert(a*b)');

    fun1(3, 4);
```



 形参  --函数创建的时候
 实参  ---函数调用的时候

```js
   形参和实参一一对应

   实参大于形参-----
   arguments 对象 ---创建了函数，arguments存在，arguments里面存的是所有的实参;
   arguments[0]  第一个实参
   arguments[1]  第二个实参
   。。。。
```

####  形参大于实参 -----

   多了的这个形参的值默认是undefine
   默认情况下，函数的返回值是undefined
   return  1.函数的返回值   2.终止当前函数运行



1. #### 什么是作用域?



######   *> 一段代码起作用的范围我们就称之为作用域，分为全局作用域和局部作用域*



####   \- 定义全局变量的三种方法



​    \- 变量定义在函数外部

​    \- 在函数内部定义一个不使用var声明的变量

​    \- 使用window对象来定义变量



2. #### 什么是作用域链？



  *> 在函数内部访问一个变量，优先在当前函数内部进行查找，如果找到了就使用该变量，*

  如果找不到则继续向父级进行查找，最后找到window顶层对象，如果还没有找到，则提示报错，

  这种由内向外查找变量的链条关系我们就称之为`作用域链`

####   js的预解析  

当JavaScript代码运行的时候，确定它运行所在的环境是非常重要的，

js的运行环境分为三种

\- 全局代码（Global Code）：代码首次执行时候的默认环境

\- 函数代码（Function Code）：每当执行流程进入到一个函数体内部的时候

\- Eval代码（Eval Code）：当eval函数内部的文本执行的时候

```js
function Fn(){

  var name = 1;

  console.log(name);

}

Fn();
```

- 当执行代码或调用函数的时候，js会形成执行上下文(可以认为代码运行环境)

- 这个执行上下文只能访问当前栈和上一个栈，这个执行上下文会被压入栈顶，

- 如果在函数内部又执行了一个函数，执行同样的操作

- 这样的话，函数执行完成后就会依次出栈，就形成上下文栈。

#### 函数提升与变量提升

  当js中函数或变量在未声明之前使用，
  那么函数或变量的声明将被提升到当前作用域的最顶部，
  这就叫变量提升

#### 函数的生命周期：

函数运行结束--函数以及里面的变量被js的垃圾回收机制回收了
 代码的执行顺序 ：代码从上到下执行--函数只有在调用的时候才会执行

## 辣鸡回收机制

1. ###### 标记清除

  *> 当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，*

  在离开环境之后还有的变量则是需要被删除的变量,因为环境中的变量已经无法访问。垃圾收集器，标记给他清除掉。

2. ###### 引用计数清除

  *> 这种方式常常会引起内存泄漏,* 

  机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，

  当这个变量指向其他一个值则引用次数便减一。当该值引用次数为0时就会被回收。

  a = object +1 b= object +1 c = object + 1 =3 

  a = null -1 

  比如 a 和 b 都保存一个对象，如果，a=b b=a,则a,b引用次数都是2，不会释放

3. ###### 内存管理 

  简单数据类型和复杂数据类型存储方式的不同，

  使用案例理解深拷贝和浅拷贝

## Date 日期对象

###### 				概念:	Date 对象用于处理日期与时间。

#### 创建 Date 对象：

```js
new Date()

var d = new Date();    // 当前时间
```

 

```js
    var d = new Date(milliseconds);   // 毫秒数
    var d = new Date(dateString);    
	// 字符串 '2019 2 2 10:00:00'  '2019-2-2 10:00:00'  '2019/2/2 10:00:00'
    var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);   
    // 以逗号隔开的年月日时分秒
```



#### 获取：

```javascript
  getFullYear()		//从 Date 对象以四位数字返回年份。
  getMonth()		//从 Date 对象返回月份 (0 ~ 11)。
  getDate()			//从 Date 对象返回一个月中的某一天 (1 ~ 31)。
  getDay()			//从 Date 对象返回一周中的某一天 (0 ~ 6)。        
  getHours()		//返回 Date 对象的小时 (0 ~ 23)。
  getMinutes()		//返回 Date 对象的分钟 (0 ~ 59)。
  getSeconds()		//返回 Date 对象的秒数 (0 ~ 59)。 
  getMilliseconds()	 //返回 Date 对象的毫秒(0 ~ 999)。
  getTime()			//返回 1970 年 1 月 1 日至今的毫秒数。
```

​     

#### 设置:

```js
setFullYear()		//设置 Date 对象中的年份（四位数字）。
setMonth()			//设置 Date 对象中月份 (0 ~ 11)。
setDate()			//设置 Date 对象中月的某一天 (1 ~ 31)。   
setHours()			//设置 Date 对象中的小时 (0 ~ 23)。
setMinutes()		//设置 Date 对象中的分钟 (0 ~ 59)。
setSeconds()		//设置 Date 对象中的秒钟 (0 ~ 59)。
setMilliseconds()	 //设置 Date 对象中的毫秒 (0 ~ 999)。
setTime() 			//方法以毫秒设置 Date 对象。
```

​        

#### 转换时间格式的方法:

```javascript
  toLocaleString()		//据本地时间格式，把 Date 对象转换为字符串。
  toLocaleDateString()	//根据本地时间格式，把 Date 对象的日期部分转换为字符串。
  toLocaleTimeString()	//根据本地时间格式，把 Date 对象的时间部分转换为字符串。
```

​      

#### Date转换为字符串:       

```javascript
   toString()		//把 Date 对象转换为字符串。
   valueOf()		//返回 Date 对象的原始值。  ---毫秒       
   toUTCString()	//根据世界时，把 Date 对象转换为字符串。
   toGMTString()   //标准格式的字符串时间
   toDateString()	//把 Date 对象的日期部分转换为字符串。
   toTimeString()	//把 Date 对象的时间部分转换为字符串。
```



#### 定时器相关方法：

##### 设置计时器方法

```javascript
    
    setInterval()  //间歇调用；就是每隔一段时间调用一次-间隙性计时器
   // 按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。

    setTimeout()   //延迟调用；指定的时间后调用一次，只调用一次   在指定的毫秒数后调用函数或计算表达式。一次性计时器    
    
    清除计时器的方法
        clearInterval("要清除的定时器名")
        clearTimeout("要清除的定时器名")

    语法：setInterval(code,millisec,lang)     
		 setTimeout(code,millisec,lang)
   code	    //必需。要调用的函数或要执行的代码串。
   millisec	//必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。
   lang	    //可选。 JScript | VBScript | JavaScript
```
## 正则表达式（RegExp）

#### -- 基本概念

- 字符串匹配，查询，替换的一种模式，外表风骚，内功强大。

- 表达式的结构

- 正则表达式结构/修饰符` 比如 `/\d{12}/g`

-  g 全局匹配 global  hello world

- i 忽略大小写 ignore

#### -- 正则的创建方法

###### 字面量方式

```js
var rep = /^1[34578]\d{9}$/
```

###### 构造函数形式

```js
 var rep = new RegExp("表达式","修饰符")
 //比如下面匹配一个手机号
 var rep = new RegExp("^1[34578]\d{9}$");
```

#### JS 字符串中可以使用正则表达式的三个函数

```js
  string.replace("正则表达式","要替换的对象")
  string.match("正则表达式")
  string.search("正则表达式")
```

#### test方法（用来验证）

```js
   var rep = /正则表达式/g
   rep.test(要验证的字符串); //结构返回true或者false
```

##### exec方法（用来验证）

```js
var rep = /正则表达式/g
rep.test(要验证的字符串) //结构返回true或false
```

#### 常用的元字符：

```js
            [abc] //匹配方框号中的任意一个字符
            [^abc] //除了abc以外的所有的字符
            [0-9] //匹配0-9之间数字
            [a-z] //匹配所有的大写字母
            [0-9a-zA-Z] //匹配大小写字母和数字
            [A-z] //匹配所有的大小写字母  [A-Za-z]
            (红色|蓝色|绿色)  //匹配红色，蓝色绿色
            [\u4e00-\u9fa5] //中文汉字
             
            .  //匹配任意字符
            \w //匹配任意字母数字下划线 或 [A-Za-z0-9_]
            \W //匹配非字母数字下划线
            \d //匹配所有数字  [0-9]
            \D //匹配非数字
            \s //匹配空格字符
            \S //匹配非空格字符
```

#### 常用的(写好的)

```javascript
        1.只能是中文 长度为2-7位
		 /^([\u4e00-\u9fa5]){2,7}$/
        2.长度为8到18位的小写大写字母或数字或下划线 【重要】
            /^[a-zA-Z0-9_]{8,18}$/
        3.正确的邮箱格式 【重要】
            /^\w+@[a-z0-9]{2,5}\.(com|cn|net|org)$/
            /^[A-z0-9_-]+@[a-z0-9]{2,5}\.[a-z]{2,3}$/
        4.正确的手机号【重要】
            /^1(3|4|5|7|8)\d{9}$/
        5.正确的身份证号:
            /^\d{15}|\d{17}([0-9]|x)/
            /^[1-9][0-9]{16}[0-9x]$/
        6.正确的qq号
            /[1-9][0-9]{4,}/
        7.正确的电话号码格式 【重要】
            /^0[0-9]{2}-[0-9]{8}|0[0-9]{3}-[0-9]{7}$/
            
        8. 过滤空白 /\s+/g
        9. 过滤首尾空格  str.trim()
        10. 匹配任意8-18之间的大小写字母数字构成的密码
            /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,18}$/
```

## 更多的正则相关知识可以找我要《精通正则表达式--第三版》



## Array  ---  [ 最好玩的莫过于（数组）]

## Array 对象用于在单个的变量中存储多个值，用来存储多组数据的容器（变量）;

      数组一般是由中括号包裹，元素之间使用逗号分隔，数组的长度也就是数组中元素的个数使用length获取，数组中具有索引下标，它们是
      从0开始的，通过对应的索引下标可以取到元素中对应的值。
      数组中的元素可以是js中任意数据类型的值
      当数组对象指定长度时，我们也可以存储多余这个长度的元素
    
       数组的创建方式：
       1. 使用字面量的方式创建  var arr = [10,20.30,true,"Hello",new Date(),function(){},[12,12,34],Math.random(),null,undefined]
       2. 使用new关键字来创建一个对象   var arr = new Array(12,34,"hello")
                                  var arr = new Array(5);

```js
     数组概念：数组是值的有序集合,每个值叫做一个元素,元素的位置我们称为下标或索引,从0开始
    
     数组定义的两种方式
     var  arr = [1,2,3];
     var  arr1 = new Array(1,2,3);

     数组的属性：length 设置或返回数组中元素的数目；
	max-最大的  min-最小的  average-平均  sort-排序(从左往右-从小到大)       
```


```js
    向数组中添加和删除的方法：
    
    push()	    向数组的末尾添加一个或更多元素，并返回新的数组长度。
    unshift()	  向数组的开头添加一个或更多元素，并返回新的长度

    shift()	    删除并返回数组的第一个元素。  //无参数    
    pop()	      删除数组的最后一个元素并返回删除的元素。 // 无参数
    splice()	  从数组中添加或删除元素 或者替换元素
           参数1： 下标    
           参数2： 数量
           参数3...4...5 添加的元素
           // 返回的是删除的元素---数组

    注意：添加和删除的方法，改变了原数组的长度和元素
```

```js
concat()    拼接一个或多个数组;返回拼接后的数组    
join()     根据指定的分隔符（seperator）进行切割，返回一个字符串,参数缺省以逗号作为分隔符 (数组连接成字符串)
  
  slice()	    选取数组的的一部分，并返回一个新数组 获取数组中部分元素并返回：  不会影响原数组(截取)

  // 以上三个方法不会影响原数组
```


```js
  与索引相关的方法： 
  indexOf()      匹配要查找的元素在数组中第一次出现的索引位置 ,array.indexOf(item,start)
  lastIndexOf()  匹配要查找的元素在数组中最后一次出现的索引位置 
      注意：以上两个方法去查找元素，如果找不到，返回-1
      //  第二个参数默认省略, 如果有，下标
  includes()  包含 数组中是否包含某个值   true   false

  //不会影响原数组
reverse() 反转数组的元素顺序 ; 改变了原数组的顺序  (原来的数组发生变化)
sort()  //排序 ---  影响原数组   默认升序
```

```js

1. instanceof     arr instanceof Array

2. isArray()      Array.isArray(arr)   //// 如果是数组返回结果是true ,否则false 

```

基本排序算法其核心思想是指对一组数据按照一定的顺序重新排列。
    重新排列时用到的技术是一组嵌套的for循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。

这些算法非常逼真的模拟了人类在现实生活中对数据的排序，例如纸牌玩家在处理手中的纸牌时对纸牌进行排序，
或者教师按照字母顺序或者分数对试卷进行排序。

#####  冒泡排序：

最慢的排序算法之一，也是最容易实现的排序算法

数组值会像气泡一样从数组的一端漂浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小的值 则会浮动到数组的左侧。

原因是因为算法会多次在数组中移动，比较相邻的数据，当左侧值大于右侧值时它们进行互换。

#####  选择排序算法 

​      选择排序从数组的开头开始，将第一个元素和其他元素进行比较。
​      检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从第二个位置继续。这个过程一直进行，
​      当进行到数组的倒数第二个位置时所有的数组便完成了排序。



## 代理

###### 		代理就是目标对象的抽象，复制版本，可以当作目标对象的替身，但又完全独立于目标对象。。

###### 		目标既可以被直接操作，也可以通过代理操作，但是直接操作会跳过代理。

#### 创建空代理

###### 	使用Proxy构造函数创建的，有两个参数接收（目标对象，处理程序对象），缺少参数就会报错TypeError.

上代码：

```javascript
const target = {
	id:"target"
};

const handler = {};

const proxy = new Proxy(target,handler)

// id属性会访问同一个值
console.log(target.id); // target 
console.log(proxy.id); 	// target

// 给目标属性赋值会反映在两个对象上
// 因为两个对象访问的是同一个值
target.id = 'foo'; 
console.log(target.id); // foo 
console.log(proxy.id); // foo

// 给代理属性赋值会反映在两个对象上
// 因为这个赋值会转移到目标对象
proxy.id = 'bar'; 
console.log(target.id); // bar 
console.log(proxy.id); // bar

// 严格相等可以用来区分代理和目标
console.log(target === proxy); // false

```



# javaScript执行上下文理解



###### 执行上下文就是当前js代码被解析和执行时所在的环境的抽象概念，JavaScript中运行的任何代码都是在执行上下文中运行。

###### 执行上下文也有生命周期，生命周期包括三个阶段：创建阶段->执行阶段->回收阶段.



###### 创建阶段（当函数被调用，单位执行任何内部代码之前）会做以下三件事:

- ###### 创建变量对象：首先初始化函数的参数arguments提升函数声明和变量声明

- ###### 创建作用域链

- ###### 确定this指向

```javascript
function text(arg){
	//1.形参arg是“h1”
    //2.因为函数声明比变量生命优先级高，所以此时arg是function
    console.log(arg)
    
    var arg = "hello";  //3.var arg 变量声明被忽略 arg = hello; 被执行
    function arg(){
        console.log("hello world")
    }
    console.log(arg)
}
text('h1')

```

这是因为当函数执行的时候，**首先会形成一个私有的作用域**，然后一次按照下面的步骤执行：

- ###### 如果有形参，先给形参赋值

- ###### 进行私有作用域中的预解析

- ###### 私有作用域中的代码从上到下执行

###### 函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文。



（了解）那怎么管理那么多的上下文？JavaScript殷勤创建了个执行栈来管理执行上下文。可以把执行站认为是个存贮函数调用的栈结构，遵循先进后出的原则。

```javascript
console.log(1);
function a(){
	console.log(2)
	(function b(){
		console.log(3)
	})()
	console.log(4)
} 
a()
console.log(5)
//输出: 1 2 3 4 5
```

![简单执行栈构造图]()

（此图来自网络，懒的画）

###### 如果非要深刻理解，看上面的流程图，需要记住的点：

- JavaScript执行在单线程上，所有的代码都是排队执行。
- 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入行栈的顶部（你可以理解电梯里面进去的人，先进后出，后进先出的概念）
- 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当权的函数的执行上下文出栈，等待垃圾回收/
- 浏览器的JS执行引擎总是访问栈顶的执行上下文。
- 全局上下文只有唯一的一个，它在浏览器关闭时出栈。

关于作用域上面有提到。。。







**什么是OOP语义ctrl+作键点这个链接↓**

[https://blog.csdn.net/qing_gee/article/details/83305342?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161105937216780255262487%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161105937216780255262487&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-83305342.pc_search_result_hbase_insert&utm_term=%E4%BB%80%E4%B9%88%E6%98%AFOOP%E8%AF%AD%E4%B9%89]



# javaScript面向对象笔记

## 面向对象的程序设计

##### 	面向对象最常用到的概念：

- ###### 对象、方法、属性

- ###### 类

- ###### 封装

- ###### 聚合

- ###### 重用与继承

- ###### 多态

## 对象

###### 面向对象这种设计风格重点就在于对象，这种对象不是我们代码中的对象，而是实质上的事物在程序设计语言

###### 中的表现形式，这里的食物可以是任何东西（比如某个客观存在的对象，或一些比较抽象的概念）。

###### 例如：

###### 		狗这种常见的对象来说，我们可以看到它们具有某些明确的特征（如：颜色，名字，体型等），能

###### 执行某些动作，比如 ： 汪汪叫，睡觉，吃狗粮，躲避，逃跑等等，在OOP（什么是OOP语义看上面？）语义中，这些对象特征就叫

###### 做属性，而那些动作就称之为方法。

#### 	此外还有一个口语方面的类比：

- ###### 对象往往使用名词来表示的（如book，person）

- ###### 方法一般都是些动词（如read，run）

- ###### 属性值则是一些形容词

## 类

###### 在现实生活中，相似的对象之间往往都有一些共同的组成特征，例如狗的种类比较多例如{“哈士

###### 奇”，“牧羊犬”，“德牧”，“柯基”。。。。等等种类繁多，*类* 实际上就是对象的设计蓝图或者制

###### 作配方。“对象这个词”，我们有时候也叫“实例”，所以我们可以说老鹰是鸟类的一个实例。我们能基于

###### 相同的类型创建出许多不同的对像。

###### 类就像一个模板（原型），而对象就是在这些模板的基础上被创建出来的。



###### 但是！JS实际上压根儿没有类，该语言的一切都是基于对象的，其所依靠的是一套原型系统

###### （prototype）。



## 封装

###### 封装则是另一个OOP相关概念，它主要用于对象中封装的内容，两部分组成：

- ###### 相关的数据和属性

- ###### 基于这些属性所能做的功能或方法

  

```
但除此之外，在概念中封装术语也包含了一层隐藏的信息。因此，当我们理解这个概念时，必须注意它在OOP的特定上下文中的含义。例如，在MP3播放器中。如果这是一个对象，那么作为用户的对象，我们肯定需要一些类似于按钮、显示界面之类的工作。这些接口可以帮助我们使用对象(例如播放歌曲)。至于它们的内部工作原理，我们并不清楚，而且在大多数情况下也不会关心这些。换句话说，这些接口的实现对我们来说是不可见的。同样,在OOP中。当我们在代码中调用对象的方法时，无论是我们自己的对象还是第三方的对象，至少在中国的环境中，鹰更像是鸟的子类。希望读者在理解对象和类之间的关系时，不要过于依赖类比。-第1章绪论7Library，我们不需要知道这个方法是如何工作的。在编译语言中，我们甚至看不到目标代码。由于Javascript是一种解释语言，is可以查看源代码。但至少它们在这个概念上是一致的，我们只需要知道对象操作接口，而不需要关心它的具体实现。关于信息隐藏，另一方面，关于方法和属性的可见性。在某些语言中，我们可以通过public、private、protected这些关键字来定义方法和属性的可见性。该用户可以访问限制分类定义对象的级别。例如，私有方法只有自己的内部代码才能访问对象，而公共方法是任何人都可以访问的。在JavaScript中，虽然所有的方法和属性都是公开的，但是我们会看到，该语言还是提供了一些隐藏的数据方法，以保护程序的秘密性。
```

## 聚合

###### 		聚合可把它理解成组合，就是指把几个现有的对象合并成一个新的对象的过程，聚合所强调的就是这种将

###### 多个对象合而为一的能力。

###### 用另一种思维去理解：

###### 	我可以把一个项目分解成多个模块，这样项目就易于管理，当一个项目大到一个人无法完成的时候，就得给

###### 它分解成多个模块，必要的话模块还可以分解成多个子模块，这样做可以利于开发者从多个不同的抽象层次来

###### 考虑这个项目怎么开发。



## 继承

###### 顾名思义，继承就是继承一些属性和方法，通过继承，开发者可以实现对代码的重复利用。

###### 

  一个对象继承另一个对象，子对象可以直接使用父对象的属性和方法，这种关系就叫做继承。

  如果父类对象已经定义的属性和方法，子对象可以直接使用，无需再定义，减少内存开销。

  子函数中的属性和方法如果跟父函数同名的话，子函数会覆盖父函数的属性和方法。 

**继承的方法**

~~~js
**原型链继承**

```js
    function Father(){

    }

    function Zi(){ 
    }

    Zi.prototype = new Father()

```
优缺点:

1. 子对象既可以使用方法发自身的属性，也可以使用父方法原型里的属性

2. 缺点：无法传递参数

**构造函数继承**
~~~


~~~js
```js

function Fu(){
    this.name = "超级玛丽";

    this.love = "顶砖吃毛菇";
}

function Zi(){
    
    Fu.call(this);
    
}

```

构造函数继承的优缺点
1. 可以传递参数，
2. 不可以使用父方法的原型属性
~~~


~~~js
**组合继承**

```js
function Fu(){
    this.name = "步佳伟.威龙";
    this.say = function(){

    }
}

function Zi(){

    Fu.call(this);
}

Zi.prototype = new Fu();

```

优点: 既能传递参数，也能使用父函数的原型
缺点：每实例化一次，要调用两次继承父方法
~~~

  **继承方式简单总结**
    - 原型链继承
        - 把父方法的new的实例化对象 赋给 子方法的原型属性
        - 子方法可以使用父方法原型中的属性，缺点：不可以传递参数

- 构造函数继承
    - 在子函数中通过call方法，改变this指向，把父方法的属性全部继承过来
        - 父方法.call(this,传递的参数)
    - 可以传递参数， 无法使用父方法原型中的属性

- 组合继承
    - 把原型链继承和构造函数继承，糅合到一起
    - 既可以传递参数，也可以使用父方法的原型属性， 缺点，实例化一次，调用两次继承，资源消耗比较大。



3. **call和apply的区别**

    A.call(B,参数);   A函数用B对象替代当前对象中的内容
        
    调用一个对象的一种方法，用另一个对象来代替当前对象

    apply和call方法的区别:
    apply传递一个数组参数，但是call传递的是一个参数列表

    还有一个bind方法，但是bind不会自动执行函数，需要手动调用一下

## 多态

##### 多态的概念就是：不同对象通过相同方法调用来实现各自行为的能力，就称作多态。

##### 例如:

###### 		obj2继承了上一级对象obj1的所有方法，这意味着两个对象都实现了定义的方法，

###### 		现在有一个叫obj3的变量，哪怕我不知道它是obj1还是obj2，也能直接调用这个方法，

###### 		完全不用担心会影响代码的正常运转。