变量，作用域与内存
原始值与引用值
概念：ECMAScript变量可以包含两种不同类型的数据：原始值和引用 值。原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。
注： 在很多语言中，字符串是使用对象表示的，因此被认为是引 用类型。ECMAScript打破了这个惯例。
动态属性：
原始值和引用值的定义方式很类似，都是创建一个变量，然后给 它赋一个值。
例：
let person = new Object(); 
person.name = "Nicholas"; 
console.log(person.name);
这里，首先创建了一个对象，并把它保存在变量 person 中。然 后，给这个对象添加了一个名为 name 的属性，并给这个属性赋值了 一个字符串 "Nicholas" 。在此之后，就可以访问这个新属性，直 到对象被销毁或属性被显式地删除
原始值不能有属性，尽管尝试给原始值添加属性不会报错
例如：
let name = "Nicholas";
name.age = 27; 
console.log(name.age); // undefined
复制值：
在通过变量把一个原始值赋值到另一个变量时，原始值会被复制 到新变量的位置。
例：
let num1 = 5;
let num2 = num1
传递参数：
在按值传递参数时，值会被复制到一个局部变量（即一个命名参 数，或者用ECMAScript的话说，就是 arguments 对象中的一个槽 位）。
确定类型
它是判断一个变量是否为字符串、数值、布尔 值或 undefined 的最好方式。如果值是对象或 null ，那么 typeof 返回 "object"
注：
typeof 操作符在用于检测函数时也会返 回 "function" 。当在Safari（直到Safari 5）和Chrome（直到 Chrome 7）中用于检测正则表达式时，由于实现细节的原因， typeof 也会返回 "function" 。ECMA-262规定，任何实现内 部 [[Call]] 方法的对象都应该在 typeof 检测时返 回 "function" 。因为上述浏览器中的正则表达式实现了这个方 法，所以 typeof 对正则表达式也返回 "function" 。在IE和 Firefox中， typeof 对正则表达式返回 "object" 。
执行上下文与作用域
变量或函数的上下文决定了它们可以访问哪些数据，以及它们 的行为。每个上下文都有一个关联的变量对象（variable object），而 这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法 通过代码访问变量对象，但后台处理数据会用到它。
因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。
上下文中的代码在执行的时候，会创建变量对象的一个作用域链 （scope chain）。
如果上下文是函数，则其活动对象（activation object）用作变量对象。
变量声明	
1.在使用 var 声明变量时，变量会被自动添加到最接近的上下 文。
	var 声明会被拿到函数或全局作用域的顶部，位于作用域中所 有代码之前
2.ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级 的，这也是JavaScript中的新概念。块级作用域由最近的一对包含 花括号 {} 界定。
3.除了 let ，ES6同时还增加了 const 关键字。使用 const 声 明的变量必须同时初始化为某个值。
注：
let 与 var 的另一个不同之处是在同一作用域内不能声明两 次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError 。
原始值和引用值有 以下特点：
原始值大小固定，因此保存在栈内存上。 
从一个变量到另一个变量复制原始值会创建该值的第二个副本。 
引用值是对象，存储在堆内存上。 
包含引用值的变量实际上只包含指向相应对象的一个指针，而不 是对象本身。 
从一个变量到另一个变量复制引用值只会复制指针，因此结果是 两个变量都指向同一个对象。 
typeof 操作符可以确定值的原始类型，而 instanceof 操作 符用于确保值的引用类型。
执行上下文可以总结如下：
执行上下文分全局上下文、函数上下文和块级上下文。 
代码执行流每进入一个新上下文，都会创建一个作用域链，用于 搜索变量和函数。 
函数或块的局部上下文不仅可以访问自己作用域内的变量，而且 也可以访问任何包含上下文乃至全局上下文中的变量。 
全局上下文只能访问全局上下文中的变量和函数，不能直接访问 局部上下文中的任何数据。 变量的执行上下文用于确定什么时候释放内存。
JavaScript的垃圾回收程序可以总结如下：
离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被 删除。 
主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标 记，再回来回收它们的内存。 
引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。 JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这 种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如 DOM元素）。 
引用计数在代码中存在循环引用时会出现问题。 
解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮 助。为促进内存回收，全局对象、全局对象的属性和循环引用都 应该在不需要时解除引用。