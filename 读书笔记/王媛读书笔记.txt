第三章：语言基础
3.1 语法
1，区分大小写 
2，标志符，就是变量、函数、属性或函数参数的名称。
    驼峰式命名：虽然写法不是强制的，但因为这种形式跟ECMAScript内置函数和对象的命名方式一致，所以算是最佳事件
3，注释：
单行注释和多行注释
4，严格模式
    可以全局使用 "use strict"
    也可以定义在函数体内，指定一个函数在严格模式下执行
    所有现代浏览器都支持严格模式
    5，语句
    语句以分号结尾
    代码块

3.2 关键字和保留字
    case void yield 样式关键字
    保留字
    enum implemments package public
    interface protected static let private

3.3变量
    变量是松散类型的，意思是变量可以用于保存任何类型的数据。
    每个变量不过是一个用于保存任意值的命名占位符

    三个关键字可以声明变量；var ，let,const

    3.31 var 
    可以多次声明变量，声明多个多个变量
    var string = "hi"
    如果去掉 var  string=“hi"吃屎string是全局变量

    变量提升   只是变量的提升命名不提升
    let 
    1,let声明的范围是块作用域，而var声明的范围是函数作用域

    2,let声明的变量不会别提升
         console.log(b); //--undefined
       var b = 2 

       console.log(a); //----a没有定义
       let a = 1
    3,不会和window相映射
        var a = 0;
      console.log(window.a); //--0
      let c = 0;
      console.log(window.c);--undefind
    4,let 在条件判断中，try catch中尽量不使用let，因为let是块作用域，
    5，for循环和定时器共同使用，输出0,1,2,3
        将var改成let 
    
    const
    1,const 声明的变量一旦声明不能修改，
    2，和let一样 不与window相映射 受限于块级 暂存性死区
    3，定义对象中的属性可以的，
    4， 使用到for in，for of 循环中

    优先使用const，如果需要更改的则使用let，以后var会用的很少。
    因为变量有了明确的作用域、声明位置，以及不变的值。
3.4 数据类型
    3.41，undefined 定义未被初始化，
    未定义会报错；
    用typeOf 检查  定义未被初始胡和未定义都是undefined
        undefined是一个假值
    var message ;
      console.log(message);//undefined
      console.log(d);//报错

      console.log(typeof message);//undefined
      console.log(typeof d); //---undefined
    3.42，null
      1，null值表示一个空对象指针，所以给typeof会返回“object”
      2，在定义将来要报错对象值的变量时候，建议使用null来初始化
        if(car! = null){
            //表示car是一个对象的引用
        }
      3，undefined是由null值派生来的，定义为表面上的相等
      console.log(undefined == null)  -----true
      4,即使null和undefined 有关系，他们的用途完全不一样。永远不必显式的将变量值设置为 undefined。当时null之哟啊变量要 报错对象，而当时有解忧对象可以保存，可以用null来填充变量
    3.43 boolean类型
        1，boolean 有两个字面量：true和false
        2，可以用来赋值
            let found = true;
            let lost = false;
        3,是区分大小写的
            True False是有效的标识符，但不是布尔值
        4，可用Boolean()将其他的数据类型转换成布尔值
        空字符串"",数值型 0，NaN ,null,undefined 转换成false；；；
        其他的转换成true
        var msg = "hello";
        if(msg){
            console.log("你好"); 
        }       //会打印出 "你好"
    3.44 Number 类型
        不明白
        浮点数和整数
        NaN 不是数值
            isNaN()用于判断是不是数值型
        转换成数值型Number(),parseInt(),parseFloat()
            一样用parseInt()转换成整型，parseFloat()转换浮点型
    3.45字符串
        1，字符串可以使用双引号，单引号，反引号
        2，字符字面量
            \n 换行 \t 制表 \b退格 \r回车 
            \f换页 \\\\反斜杠 \' 单引号……

        3,，字符串是不可变的，修改某个变量中的字符串，必须先销毁原始的字符串，将包含新值的保存到变量
        4，转换为字符串
            toString();
            但是null,undefined用string()来转换成自身的字面量
        5，模板字符串
            标签那部分没看明白
    3.46 Symbol 符号 唯一的标志符
            
    3.47 Object类型
        在ECMAScript中的Object时候派生其他对象的基类。Object类型的所有属性和方法在
        派生的对象上同样存在
        每个Object实例都有如下属性和方法
        1，constructor 用于常见当期那对象的函数。在前面的例子中，这个属性的值就是Object()hanshu 
        2,hasOwnProperty(propertyName);:用于判断当前对象实例时候存在给定的属性。
            检查的是字符串 o.hasOwnProperty('name')
        3,isPrototypeof(object):用于判断当前对象是否为另一个对象的原型
        4，propertyIsEnumerable(propertyName) ：用于判断给定
            的属性是否可以使用（本章稍后讨论的） for-in 语句枚举。
            与 hasOwnProperty() 一样，属性名必须是字符串。
        5，toString()返回对象的字符串表示
        6valueOf() 返回对象对应的字符串、数值或布尔值表示。通常与toString(d fanhuizhi xinagong )
3.5 操作符
    3.51 一元操作符
    3.52位操作符
    3.53布尔操作符
        逻辑或
        逻辑非
        逻辑与
    3.54 乘性操作符，除性操作符，取模
    3.55 指数操作符 es7新增  
            Math.pow() ===>对应的操作符是 **
            console.log(Math.pow(3,2))===9
            console.log(3 ** 2)===9

            console.log(Math.pow(16，0.5))===4
            console.log(16**0.5)===4

        还可以赋值操作
            let squar = 3;
            squar **=2;
            console.log(squared);====9
    3.56 加法 +
         减法 -
    3.57 关系操作符
        < > <= >=
    3.58 == === != !==
    3.59 条件操作符(二元表达式)
    3.6逗号操作符
        用来在一条语句中执行多个操作
第四章 变量、作用域与内存
4.1 原始值和引用值
    变量包含两种不同类型的数据：原始值和引用值
    原始值就是最简单的数据，引用值则是由多个值构成的对象
    再把一个值赋值给变量时，js引擎必须确定这个值是原始值还是引用值
    原始值(Undefined,Null,Boolean,Number,String,Symbol)
    保存原始值的变量是 按值 访问的，因为我们操作的就是存储在变量中的实际值
    引用值是保存在内存中的对象。与其他语言不同，js不许直接访问内存位置，不能直接操作对象所在的内存空间。
        在操作对象时候，实际上操作的是改对象的引用而非实际的对象本身。因此保存引用值的变量是按引用访问的
    4.11 动态属性
        引用类型可以添加、删除、修改属性。而原始值没有属性
    4.12 复制值
        原始值和引用值 
        通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置
        引用值 把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，他指向存储在堆内存中的对象
    4.13 传递参数 不明白
    4.14 确定类型
        typeof 操作符最适合用来判断一个变量是否是原始类型。可以检测 字符串。数值、布尔值、或undefined的最好方式
        如果值是对象或者是 unll 用typeof来检测返回 “object"
        typeof操作符用于检测函数时会返回“function”
    4.2 执行上下文与作用域
        看后面的小结部分会明白些   
        执行上下文和 变量、函数预解析的关系
    4.21 try catch; with 
    4.22 1，使用var声明的作用域
         写在函数内部的是局部变量，未写在函数内部的是全局变量。。
         name = 1；；这种形式没有var，，是全局变量
         变量提升
         通过在声明之前打印变量，可以验证变量是否被提升。声明的提升意味着 会输出undefined而不是Reference Error
         2,使用let的块级作用域
         在同一个块级作用域中，let重复声明会报错，
         var 则不会报错
         let 非常适合在循环中声明迭代变量。使用var声明的变量会泄漏到外面，而 let不会
         严格将 let 在js运行时也会被提升，但由于“暂时性死区”实际上不能在声明之前使用let变量
         3，const 声明的变量必须赋值(声明的变量必须同时初始化为某个值)，
            一经声明，在声明周期的任何时候都不能在重新赋予新值
        const声明只应用到顶级原语或者对象。换句话说，赋值为对象的const变量不能在被重新赋值为其他引用值，但对象的键则不受限制

        如果，想让整个对象都不能修改，使用Object.freeze()
        const a1 = Object.freeze({});
        a1.name ="jack";
        console.log(a1.naem) //undefined

        由于 const 声明 暗示变量的值是单一类型且不可修改，js运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的V8引擎就执行这种优化

    4.23 标识符查找
    4.3 垃圾回收
        在执行环境负责在代码执行时管理内存。
        通过自动内存管理实现内存分配和限制资源回收。基本思路很简单：确定哪个变量不会在使用，然后释放他占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间就会自动执行，，但是某块内存是否还有用，属于“不可判定的”问题
        如何标记未使用的变量也许有不同的实现方式在浏览器的发展史上，勇敢到过阆中主要的标记策略：标记清理和引用计数
    4.31 标记清理？？？
    4.32 引用计数 使用中会有很多问题
    4.33 性能
         现在垃圾回收程序会基于对js运行时环境的探测来决定何时运行。参测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的

         将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保住在执行代码时值保存必要的数据。如果数据不再必要，那么把它设置为null,从而释放其引用。这也可以叫做 解除引用。
         这个建议最适合全局变量和全局对象的属性。
         局部变量在超出作用域后会被自动解除引用，
         解除引用的关键在于确保相关的值已经不再上下文里里，因此他咋下次垃圾回收时会被回收

         1，通过let和const来提升性能
            不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。
            因为都以块为作用域，相比较var，会增早让垃圾回收程序介入
            在块作用域比函数作用域更早终止的情况下，这就有可能发生
        2 隐藏类 和 删除操作
        3 内存泄漏
            内存有限，多次调用，会有内存泄漏的问题
            js中的内存泄漏大部分是有不合理的引用导致的
                没有var const let声明的变量。相当于window.name ="jack".只要window本事不被清理就不会消失。
            定时器，，定时器的回调通过闭包引用了外部变量。。。定时器一致运行，回调函数中国引用的全局变量就会一直占用内存
            js闭包很容易在不知不觉中造成内存泄漏
        4 静态分配与对象池
            如何减少浏览器执行垃圾回收的次数。
            开发者无法直接控制什么时候开始收集垃圾，但可以简介控制触发垃圾回收的条件。
            理论上将 合理使用分配的内存，同时避免多余的垃圾回收，可以保住因释放内存而损失的性能

            浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后又超出了作用域，浏览器就会采用更激进的方式调度垃圾回收程序运行。这样就会影响性能
            对象池？？？？
        
        4.4 小结  复制过来。。看完小结对前面的内容理解的更多一些。下次先看小结部分
JavaScript变量可以保存两种类型的值：原始值和引用值。原始值
可能是以下6种原始数据类型之一： Undefined 、 Null 、
Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有
以下特点。
原始值大小固定，因此保存在栈内存上。
从一个变量到另一个变量复制原始值会创建该值的第二个副本。
引用值是对象，存储在堆内存上。
包含引用值的变量实际上只包含指向相应对象的一个指针，而不
是对象本身。
从一个变量到另一个变量复制引用值只会复制指针，因此结果是
两个变量都指向同一个对象。
typeof 操作符可以确定值的原始类型，而 instanceof 操作
符用于确保值的引用类型。
任何变量（不管包含的是原始值还是引用值）都存在于某个执行
上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生
命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如
下。
执行上下文分全局上下文、函数上下文和块级上下文。
代码执行流每进入一个新上下文，都会创建一个作用域链，用于
搜索变量和函数。
函数或块的局部上下文不仅可以访问自己作用域内的变量，而且
也可以访问任何包含上下文乃至全局上下文中的变量。
全局上下文只能访问全局上下文中的变量和函数，不能直接访问
局部上下文中的任何数据。
变量的执行上下文用于确定什么时候释放内存。

JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分
配和回收。JavaScript的垃圾回收程序可以总结如下。
离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被
删除。
主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标
记，再回来回收它们的内存。
引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。
JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这
种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如
DOM元素）。
引用计数在代码中存在循环引用时会出现问题。
解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮
助。为促进内存回收，全局对象、全局对象的属性和循环引用都
应该在不需要时解除引用。


