### 执行上下文与作用域

```
执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重
要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们
的行为。每个上下文都有一个关联的变量对象（variable object），而
这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法
通过代码访问变量对象，但后台处理数据会用到它。
```

## 变量声明

```
ES6之后，JavaScript的变量声明经历了翻天覆地的变化。直到
ECMAScript 5.1， var 都是声明变量的唯一关键字。ES6不仅增加了
let 和 const 两个关键字，而且还让这两个关键字压倒性地超越
var 成为首选
```

## var

```
var 声明会被拿到函数或全局作用域的顶部，位于作用域中所
有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用
域中的代码不必考虑变量是否已经声明就可以直接使用。可是在
实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使
用变量。
```

##### 4.1 原始值与引用值

```
ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。原始值就是最简单的数据，引用值 则是由多个值构成的对象。

保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。

在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的
```

。

##### 4.1.1 动态属性

```
原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。

这里，首先创建了一个对象，并把它保存在变量person 中。然后，给这个对象添加了一个名为name 的属性，并给这个属性赋值了一个字符串"Nicholas" 。在此之后，就可以访问这个新属性，直到对象被销毁或属性被显式地删除。
```



##### 4.1.2 复制值

```
除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。
```



##### 4.1.3 传递参数

```
ECMAScript中所有函数的参数都是按值传递的。在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用ECMAScript的话说，就是arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。
```



##### 4.1.4 确定类型

```
typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined 的最好方式。如果值是对象或null ，那么typeof 返回"object"
```



#### 4.2 执行上下文与作用域

```
执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。主要有全局上下文和函数上下文两种。
```



##### 4.2.1 作用域链增强

```
try / catch 语句的catch 块 with 语句 这两种情况下，都会在作用域链前端添加一个变量对象。对with 语句来说，会向作用域链前端添加指定的对象；对catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。
```



##### 4.2.2 变量声明

1. 使用var 的函数作用域声明

```
在使用var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。
```



1. 使用let 的块级作用域声明

```
ES6新增的let 关键字跟var 很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号{} 界定。换句话说， if 块、while 块、function块，甚至连单独的块也是let 声明变量的作用域。
```



1. 使用const 的常量声明

```
ES6同时还增加了const 关键字。使用const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。
```



1. 标识符查找

```
当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。
```



#### 4.3 垃圾回收

```
JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。
```

\##### 4.3.1 标记清理

```
JavaScript最常用的垃圾回收策略是标记清理（mark-andsweep）

当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑

上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运

行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下 文的标记。
```

4.3.2 引用计数

```
另一种没那么常用的垃圾回收策略是引用计数（referencecounting）。其思路是对每个值都记录它被引用的次数。声明变量并它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办 法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序 下次运行的时候就会释放引用数为0的值的内存。 4.3.4 内存管理 在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。 不过，JavaScript运行在一个内存管理与垃圾回收都很特殊的环境。分 配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。
```

# 4.4 小结

```
JavaScript变量可以保存两种类型的值：原始值和引用值。原始值

可能是以下6种原始数据类型之一： Undefined 、Null 、 Boolean 、Number

、String 和Symbol 。原始值和引用值有 以下特点。

原始值大小固定，因此保存在栈内存上。

从一个变量到另一个变量复制原始值会创建该值的第二个副本。

引用值是对象，存储在堆内存上。

包含引用值的变量实际上只包含指向相应对象的一个指针，而不 是对象本身。

从一个变量到另一个变量复制引用值只会复制指针，因此结果是

两个变量都指向同一个对象。 typeof 操作符可以确定值的原始类型，而instanceof

操作 符用于确保值的引用类型。

任何变量（不管包含的是原始值还是引用值）都存在于某个执行

上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生

命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如 下。

执行上下文分全局上下文、函数上下文和块级上下文。

代码执行流每进入一个新上下文，都会创建一个作用域链，用于 搜索变量和函数。

函数或块的局部上下文不仅可以访问自己作用域内的变量，而且

也可以访问任何包含上下文乃至全局上下文中的变量。

全局上下文只能访问全局上下文中的变量和函数，不能直接访问

局部上下文中的任何数据。 变量的执行上下文用于确定什么时候释放内存。

JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分

配和回收。JavaScript的垃圾回收程序可以总结如下。

离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被 删除。

主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标

记，再回来回收它们的内存。

引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。
```

