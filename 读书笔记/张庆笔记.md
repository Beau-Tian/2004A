1JavaScript实现

 虽然JavaScript和ECMAScript基本上是同义词，但JavaScript远远 不限于ECMA-262所定义的那样。没错，完整的JavaScript实现包含以下几个部分：

核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM）

文档对象模型（DOM，Document Object Model）是一个应用编程 接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽 象为一组分层节点。HTML或XML页面的每个组成部分都是一种节 点，包含不同的数据。

IE3和Netscape Navigator 3提供了浏览器对象模型（BOM） API， 用于支持访问和操作浏览器的窗口。使用BOM，开发者可以操控浏览 器显示页面之外的部分。而BOM真正独一无二的地方，当然也是问题 最多的地方，就是它是唯一一个没有相关标准的JavaScript实现。

BOM主要针对浏览器窗口和子窗口（frame），不过 人们通常会把任何特定于浏览器的扩展都归在BOM的范畴内。比如， 下面就是这样一些扩展： 弹出新浏览器窗口的能力； 移动、缩放和关闭浏览器窗口的能力； navigator 对象，提供关于浏览器的详尽信息； location 对象，提供浏览器加载页面的详尽信息； screen 对象，提供关于用户屏幕分辨率的详尽信息； performance 对象，提供浏览器内存占用、导航行为和时间统 计的详尽信息； 对cookie的支持； 其他自定义对象，如 XMLHttpRequest 和IE的 ActiveXObject 。

## 第 2 章 HTML中的JavaScript

### 2.1 <script> 元素

```
将JavaScript插入HTML的主要方法是使用 <script> 元素。这
个元素是由网景公司创造出来，并最早在Netscape Navigator 2中实现
的。后来，这个元素被正式加入到HTML规范。 <script> 元素有下
列8个属性。
1.async ：表示应该立即开始下载脚本，但不能阻止其他
页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。

2.charset ：可选。使用 src 属性指定的代码字符集。这个属
性很少使用，因为大多数浏览器不在乎它的值。

3.crossorigin ：可选。配置相关请求的CORS（跨源资源共
享）设置。默认不使用CORS。
crossorigin="anonymous" 配置文件请求不必设置凭据标
志。 crossorigin="use-credentials" 设置凭据标志，意
味着出站请求会包含凭据。

4.defer ：可选。表示在文档解析和显示完成后再执行脚本是没
有问题的。只对外部脚本文件有效。在IE7及更早的版本中，对行
内脚本也可以指定这个属性。

5.integrity ：可选。允许比对接收到的资源和指定的加密签名
以验证子资源完整性（SRI，Subresource Intergrity）。如果接收到
的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚
本不会执行。这个属性可以用于确保内容分发网络（CDN，
Content Delivery Network）不会提供恶意内容。

6.language ：废弃。最初用于表示代码块中的脚本语言
（如 "JavaScript" 、 "JavaScript
1.2" 或 "VBScript" ）。大多数浏览器都会忽略这个属性，
不应该再使用它。

7.src ：可选。表示包含要执行的代码的外部文件。

8.type ：可选。代替 language ，表示代码块中脚本语言的内
容类型（也称MIME类型）。按照惯例，这个值始终都
是 "text/javascript" ，尽
管 "text/javascript" 和 "text/ecmascript" 都已经废
弃了。JavaScript文件的MIME类型通常是 "application/xjavascript" ，不过给type属性这个值有可能导致脚本被忽
略。在非IE的浏览器中有效的其他值还
有 "application/javascript" 和 "application/ecmas
cript" 。如果这个值是 module ，则代码会被当成ES6模块，
而且只有这时候代码中才能出现 import 和 export 关键字。
```

#### 2.1.1 标签占位符

所有  <script>元素都被在页面的<head>标签内。这种做法的主要目的是把外部的CSS和JavaScript文件都集中放到 一起。



#### 2.1.2 推迟执行脚本

HTML 4.01为 <script>元素定义一个叫defer的属性。这 个属性表示脚本在执行的时候不会改变页面的结构。因此，这个脚本完全可以在整个页面解析完之后再运行。

#### 2.1.3 异步执行脚本

HTML5为<script>元素定义了async属性。从改变脚本处 理方式上看， async 属性与 defer 类似。当然，它们两者也都只 适用于外部脚本，都会告诉浏览器立即开始下载。不过，与 defer 不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执行。

#### 2.1.4 动态加载脚本

除了<script>标签，还有其他方式可以加载脚本。因为javaScript可以使用DOM API,所以通过向DOM中动态添加 script 元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添加到DOM即可。

#### 2.1.5 XHTML中的变化

可扩展超文本标记语言（Extensible HyperText Markup Language）是将HTML作为XML的应用重新包装的结果。与HTML不 同，在XHTML中使用JavaScript必须指定 type 属性且值为 text/javascript ，HTML中则可以没有这个属性。

### 第 3 章 语言基础

#### 3.1 语法

#### ECMAScript的语法很大程度上借鉴了C语言和其他类C语言，如 Java和Perl。熟悉这些语言的开发者，应该很容易理解ECMAScript宽 松的语法。

#### 3.1.1 区分大小写

ECMAScript中一切都区分大小写。无论是变 量、函数名还是操作符，都区分大小写。换句话说，变量 test 和变 量 Test 是两个不同的变量。类似地， typeof 不能作为函数名， 因为它是一个关键字。但 Typeof 是一个完全有效的函数名。

#### 3.1.2 标识符

所谓标识符，就是变量、函数、属性或函数参数的名称。标识符 可以由一或多个下列字符组成：

1.第一个字符必须是一个字母、下划线（ _ ）或美元符号 （ $ ）； 

2.剩下的其他字符可以是字母、下划线、美元符号或数字。

3.ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写

4.关键字，保留字，true,false和null不能作为标识符。



#### 3.1.3 注释

ECMAScript采用C语言风格的注释，包括单行注释和块注释。单 行注释以两个斜杠字符开头

//       单行注释

/* */   多行注释

#### 3.1.4 严格模式

ECMAScript 5增加了严格模式（strict mode）的概念。严格模式是 一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写 法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个 脚本启用严格模式，**在脚本开头加上这一行：**

**"use strict";**

##### 虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个 预处理指令。任何支持的JavaScript引擎看到它都会切换到严格模式。 选择这种语法形式的目的是不破坏ECMAScript 3语法。

预处理：

function doSomething(){

"use strict";

}

严格模式会影响JavaScript执行的很多方面，因此本书在用到它时 会明确指出来。所有现代浏览器都支持严格模式。

### 3.1.5 语句

ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定 语句在哪里结尾.

注意：

1.即使语句末尾的分号不是必需的，也应该加上。

2.记着加分号有助于防止省略造成的问题，比如可以避免输入内容不完整。

多条语句可以合并到一个C语言风格的代码块中。代码块由一个 左花括号（ { ）标识开始，一个右花括号（ } ）标识结束：

```
if(test){
  test = false;
  console.log(test);
}
```

if之类的控制语句只在执行多条语句时要求必须有代码块。不 过，最佳实践是始终在控制语句中使用代码块，即使要执行的只有一 条语句，如下例所示：

```
// 有效，但容易导致错误，应该避免
if (test)
console.log(test);
// 推荐
if (test) { console.log(test);
]
```

在控制语句中使用代码块可以让内容更清晰，在需要修改代码时 也可以减少出错的可能性。

### 3.2 关键字与保留字

ECMA-262描述一组保留的关键字，这些关键字有特殊用途，比如表示控制语句的开始和结束，

，或者执行特定的操作。

注意的点：

1.保留的关键字不能用作标识符或属性名。

2.规范中也描述了一组未来的保留字，同样不能用作标识符或属性 名。虽然保留字在语言中没有特定用途，但它们是保留给将来做关键字用的。

### 3.3 变量

变量是松散类型的，意思是变量可以用于保存任何类 型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有3种个关键字可以声明变量：var,const,let.

### 3.3.1 var 关键字

要定义变量，可以使用 var 操作符（注意 var 是一个关键 字），后跟变量名（即标识符，如前所述）：

```
var message;

```

这行代码定义了一个名为 message 的变量,可以用它保存任何 类型的值。（不初始化的情况下，变量会保存一个特殊值 undefined ，下一节讨论数据类型时会谈到。）ECMAScript实现变 量初始化，因此可以同时定义变量并设置它的值：

```
var message = "hi";
```

这里， message 被定义为一个保存字符串值 hi 的变量。像这 样初始化变量不会将它标识为字符串类型，只是一个简单的赋值而 已。随后，不仅可以改变保存的值，也可以改变值的类型：

```
var message = "hi";
message = 100; // 合法，但不推荐
```

在这个例子中，变量 message 首先被定义为一个保存字符串值 hi 的变量，然后又被重写为保存了数值100。虽然不推荐改变变量保 存值的类型，但这在ECMAScript中是完全有效的。

###  var 声明作用域

使用 var 操作符定义的变量会成为包含它的 函数的局部变量。比如，使用 var 在一个函数内部定义一个变 量，就意味着该变量将在函数退出时被销毁：

```
使用 var 操作符定义的变量会成为包含它的
函数的局部变量。比如，使用 var 在一个函数内部定义一个变
量，就意味着该变量将在函数退出时被销毁：
```

```
function test() {
var message = "hi"; // 局部变量
}
test();
console.log(message); // 出错！
```

这里， message 变量是在函数内部使用 var 定义的。函数叫 test() ，调用它会创建这个变量并给它赋值。调用之后变量随 即被销毁，因此示例中的最后一行会导致错误。不过，在函数内 定义变量时省略 var 操作符，可以创建一个全局变量：

```
function test() {
message = "hi"; // 全局变量
}
test();
console.log(message); // "hi"

```

去掉之前的 var 操作符之后， message 就变成了全局变量。 只要调用一次函数 test() ，就会定义这个变量，并且可以在函 数外部访问到。

```
注意 虽然可以通过省略 var 操作符定义全局变量，但不推 荐这么做。在局部作用域中定义的全局变量很难维护，也会造 成困惑。这是因为不能一下子断定省略 var 是不是有意而为之。在严格模式下，如果像这样给未声明的变量赋值，则会导
致抛出 ReferenceError 。
```

2. #### var 声明提升 使用 var 时，下面的代码不会报错。这是因为使用这个关键字 声明的变量会自动提升到函数作用域顶部：

 

```
function foo() {
console.log(age);
var age = 26;
}
foo(); // undefined
```

之所以不会报错，是因为ECMAScript运行时把它看成等价于如下

把所有变量声明都拉到函数作用域的顶部。

### 3.3.2  let 声明

####  let 跟 var 的作用差不多，但有着非常重要的区别。最明显的 区别是， let 声明的范围是块作用域，而 var 声明的范围是函数作用域。

```
if(true){
  var name ='Matt',
  console.log(name);
}
console.log(name); //Matt
if(true){
 let age =26;
 console.log(age); //26
}
console.log(age // ReferenceError: age没有
```

#### 3.3数据类型

ECMAscipt有6种简单数据类型（也称为原始类型）：

undefined,null,Boolean.Number,String和Symbol.

Symbol是ECMAScript新增的。还有一种复杂的数据类型叫object对象。

### 3.4操作符

1.递增/递减操作符

如果将一元减应用到非数值，则会执行与使用 Number() 转型，函数一样的类型转换：

布尔值false和true转换为0和1，字符串根据特殊规则进行解析，对象会调用它们的valueof()

或toString() 方法以得到可以转换的值。

2. 一元加和减

一元加和减操作符对大多数开发者来说并不陌生，它们ECMAScirpt中的数学用途一样，

一元加由一个加号表示，放在变量前头，对数值没有任何影响

### 3.5   if语句

##### if 语句是使用最频繁的语句之一，语法如下：

```
if (condition) statement1 else statement2
```

这里的条件可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript会自动调用

Boolean函数将这个表达式的值转换为布尔值。如果条件求值为true,则执行语句

statement1;如果条件求值为false,则执行statement2。

## 3.6函数

函数对任何语言来说都是核心组件，因为它们可以封装语句，然 后在任何地方、任何时间执行。ECMAScript中的函数使用 function 关键字声明，后跟一组参数，然后是函数体。

JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的    形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对    象，能完成基本的计算任务，但没有提供获得输入和产生输出的机    制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的    关键。下面总结一下ECMAScript中的基本元素。    ECMAScript中的基本数据类型包括 Undefined 、 Null 、 Boolean 、 Number 、    String 和 Symbol 。

严格模式对函数也有一些限制：

 函数不能以 eval 或 arguments 作为名称； 函数的参数不能叫 eval 或 arguments ； 两个函数的参数不能叫同一个名称。

#### 下面总结一下ECMAScript中的基本元素。

1.ECMAScript中的基本数据类型包括 Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。

2.与其他语言不同，ECMAScript不区分整数和浮点值，只有 Number 一种数值数据类型。

3.Object 是一种复杂数据类型，它是这门语言中所有对象的基类。

4.严格模式为这门语言中某些容易出错的部分施加了限制。

5.ECMAScript提供了C语言和类C语言中常见的很多基本操作符， 包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值 操作符等。

6.不需要指定函数的返回值，因为任何函数可以在任何时候返回任 何值。 

7.不指定返回值的函数实际上会返回特殊值 undefined

### 第 4 章 变量、作用域与内存

```
本章内容
通过变量使用原始值与引用值
理解执行上下文
理解垃圾回收
```

#### 4.1 原始值与引用值

ECMAScipt变量可以包含两种不同的类型的数据：原始值和引用值。

原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。

#### 4.2 动态属性 

原始值和引用值的定义方式很类似，都是创建一个变量，然后给 它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什 么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属 性和方法。

#### 4.2.1 复制值 

除了存储方式不同，原始值和引用值在通过变量复制时也有所不 同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制 到新变量的位置。

#### 4.2.2传递参数

ECMAScript中所有函数的参数都是按值传递的。这意味着函数外 的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变 量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引 用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块 可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值 传递。 

在按值传递参数时，值会被复制到一个局部变量（即一个命名参 数，或者用ECMAScript的话说，就是 arguments 对象中的一个槽 位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部 变量，这意味着对本地变量的修改会反映到函数外部。

#### 4.2.3 确定类型

####  前一章提到的 typeof 操作符最适合用来判断一个变量是否为原 始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔 值或 undefined 的最好方式。如果值是对象或 null ，那么 typeof 返回 "object" 

#### 4.3执行上下文与作用域

##  执行上下文类型：

- **全局执行上下文** ：只有一个，浏览器中的全局对象就是 window 对象，`this` 指向这个全局对象。
- **函数执行上下文** ： 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序，在执行栈中（将在后文讨论）执行一系列步骤。
- **Eval 函数执行上下文** — 执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文
- 注意点：

1：只有全局执行上下文

2：first()函数执行，执行栈中添加first()函数的执行上下文

3：在first函数执行的过程中Second函数执行了，second函数的执行上下文加入到执行栈中

4：Second函数执行完毕，移除执行栈

5：Frist()函数执行完毕移除执行栈

###  作用域

作用域是可访问变量的集合。在 JavaScript 中, 对象和函数同样也是变量。

**在 JavaScript 中, 作用域为可访问变量，对象，函数的集合。**

JavaScript 函数作用域: 作用域在函数内修改。

分为全局变量和局部变量，

变量在函数内声明，变量为局部作用域。

变量在函数外定义，即为全局变量。

### 标记清理 

### JavaScript最常用的垃圾回收策略是标记清理（mark-andsweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个 变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑 上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运 行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下 文的标记。

#### 引用计数

什么是引用计数？

一个在堆上创建的对象，记录有多少个指针指向它。

 为什么要设计引用计数，他解决什么问题？

1、new出一个临时对象，使用完了，需要delete。但是拥有权会转移（auto_ptr）或者扩散，因此很难确定delete时机。忘记delete导致资源泄漏，过早delete，导致还在使用的指针出现错误，重复delete导致未定义行为。

2、许多对象拥有相同的值，存储多次是个很愚蠢的事，可以共享。

如何实现：

1、以String为例说明，String s1 = "Hello", String s2 = s1; 可以让s1,s2共享"Hello"。

2、引用计数放在哪里呢？显然不能放在String对象中，因为每个String对象都有这个引用计数，引用计数应该和String指向的Value在一起。

3、在String中建立一个嵌套类StringValue，String中有一个字段 StringValue* pStringValue。为什么StringValue设计成嵌套类，因为StringValue只是嵌套在String中，为了实现String，不会出现在其他地方。与此类似的有，STL中各种容器专属的迭代器。

4、StringValue中有：int refCount，记录引用计数。char* pData：指向char。

5、String的copy构造

```
1 String::String(const String& rhs)
2     :pStringValue(rhs.pStringValue)
3 {
4     ++(pStringValue->refCount);
5 }
```

#### 性能

IE7发布后，JavaScript引擎的垃圾回收程序被调优为动态改变分 配变量、字面量或数组槽位等会触发垃圾回收的阈值。IE7的起始阈值 都与IE6的相同。如果垃圾回收程序回收的内存不到已分配的15%，这 些变量、字面量或数组槽位的阈值就会翻倍。如果有一次回收的内存 达到已分配的85%，则阈值重置为默认值。这么一个简单的修改，极 大地提升了重度依赖JavaScript的网页在浏览器中的性能。

#### 内存管理

 在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。 不过，JavaScript运行在一个内存管理与垃圾回收都很特殊的环境。分 配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏 览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运 行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存 限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执 行的语句数量。 将内存占用量保持在一个较小的值可以让页面性能更好。优化内 存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数 据不再必要，那么把它设置为 null ，从而释放其引用。这也可以叫解除引用

#### 内存泄漏

#### 写得不好的JavaScript可能出现难以察觉且有害的内存泄漏问题。 在内存有限的设备上，或者在函数会被调用很多次的情况下，内 存泄漏可能是个大问题。JavaScript中的内存泄漏大部分是由不合 理的引用导致的。 意外声明全局变量是最常见但也最容易修复的内存泄漏问题。

