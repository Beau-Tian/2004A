#### javaScript

​	JavaScript的实现分三部分 1.核心 (ECMA Scripe) 2.文档对象模型（DOM）3.浏览器对象模型(BOM)

核心 ： JavaScript实现了ECMAScript，而Adobe ActionScript同样也实现了 ECMAScript。

DOM：文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。HTML或XML页面的每个组成部分都是一种节点，包含不同的数据 

DOM通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用DOM API，可以轻松地删除、添加、替换、修改节点。

BOM : BOM主要针对浏览器窗口和子窗（frame），不过人们通常会把任何特定于浏览器的扩展都归在BOM的范畴内。

##### 标签占位符

​	之前都是放到<head>里面要把所有的东西都加载后页面才会显示

 把javaScript引用放到<body>里这样就可以先加载页面在加载功能了

##### 推迟执行脚本

defer属性 在执行的时候不会改变页面的结构这个脚本完全可以在整个页面解析完之后再运行在 <script> 元素上设置defer 属性，会告诉浏览器应该立即开始下载，但执行应该推迟

##### 语法

区分大小写：

 无论是变量，函数名还是操作符都要区分大小写

标识符

所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：

第一个字符必须是一个字母、下划线（ _ ）或美元符号（ $ ）；

剩下的其他字符可以是字母、下划线、美元符号或数字。

ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写，

##### 注释

js注释：   *//* *单行注释*     /* *这是多行*

*注释* **/* 

html注释 ：<!--   -->



var 关键字

要定义变量，可以使用 var 操作符（注意 var 是一个关键字），后跟变量名（即标识符，如前所述）



 var 声明作用域  var 声明提升

 let 声明的范围是块作用域，而 var 声明的范围是函数作用域。

 暂时性死区   let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。let 声明之前的执行瞬间被称为“暂时性死区”

##### 数据类型

Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 

Symbol （符号）是ECMAScript 6新增的



typeof 操作符会返回下列字符串之一:

"undefined" 表示值未定义；

"boolean" 表示值为布尔值；

"string" 表示值为字符串；

"number" 表示值为数值；

"object" 表示值为对象（而不是函数）或 null ； 

"function" 表示值为函数；

"symbol" 表示值为符号。

##### for in for of

for in 遍历数组打印出的是下标

for of  遍历数组打印出的是值

##### 函数

函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行 function 关键字声明，后跟一组参数，然后是函数体；函数通过函数名来调用要传给函数的参数放在括号里（如果有多个参数，则用逗号隔开）；



##### 原始值与引用值

原始值（primitive value）就是最简单的数据，（ Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。）

引用值（referencevalue）则是由多个值构成的对象

##### 动态属性

​	可以随时添加、修改和删除其属性和方法。

##### 复制值

​	在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置   这两个变量可以独立使用，互不干扰

##### 传递参数

这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。

例子：

```
function addTen(num) { 

num += 10; 

return num; 

}

let count = 20; 

let result = addTen(count); 

console.log(count); *// 20**，没有变化*

console.log(result); *// 30
```



##### 执行上下文与作用域

​	变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它

全局上下文是最外层的上下文全局上下文就是我们常说的 window 对象

使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的

每个函数调用都有自己的上下文

上下文中的代码在执行的时候，会创建变量对象的一个作用域链



##### 变量声明

1.使用var，var 声明会被拿到函数或全局作用域的顶部，位于作用域中所
有代码之前。这个现象叫作“提升”（hoisting）
2. 使用 let 的块级作用域声明
ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级
的，这也是JavaScript中的新概念。块级作用域由最近的一对包含
花括号 {} 。， if 块、 while 块、 function
块，连单独的块也是 let 声明变量的作用域。
let 与 var 的另一个不同之处是在同一作用域内不能声明两
次。重复的 var 声明会被忽略，而重复的 let 声明会抛出
SyntaxError
3. 使用 const 的常量声明
除了 let ，ES6同时还增加了 const 关键字。使用 const 声
明的变量必须同时初始化为某个值。一经声明，在其生命周期的
任何时候都不能再重新赋予新值。

##### 垃圾回收

​	通过自动内存管理实现内存分配和闲置资源回收   确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行



##### 标记清理和引用计数

​		当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。

​		当变量离开上下文时，也会被加上离开上下文的标记

​		被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存

​		其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1  下次运行的时候就会释放引用数为0的值的内存



##### **Date**

​	 

Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间1970年1月1日午夜（零时）今所经过的毫秒数

在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间

Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数

支持的日期格式：

“月/日/年”，如 "5/23/2019" ； 

“月名 日, 年”，如 "May 23, 2019" ； 

“周几 月名 日 年 时:分:秒 时区”，如 "Tue May 23 2019 00:00:00

GMT-0700" ；

ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05- 

23T00:00:00 （只适用于兼容ES5的实现）。



##### 日期格式化方法 

Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：

toDateString() 显示日期中的周几、月、日、年（格式特定于实现）；

toTimeString() 显示日期中的时、分、秒和时区（格式特定于实现）；

toLocaleDateString() 显示日期中的周几、月、日、年（格式特定于实现和地区）；

toLocaleTimeString() 显示日期中的时、分、秒（格式特定于实现）；

toUTCString() 显示完整的UTC日期（格式特定于实现）。



##### 日期**/**时间组件方法

getTime() 返回日期的毫秒表示；与valueOf() 相同

setTime(*milliseconds*)设置日期的毫秒表示，从而修改整个日期

getFullYear()返回4位数年（即2019而不是19） 

getUTCFullYear()返回UTC日期的4位数年

setFullYear(*year*)设置日期的年（ *year* 必须是4位数）

setUTCFullYear(*year*)设置UTC日期的年（ *year* 必须是4位数）

getMonth()返回日期的月（0表示1月，11表 示12月）

getUTCMonth()返回UTC日期的月（0表示1月，11表示12月）



getUTCDay()返回UTC日期中表示周几的数值（0表示周日，6表示周六）

getHours()返回日期中的时（0~23） 

getUTCHours()返回UTC日期中的时（0~23） 

setHours(*hours*)设置日期中的时（如果 *hours*大于23，则加日）

setUTCHours(*hours*)设置UTC日期中的时（如果*hours* 大于23，则加日）

getMinutes()返回日期中的分（0~59） 

getUTCMinutes()返回UTC日期中的分（0~59） 

setMinutes(*minutes*)设置日期中的分（如果minutes* 大于59，则加时）

setUTCMinutes(*minutes*)设置UTC日期中的分（如果minutes* 大于59，则加时）



getSeconds()返回日期中的秒（0~59） 

getUTCSeconds()返回UTC日期中的秒（0~59） 

setSeconds(*seconds*)设置日期中的秒（如果seconds 大于59，则加分）

setUTCSeconds(*seconds*)设置UTC日期中的秒（如果seconds* 大于59，则加分）

getMilliseconds()返回日期中的毫秒

getUTCMilliseconds()返回UTC日期中的毫秒

setMilliseconds(*milliseconds*)设置日期中的毫秒

setUTCMilliseconds(*milliseconds*)设置中的毫秒 UTC日期

getTimezoneOffset()返回以分钟计的UTC与本地时区的偏移量（如美国EST即“东部标准时间”返回300，进入夏令时的地区可能有所差异）



##### **RegExp**

​	RegExp 类型支持正则表达式

​	这个正则表达式的 pattern （模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用

匹配模式的标记：

​		g ：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。

​		i ：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。

​		m ：多行模式，表示查找到一行文本末尾时会继续查找。

​		y ：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。

​		u ：Unicode模式，启用Unicode匹配。

​		s ： dotAll 模式，表示元字符 . 匹配任何字符（包括 \n 或 \r ）。

##### RegExp 实例属性

global ：布尔值，表示是否设置了 g 标记。

ignoreCase ：布尔值，表示是否设置了 i 标记。

unicode ：布尔值，表示是否设置了 u 标记。

sticky ：布尔值，表示是否设置了 y 标记。

lastIndex ：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。

multiline ：布尔值，表示是否设置了 m 标记。

dotAll ：布尔值，表示是否设置了 s 标记。

source ：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。

flags ：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠