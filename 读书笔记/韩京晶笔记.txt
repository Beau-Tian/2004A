书后总结
第一章
JS是一门用来网页交互的脚本语言。
有三组成部分：ECMAScript、文档对象模型（DOM）、浏览器对象模型（BOM）
第二章	HTML中的JavaScript
JavaScript是通过script元素插入到HTML页面中的。
第三章	语言基础
ECMAScript中一切都区分大小写，他的标识符使用驼峰大小写模式。
注意：关键字、保留字、true、false和null不能作为标识符。
定义多个变量，可以用逗号分隔开每个变量
暂时性死区
数据类型：undefined.null.boolean.number.string.symbol。还有一种object
object的属性和方法：constructor.hasOwnProperty.isPrototypeof.propertyIsEnumerable.toLocaleString.toString.valueOf。
一元操作符
只操作一个值得操作符叫一元操作符，它是ECMAScript中最简单的操作符。
ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没提供获得输入和产生输出的机制。
严格模式为这门语言中某些容易出错的部分施加了限制。
不指定返回值的函数实际上会返回特殊值 undefined
第四章 变量、作用域与内存
变量就是特定时间点一个特定值的名称
4.1   原始值与引用值
原始值就是最简单的数据，引用值则是由多个值构成的对象。保存原始值的变量是按值访问的，我们操作的就是存储在变量中实际值
ECMAScript中函数的参数就是局部变量。
所有的引用值都是object的实例
4.2   执行上下文与作用域
执行上下文都有一个关联的变量对象
上下文中的代码在执行的时候，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端，如果上下文是函数，则其活动对象用作变量对象。活动对象最初只有一个定义变量
4.2.2 变量声明
\1使用var的函数作用域声明
注意：在初始化变量前一定要先声明变量
\2使用let的块级作用域声明
let的行为适合在循环中声明迭代变量
\3使用const的声明变量
4.3  垃圾回收
JavaScript最常用的垃圾回收策略是标记清理
4.3.2  引用计数
引用计数就是对象A有一个指针指向对象B，B也指向了A
4.3.4  内存管理
\1通过const和let声明提升性能
\2隐藏和删除操作
\3内存泄漏

静态分类是优化的一种极端形式，可以用它提升性能
小结：JavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以?6种原始数据类型之一： Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有以下特点。
原始值大小固定，因此保存在栈内存上。
从一个变量到另一个变量复制原始值会创建该值的第二个副本。
引用值是对象，存储在堆内存上。
包含引用值的变量实际上只包含指向相应对象的一个指针，而不
是对象本身。
从一个变量到另一个变量复制引用值只会复制指针，因此结果是
两个变量都指向同一个对象。
typeof 操作符可以确定值的原始类型，而 instanceof 操作
符用于确保值的引用类型。
JavaScript的垃圾回收程序
离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。
主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。
引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。
JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这
种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如
DOM元素）。
引用计数在代码中存在循环引用时会出现问题。
解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。
第五章   基本引用类型
引用值（或者对象）是某个特定引用类型的实例。引用类型是把数据和功能组织到一起的结构。引用类型有时候也
被称为对象定义。
对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函数（constructor）来创建。
5.1  Date
let someDate = new Date(Date.parse("May 23, 2019"));
let someDate = new Date("May 23, 2019");
5.1.1    继承的方法
5.1.2 日期格式化方法
toDateString(){月、日、年}	toTimeString(){时、分、秒}
toLocaleDateString()、toLocaleTimeString()
toUTCString() 显示完整的UTC日期
input 属性中包含原始的字符串。
leftConext 属性包含原始字符串中 "short" 之前的内容，
rightContext 属性包含 "short" 之后的内容。
lastMatch 属性包含匹配整个正则表达式的上一个字符串，
即 "short" 。
lastParen 属性包含捕获组的上一次匹配，即 "s" 。
5.3 原始值包装类型
ECMAScript提供了3种特殊的引用类型：Boolean 、 Number 和 String 
引用类型与原始值包装类型的?要区别在于对象的生命周期。
Number 是对应数值的引用类型
String 是对应字符串的引用类型。
对于大多数语言字符集是足
够了，在Unic?de中称为基本多语言平面（BMP）。为了表示更多的字符，Unic?de采用了一个策略，即每个字符使用另外16位去选择一个增补平面。这种每个字符使用两个16位码元的策略称为代理对。
3. 字符串操作方法
 concat() ，用于将一个或多个字符串拼接成一个新字符串。
3个从字符串中提取子字符串的方法：slice() 、 substr() 和 substring() 。
4. 字符串位置方法
有两个方法用于在字符串中定位子字符串： indexOf() 和lastIndexOf() 。
5. 字符串包含方法
ECMAScript 6增加了3个用于判断字符串中是否包含另一个字符串的方法： startsWith() 、 endsWith() 和 includes() 。
6. trim() 方法
ECMAScript在所有字符串上都提供了 trim() 方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。
7. repeat() 方法
ECMAScript在所有字符串上都提供了 repeat() 方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。
8. padStart() 和 padEnd() 方法
padStart() 和 padEnd() 方法会复制字符串，这两个方法的第一个参数是长度，第二个参数是可选的填充字符串
第六章    集合引用类型
6.1   Object 
大多数引用值的实例都是Object类型
对象字面量表示法：它是对象定义的简写形式
属性一般是通过点语法存取。
用中括号能通过变量访问属性：
let prototypeName="name";
console.log(person[prototypeName]);
其实就是给属性起个名，然后打印输出这个名字，就可以访问这个属性了。
数组字面量表示法：
let colors=["red","blue","green"];
let name=[];
let values=[1,2];
//逗号分隔元素
数组排序：
reverse()、sort()
splice(0,2)删除前两个元素
splice(0,2,"red","green")从位置2插入“red”和“green”
splice(2, 1, "red", "green")从位置二删除一个元素，再在该位置插入 "red" 和 "green"
6.3    定型数组
SharedArrayBuffer 是 ArrayBuffer 的一个变体，可以无须复制就在执行上下文间传递它。
 ArrayBuffer一经创建就不能再调整大小了，可以用slice（）创建一个新的
malloc() 在分配失败时会返回一个 null 指针。 ArrayBuffer在分配失败时会抛出错误。
malloc() 可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。 ArrayBuffer 分配的内存不能超过Number.MAX_SAFE_INTEGER （）字节。
malloc() 调用成功不会初始化实际的地址。声明 ArrayBuffer则会将所有二进制位初始化为0。
通过 malloc() 分配的堆内存除非调用 free() 或程序退出，否则系统不能再使用。而通过声明 ArrayBuffer 分配的堆内存可以被当成垃圾回收，不用手动释放。
6.4    Map
 Map 是一种新的集合类型，Map 的大多数特性都可以通过Object 类型实现
使用回调方式，可以调用forEach()方法并传回回调。
6.4.3  选Object还是Map
・内存占用：Map比Object存储多
・插入性能：代码涉及大量插入时，Map的性能更加
・查找速度：代码涉及大量查找，选择Object比较好
・删除性能：涉及大量删除选Map
6.5   基本API
用 new 关键字实例化一个空的 WeakMap ：弱映射中的键只能是 Object 或者继承Object 的类型，尝试使用非对象设置键会抛出 TypeError 。值的类型没有限制。
6.6   Set
Set 会维护值插入时的顺序，因此支持按顺序迭代。
因为 values() 是默认迭代器，可以直接对集合实例使用扩展操作，把集合转换为数组：
const s = new Set(["val1", "val2", "val3"]);
console.log([...s]);  
6.7   WeakSet
WeakSet是一种新的集合类型
6.8   迭代与扩展操作
与扩展操作符一起使用时，能方便地实现互操作。
6.9   小结
3种原始值包装类型： Boolean 、 Number 和String 。
特点：・每种包装类型都映射到同名的原始类型。
・在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据
・涉及原始值的语句只要一执行完毕，包装对象就会立即销毁


