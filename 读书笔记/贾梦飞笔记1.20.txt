一。JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成
部分。
包含：ECMAScript
DOM
BOM
二。JavaScript插入HTML的主要方法是使用 <script> 元素
推迟执行脚本：defer
异步执行脚本：async和defer类似，defer
不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执
行
文档模式：最初的文档模式有两种：混杂模式和标准模式
JavaScrip重点：
1.要包含外部JavaScript文件，必须将 src 属性设置为要包含文件
的URL。文件可以跟网页在同一台服务器上，也可以位于完全不
同的域。
2.所有 <script> 元素会依照它们在网页中出现的次序被解释。
在不使用 defer 和 async 属性的情况下，包含在 <script>
元素中的代码必须严格按次序解释。
3.对不推迟执行的脚本，浏览器必须解释完位于 <script> 元素
中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该
把 <script> 元素放到页面末尾，介于主内容之后及
</body> 标签之前。
4.可以使用 defer 属性把脚本推迟到文档渲染完毕后再执行。推
迟的脚本总是按照它们被列出的次序执行。
5.可以使用 async 属性表示脚本不需要等待其他脚本，同时也不
阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面
中出现的次序执行。
6.通过使用 <noscript> 元素，可以指定在浏览器不支持脚本时
显示的内容。如果浏览器支持并启用脚本，则 <noscript> 元
素中的任何内容都不会被渲染。
三。语言基础：
1.语法：
   ①.区分大小写：字母一定要区分大小写
   ②.标识符:就是变量、函数、属性或函数参数的名称。标识符
可以由一或多个下列字符组成
   ③.注释：单行注释：//，多行注释：/**/
   ④.严格模式：严格模式是一种不同的JavaScript解析和执行模型，
2.关键字和保留字
   在JavaScript不能使用关键字和保留字会引起一些冲突或BUG
3.变量：
   var，
   let，
   const
4.数据类型：typeof检测数据类型
   简单数据类型：Undefined：表示值未定义、 Null ：空、 Boolean： 表示值为布尔值 、 Number：表示值为数值 、 String：表示值为字符串， Symbol ：表示值为符号。 
   复杂数据类型：Object 表示值为对象（而不是函数）
5.操作符：描述了一组可用于操作数据值的操作符
   +加  -减  ++递加  --递减   *乘  /除  %取模       ！取反
   包括小于（ < ）、大于（ > ）、小于等于（ <= ）和大于等于（ >= ），
  ==相等    ！=不等   ===全等  ！==不全等    =赋值
6.语句
    ①。if语句用于判断，分支少的时候比较好用
    ②。do-while 语句，while 语句，for 语句：循环语句
    ③。for-in 语句，for-of 语句：循环对象
    ④。switch 语句与if一样是判断的语句，分支多的时候比较好用
7.函数：function
     函数对任何语言来说都是核心组件，因为它们可以封装语句，然
后在任何地方、任何时间执行。
四。变量、作用域与内存
  1.原始值与引用值
原始值（primitive value）就是最简单的数据，引用值（referencevalue）则是由多个值构成的对象。
动态属性：
原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值，不同的是引用值可以随时添加、修改和删除其属
性和方法。而原始值不能有属性，尽管尝试给原始值添加属性不会报错。
传递参数：所有函数的参数都是按值传递的，程序运行过程中，实际参数就会将参数值传递给相应的形式参数，然后在函数中实现对数据处理和返回的过程，方法有按值传递参数，按地址传递参数和按数组传递参数。
执行上下文与作用域：执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。
执行上下文的生命周期包括三个阶段：创建阶段→执行阶段→回收阶段
每个上下文都有一个关联的变量对象而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。
上下文中的代码在执行的时候，会创建变量对象的一个作用域链
作用域链增强：有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到
try / catch 语句的 catch 块 with 语句这两种情况下，都会在作用域链前端添加一个变量对象。对with 语句来说，会向作用域链前端添加指定的对象；对 catch 语
句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明
变量声明：使用 var 的函数作用域声明变量会被自动添加到最接近的上下文，var 声明会被拿到函数或全局作用域的顶部，
使用 let 的块级作用域声明：特点有无法变量提升，存在let不能重复定义，只在块级作用域内生效，块级作用域内只能够拿到该作用域内声明的let变量，外部被忽略
使用 const 的常量声明：一经声明，在其生命周期的任何时候都不能再重新赋予新值，除了要遵循以上规则，其他方面与 let 声明是一样的
垃圾回收：
标记清除：这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。
引用计数：另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。
内存泄漏：内存泄漏指申请的内存一直得不到释放，GC回收不了。一般在项目中就是，你创建的对象一直保存在内存中，可达但你把它的引用地址搞丢了结果没法操作它，而GC又不会回收这块内存。内存泄漏的危害就是堆积耗尽系统所有内存。
第五章：
Date：Date 对象用于处理日期和时间。
是世界时间1970年1月1日午夜（零时）至今所经过的毫秒数。
ECMAScript为此提供了两个辅助方法： Date.parse() 和 Date.UTC() 。
Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。
Date.UTC() 方法也返回日期的毫秒表示，但使用的是跟Date.parse() 不同的信息来生成这个值。传给 Date.UTC() 的参数是年、零起点月数（1月是0，2月是1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为1日。其他参数的默认值都是0。
日期格式化方法：toDateString()，toTimeString()，toLocaleDateString()，toLocaleTimeString()，toUTCString()
日期/时间组件方法：
getDate()	返回当日的日期和时间。
getDate()从 Date 对象返回一个月中的某一天 (1 ~ 31)。
getDay()从 Date 对象返回一周中的某一天 (0 ~ 6)。0是周一，以此类推
getMonth()从 Date 对象返回月份 (0 ~ 11)。0是1月，以此类推
getFullYear()从 Date 对象以四位数字返回年份。
getHours()返回 Date 对象的小时 (0 ~ 23)。
getMinutes()返回 Date 对象的分钟 (0 ~ 59)。
getSeconds()返回 Date 对象的秒数 (0 ~ 59)。
getMilliseconds()返回 Date 对象的毫秒(0 ~ 999)。
getTime()	返回 1970 年 1 月 1 日至今的毫秒数。
getTimezoneOffset()	返回本地时间与格林威治标准时间 (GMT) 的分钟差。
getUTCDate()根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。
getUTCDay()根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。
getUTCMonth()根据世界时从 Date 对象返回月份 (0 ~ 11)。
getUTCFullYear()根据世界时从 Date 对象返回四位数的年份。
getUTCHours()根据世界时返回 Date 对象的小时 (0 ~ 23)。
getUTCMinutes()根据世界时返回 Date 对象的分钟 (0 ~ 59)。
getUTCSeconds()根据世界时返回 Date 对象的秒钟 (0 ~ 59)。
getUTCMilliseconds()根据世界时返回 Date 对象的毫秒(0 ~ 999)。
RegExp：对象表示正则表达式，它是对字符串执行模式匹配的强大工具
参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。
参数 attributes 是一个可选的字符串，包含属性 "g"、"i" 和 "m"，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。
RegExp 构造函数创建时对应的模式字符串

RegExp 对象属性
global	RegExp 对象是否具有标志 g。
ignoreCase	RegExp 对象是否具有标志 i。	
lastIndex	一个整数，标示开始下一次匹配的字符位置。
multiline	RegExp 对象是否具有标志 m。	
source	正则表达式的源文本。	

元字符
.	查找单个字符，除了换行和行结束符。
\w	查找单词字符。
\W	查找非单词字符。
\d	查找数字。
\D	查找非数字字符。
\s	查找空白字符。
\S	查找非空白字符。
\b	匹配单词边界。
\B	匹配非单词边界。
\0	查找 NUL 字符。
\n	查找换行符。
\f	查找换页符。
\r	查找回车符。
\t	查找制表符。
\v	查找垂直制表符。
\xxx	查找以八进制数 xxx 规定的字符。
\xdd	查找以十六进制数 dd 规定的字符。
\uxxxx	查找以十六进制数 xxxx 规定的 Unicode 字符。

RegExp 构造函数属性
input $_ 最后搜索的字符串
lastMatch $& 最后匹配的文本
lastParen $+ 最后匹配的捕获组
leftContext $` input 字符串中出现在lastMatch 前面的文本
rightContext $' input 字符串中出现在lastMatch 后面的文本
通过这些属性可以提取出与 exec() 和 test() 执行的操作相关的信息。
原始值包装类型：ECMAScript提供了3种特殊的引用类型：Boolean 、 Number 和 String 。
Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入 true 或 false ，
Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值，
String 是对应字符串的引用类型。要创建一个 String 对象，使用 String 构造函数并传入一个数值，
JavaScript字符
 concat() ，用于将一个或多个字符串拼接成一个新字符串。
indexOf() 和 lastIndexOf() 。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）。
判断字符串中是否包含另一个字符串的方法： startsWith() 、 endsWith() 和 includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。
 trim() 方法。这个方法会创建字符串的一个副本，删除前、后所有空格符
 repeat() 方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。
字符串大小写转换包括4个方法： toLowerCase() 、 toLocaleLowerCase() 、 toUpperCase() 和 toLocaleUpperCase() 。 toLowerCase() 和 toUpperCase() 方法是原来就有的方法，与 java.lang.String中的方法同名。 toLocaleLowerCase() 和 toLocaleUpperCase() 方法旨在基于特定地区实现。
 localeCompare() ，这个方法比较两个字符串返回1，-1，0三种情况
单例内置对象
Global 对象是ECMAScript中最特别的对象，因为代码不会显式地访问它。ECMA-262规定 Global 对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 Global 对象的属性 。本
encodeURI() 和 encodeURIComponent() 方法用于编码统一资源标识符（URI），以便传给浏览器。有效的URI不能包含某些字符，比如空格。使用URI编码方法来编码URI可以让浏览器能够理解它们，同时又以特殊的UTF-8编码替换掉所有无效字符。
eval() 。这个方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串。
Global 对象有很多属性，其中一些前面已经提到过了。像undefined 、 NaN 和 Infinity 等特殊值都是 Global 对象的属性。此外，所有原生引用类型构造函数，
Math：ECMAScript提供了 Math 对象作为保存数学公式、信息和计算的地方。 Math 对象提供了一些辅助计算的属性和方法。
Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。min() 和 max() 方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数
舍入方法：于把小数值舍入为整数的4个方法： Math.ceil() 、 Math.floor() 、 Math.round() 和 Math.fround() 。	
Math.random() 方法返回一个0~1范围内的随机数，其中包含0但不包含1。























