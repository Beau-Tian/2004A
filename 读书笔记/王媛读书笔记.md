# 第三章：语言基础

## 3.1 语法

1，区分大小写 
2，标志符，就是变量、函数、属性或函数参数的名称。
    驼峰式命名：虽然写法不是强制的，但因为这种形式跟ECMAScript内置函数和对象的命名方式一致，所以算是最佳事件
3，注释：
单行注释和多行注释
4，严格模式
    可以全局使用 "use strict"
    也可以定义在函数体内，指定一个函数在严格模式下执行
    所有现代浏览器都支持严格模式
    5，语句
    语句以分号结尾
    代码块

## 3.2 关键字和保留字

​    case void yield 样式关键字
​    保留字
​    enum implemments package public
​    interface protected static let private

## 3.3变量

​    变量是松散类型的，意思是变量可以用于保存任何类型的数据。
​    每个变量不过是一个用于保存任意值的命名占位符

    三个关键字可以声明变量；var ，let,const
    
    3.31 var 
    可以多次声明变量，声明多个多个变量
    var string = "hi"
    如果去掉 var  string=“hi"吃屎string是全局变量
    
    变量提升   只是变量的提升命名不提升
    let 
    1,let声明的范围是块作用域，而var声明的范围是函数作用域
    
    2,let声明的变量不会别提升
         console.log(b); //--undefined
       var b = 2 
    
       console.log(a); //----a没有定义
       let a = 1
    3,不会和window相映射
        var a = 0;
      console.log(window.a); //--0
      let c = 0;
      console.log(window.c);--undefind
    4,let 在条件判断中，try catch中尽量不使用let，因为let是块作用域，
    5，for循环和定时器共同使用，输出0,1,2,3
        将var改成let 
    
    const
    1,const 声明的变量一旦声明不能修改，
    2，和let一样 不与window相映射 受限于块级 暂存性死区
    3，定义对象中的属性可以的，
    4， 使用到for in，for of 循环中
    
    优先使用const，如果需要更改的则使用let，以后var会用的很少。
    因为变量有了明确的作用域、声明位置，以及不变的值。
## 3.4 数据类型

​    3.41，undefined 定义未被初始化，
​    未定义会报错；
​    用typeOf 检查  定义未被初始胡和未定义都是undefined
​        undefined是一个假值
​    var message ;
​      console.log(message);//undefined
​      console.log(d);//报错

      console.log(typeof message);//undefined
      console.log(typeof d); //---undefined
    3.42，null
      1，null值表示一个空对象指针，所以给typeof会返回“object”
      2，在定义将来要报错对象值的变量时候，建议使用null来初始化
        if(car! = null){
            //表示car是一个对象的引用
        }
      3，undefined是由null值派生来的，定义为表面上的相等
      console.log(undefined == null)  -----true
      4,即使null和undefined 有关系，他们的用途完全不一样。永远不必显式的将变量值设置为 undefined。当时null之哟啊变量要 报错对象，而当时有解忧对象可以保存，可以用null来填充变量
    3.43 boolean类型
        1，boolean 有两个字面量：true和false
        2，可以用来赋值
            let found = true;
            let lost = false;
        3,是区分大小写的
            True False是有效的标识符，但不是布尔值
        4，可用Boolean()将其他的数据类型转换成布尔值
        空字符串"",数值型 0，NaN ,null,undefined 转换成false；；；
        其他的转换成true
        var msg = "hello";
        if(msg){
            console.log("你好"); 
        }       //会打印出 "你好"
    3.44 Number 类型
        不明白
        浮点数和整数
        NaN 不是数值
            isNaN()用于判断是不是数值型
        转换成数值型Number(),parseInt(),parseFloat()
            一样用parseInt()转换成整型，parseFloat()转换浮点型
    3.45字符串
        1，字符串可以使用双引号，单引号，反引号
        2，字符字面量
            \n 换行 \t 制表 \b退格 \r回车 
            \f换页 \\\\反斜杠 \' 单引号……
    
        3,，字符串是不可变的，修改某个变量中的字符串，必须先销毁原始的字符串，将包含新值的保存到变量
        4，转换为字符串
            toString();
            但是null,undefined用string()来转换成自身的字面量
        5，模板字符串
            标签那部分没看明白
    3.46 Symbol 符号 唯一的标志符
            
    3.47 Object类型
        在ECMAScript中的Object时候派生其他对象的基类。Object类型的所有属性和方法在
        派生的对象上同样存在
        每个Object实例都有如下属性和方法
        1，constructor 用于常见当期那对象的函数。在前面的例子中，这个属性的值就是Object()hanshu 
        2,hasOwnProperty(propertyName);:用于判断当前对象实例时候存在给定的属性。
            检查的是字符串 o.hasOwnProperty('name')
        3,isPrototypeof(object):用于判断当前对象是否为另一个对象的原型
        4，propertyIsEnumerable(propertyName) ：用于判断给定
            的属性是否可以使用（本章稍后讨论的） for-in 语句枚举。
            与 hasOwnProperty() 一样，属性名必须是字符串。
        5，toString()返回对象的字符串表示
        6valueOf() 返回对象对应的字符串、数值或布尔值表示。通常与toString(d fanhuizhi xinagong )
## 3.5 操作符

​    3.51 一元操作符
​    3.52位操作符
​    3.53布尔操作符
​        逻辑或
​        逻辑非
​        逻辑与
​    3.54 乘性操作符，除性操作符，取模
​    3.55 指数操作符 es7新增  
​            Math.pow() ===>对应的操作符是 **
​            console.log(Math.pow(3,2))===9
​            console.log(3 ** 2)===9

            console.log(Math.pow(16，0.5))===4
            console.log(16**0.5)===4
    
        还可以赋值操作
            let squar = 3;
            squar **=2;
            console.log(squared);====9
    3.56 加法 +
         减法 -
    3.57 关系操作符
        < > <= >=
    3.58 == === != !==
    3.59 条件操作符(二元表达式)
    3.6逗号操作符
        用来在一条语句中执行多个操作
# 第四章 变量、作用域与内存

## 4.1 原始值和引用值

​    变量包含两种不同类型的数据：原始值和引用值
​    原始值就是最简单的数据，引用值则是由多个值构成的对象
​    再把一个值赋值给变量时，js引擎必须确定这个值是原始值还是引用值
​    原始值(Undefined,Null,Boolean,Number,String,Symbol)
​    保存原始值的变量是 按值 访问的，因为我们操作的就是存储在变量中的实际值
​    引用值是保存在内存中的对象。与其他语言不同，js不许直接访问内存位置，不能直接操作对象所在的内存空间。
​        在操作对象时候，实际上操作的是改对象的引用而非实际的对象本身。因此保存引用值的变量是按引用访问的
​    4.11 动态属性
​        引用类型可以添加、删除、修改属性。而原始值没有属性
​    4.12 复制值
​        原始值和引用值 
​        通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置
​        引用值 把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，他指向存储在堆内存中的对象
​    4.13 传递参数 不明白
​    4.14 确定类型
​        typeof 操作符最适合用来判断一个变量是否是原始类型。可以检测 字符串。数值、布尔值、或undefined的最好方式
​        如果值是对象或者是 unll 用typeof来检测返回 “object"
​        typeof操作符用于检测函数时会返回“function”

##     4.2 执行上下文与作用域

​        看后面的小结部分会明白些   
​        执行上下文和 变量、函数预解析的关系
​    4.21 try catch; with 
​    4.22 1，使用var声明的作用域
​         写在函数内部的是局部变量，未写在函数内部的是全局变量。。
​         name = 1；；这种形式没有var，，是全局变量
​         变量提升
​         通过在声明之前打印变量，可以验证变量是否被提升。声明的提升意味着 会输出undefined而不是Reference Error
​         2,使用let的块级作用域
​         在同一个块级作用域中，let重复声明会报错，
​         var 则不会报错
​         let 非常适合在循环中声明迭代变量。使用var声明的变量会泄漏到外面，而 let不会
​         严格将 let 在js运行时也会被提升，但由于“暂时性死区”实际上不能在声明之前使用let变量
​         3，const 声明的变量必须赋值(声明的变量必须同时初始化为某个值)，
​            一经声明，在声明周期的任何时候都不能在重新赋予新值
​        const声明只应用到顶级原语或者对象。换句话说，赋值为对象的const变量不能在被重新赋值为其他引用值，但对象的键则不受限制

        如果，想让整个对象都不能修改，使用Object.freeze()
        const a1 = Object.freeze({});
        a1.name ="jack";
        console.log(a1.naem) //undefined
    
        由于 const 声明 暗示变量的值是单一类型且不可修改，js运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的V8引擎就执行这种优化
    
    4.23 标识符查找

## 4.3 垃圾回收

​    在执行环境负责在代码执行时管理内存。
​    通过自动内存管理实现内存分配和限制资源回收。基本思路很简单：确定哪个变量不会在使用，然后释放他占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间就会自动执行，，但是某块内存是否还有用，属于“不可判定的”问题
​    如何标记未使用的变量也许有不同的实现方式在浏览器的发展史上，勇敢到过阆中主要的标记策略：标记清理和引用计数
4.31 标记清理？？？
4.32 引用计数 使用中会有很多问题
4.33 性能
​     现在垃圾回收程序会基于对js运行时环境的探测来决定何时运行。参测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的

     将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保住在执行代码时值保存必要的数据。如果数据不再必要，那么把它设置为null,从而释放其引用。这也可以叫做 解除引用。
     这个建议最适合全局变量和全局对象的属性。
     局部变量在超出作用域后会被自动解除引用，
     解除引用的关键在于确保相关的值已经不再上下文里里，因此他咋下次垃圾回收时会被回收
    
     1，通过let和const来提升性能
        不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。
        因为都以块为作用域，相比较var，会增早让垃圾回收程序介入
        在块作用域比函数作用域更早终止的情况下，这就有可能发生
    2 隐藏类 和 删除操作
    3 内存泄漏
        内存有限，多次调用，会有内存泄漏的问题
        js中的内存泄漏大部分是有不合理的引用导致的
            没有var const let声明的变量。相当于window.name ="jack".只要window本事不被清理就不会消失。
        定时器，，定时器的回调通过闭包引用了外部变量。。。定时器一致运行，回调函数中国引用的全局变量就会一直占用内存
        js闭包很容易在不知不觉中造成内存泄漏
    4 静态分配与对象池
        如何减少浏览器执行垃圾回收的次数。
        开发者无法直接控制什么时候开始收集垃圾，但可以简介控制触发垃圾回收的条件。
        理论上将 合理使用分配的内存，同时避免多余的垃圾回收，可以保住因释放内存而损失的性能
    
        浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后又超出了作用域，浏览器就会采用更激进的方式调度垃圾回收程序运行。这样就会影响性能
        对象池？？？？


​    
## 4.4 小结  复制过来。。

看完小结对前面的内容理解的更多一些。下次先看小结部分

JavaScript变量可以保存两种类型的值：原始值和引用值。原始值
可能是以下6种原始数据类型之一： Undefined 、 Null 、
Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有
以下特点。
原始值大小固定，因此保存在栈内存上。
从一个变量到另一个变量复制原始值会创建该值的第二个副本。
引用值是对象，存储在堆内存上。
包含引用值的变量实际上只包含指向相应对象的一个指针，而不
是对象本身。
从一个变量到另一个变量复制引用值只会复制指针，因此结果是
两个变量都指向同一个对象。
typeof 操作符可以确定值的原始类型，而 instanceof 操作
符用于确保值的引用类型。
任何变量（不管包含的是原始值还是引用值）都存在于某个执行
上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生
命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如
下。
执行上下文分全局上下文、函数上下文和块级上下文。
代码执行流每进入一个新上下文，都会创建一个作用域链，用于
搜索变量和函数。
函数或块的局部上下文不仅可以访问自己作用域内的变量，而且
也可以访问任何包含上下文乃至全局上下文中的变量。
全局上下文只能访问全局上下文中的变量和函数，不能直接访问
局部上下文中的任何数据。
变量的执行上下文用于确定什么时候释放内存。
JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分
配和回收。JavaScript的垃圾回收程序可以总结如下。
离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被
删除。
主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标
记，再回来回收它们的内存。
引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。
JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这
种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如
DOM元素）。
引用计数在代码中存在循环引用时会出现问题。
解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮
助。为促进内存回收，全局对象、全局对象的属性和循环引用都
应该在不需要时解除引用。

# 第五章:基本引用类型

引用值(或者对象)是某个特定 引用类型 的实例。在ECMAScript 中，引用类型是把数据和功能组织到一个的结构。
    注意和 “类”区分开。但EAMAScript缺少传统的免息那个对象编程语言所具备的某些基本结构，包括类和接口。
    引用类型有时候也被称为 对象定义，因为他们描述了自己的对象应有的属性和方法 
    对象被认为是 某个特定引用类型的实例。 新对象通过使用 new 操作符后跟一个构造函数 来创建。构造函数就是用来创建新对象的函数
        例如：let now = new Date();
        Date()在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。
    ECMAScript提供了很多像Date这样的原生引用类型，帮助开发者实现常见的任务。

## 5.1 Date

​    Date类型可以精确表示1970年1月1日
​    要创建日期对象，就使用new 操作符来调用Date构造函数  let now = new Date();
​        bu不传递参数的情况下，创建的对象将保存当前日期和时间
​    如果要基于其他日期和时间创建日期对象，必须传入器毫秒表示 提供了两种辅助方法
​        Date.parse() 和 Date.UTC()
​        Date.parse()方法接收一个便是日期的字符串参数，转换成日期的毫秒数
​        let someDate = new Date(Date.parse('May 23,2019'));
​        let someDate = new Date(('May 23,2019'));
​        这两行得到的日期对象相同
​        Date.UTC()
​        也是返回事件的毫秒数，但是传递的参数是 年。零起点月数（1月是0,2月是1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒，前两个是年月是必须的。如果不提供日，那么默认为1日。其他参数默认值是0
​        let time = new Date(Date.UTC(2000,0)) --2000年一月一日零点
​        Let timer = new Date(Date.UTC(2000,5,5,17,55,55)); 第二个日期表示2005年5
月5日下午5点55分55秒
​        上面的例子也可以这样写
​        // 本地时间2000年1月1日零点
​            let y2k = new Date(2000, 0);
​            // 本地时间2005年5月5日下午5点55分55秒
​            let allFives = new Date(2005, 4, 5, 17, 55, 55);

        Date.now() 返回表示方法执行时日期和时间的毫秒数。可以方便的用在代码中。起始时间，间隔时间
    5.1.1 继承的方法
        toLocalString()  月 日 年 时分秒 上午或下午 没有时区
        toString() 有时区  输出和toLocalString趋于一致，在现代浏览器中
        valueOf()  返回的毫秒数  在new Date(时间之后)  可以进行比较 < >
    5.1.2 日期格式化方法
        有多个，但都会返回字符串
        toUTCString()显示完整的UTC日期   UTC 格林威治时间
            var a = new Date();
            var b = a.toUTCString();
            console.log(b);   完整 的格式  
    5.1.3 日期 时间组件方法
            getTime() 返回日期的毫秒表示，与valueOf()相同
            getFullYear()  返回 4位数年 返回2019
            getMonth() 返回日期的月(0表示1月，11表示12月)   
            getDate() 返回日期中的日（1-31）
            getDay() 返回 星期（0表示周日，6表示周六）
            getHours() 返回 时
            getMinutes() 返回  分钟
            getSeconds() 返回 秒（0-59）


## 5.2 RegExp

​    let expression = /pattern/flags;
​    pattern(模式)可以是任何简单后复杂的正则白哦哦但是，包括字符类、限定符、分组、向前查找和反向引用
​    1，匹配模式的标记 g i m y u s 
​    2,任何使用字面量定义的正则表达式也可以通过构造函数来创建
​     let pattern1 =/[bc]at/i;
​     let pattern2 = new RegExp('[bc]at','i')
​     这两个是的等效的正则表达式。狗战胜的两个参数都是字符串。
​     因为RegExp的模式参数是字符串，在某些情况下需要转义。所有元字符都必须二次转义，包括转义字符序列
​     需要转义，没看明白？？？不过字面量模式要简单写，多使用
5.21 RegExp实例属性
5.22 RegExp实例方法
​    exec() 主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串
​    什么是捕获组？？？？
​    没有补货组，数组中只包含一个元素，为什么是 那些结果
​    test(),接收的是字符串参数。 如果输入的文本域模式匹配，则参数返回true，否则返回false。
​        适用于只想测试模式是否匹配，而不需要事件匹配内容的情况。test()经常用在if语句中
​     let text = "000-00-0000";
​        let pattern = /\d{3}-\d{2}-\d{4}/;
​        if (pattern.test(text)) {
​        console.log("The pattern was matched.");
​        }   
​        这种用法常用于验证用户输入，我们只在乎输入是否有效，不关心为什么无效
​     无论正则表达式是怎么创建的，继承的方法 toLocaleString() 和
​        toString() 都返回正则表达式的字面量表示。比如：   
​        let pattern = new RegExp("\\[bc\\]at"
​                ,
​                "gi");
​                console.log(pattern.toString()); // /\
​                [bc\]at/gi
​                console.log(pattern.toLocaleString()); // /\
​                [bc\]at/gi

        toString toLocalString 这两种方法不是用在Date吗?????
5.2.3 RegExp 构造函数属性
5.24 模式局限
    虽然js对正则表达式 支持有了长足的进步，但仍然缺少Perl语言中一些高级特性

## 5.3 原始值包装类型

​    方便操作原始值，ECMAScript提供了3中特殊的引用类型  Boolean Number String
​    没用到某个原始值的方法或属性时候，后台会创建一个相对应原始包装类型的对象，从而暴露出操作原始值的各种方法 
​        let s1 = "some text"
​        let s2 =s1.substring(2)
​    区别：引用类型与原始值类型包装类型的主要区别在于 对象的生命周期，实例化引用类型后，得到的实例会在离开作用域是被销毁，而原始值包装对象值存在于访问他的那行代码执行期间。所以不能在运行时给原始值添加属性和方法

    在原始值包装类型对象调用 typeof 会返回 “object",都会转换为布尔值 true
5.31 Boolean
    对应布尔值 的引用类型
    let bool = new Boolean(true);
    console.log(bool) --true ;如果 后面括号中是false，返回false
    理解原始布尔值和boolean对象宅男的区别很重要。强烈建议不要使用后者
5.32 Number
        与 Boolean 类型一样， Number 类型重写了 valueOf() 、
    toLocaleString() 和 toString() 方法。 valueOf() 方法返回
    Number 对象表示的原始数值，另外两个方法返回数值字符串。
    toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式
    的数值字符串
     除了继承的方法外，Number类型还提供了 用于将数值格式化为字符串的方法
        toFixed()方法返回包含指定小数点位数的数值字符串
            let num = 10;
            console.log(num.toFixed(2)); // "10.00"
        如果数值本身的小数位超过了参数指定的位数，四舍五入到最接近的小数位
            let num = 10.005;
            console.log(num.toFixed(2)); // "10.01"
        注意多个浮点数值的计算不一定得到精确的结果
    toPrecision() 返回的结果可能是长度，也可能是科学计数法形式，接收一个参数表示数组的总位数
        let num = 99; 
            console.log(num.toPrecision(1)); // "1e+2" ---100 因为只能用一位数表示99，99不能只用1位 数组来精确表示，所以四舍五入为100
            console.log(num.toPrecision(2)); // "99"
            console.log(num.toPrecision(3)); // "99.0"
5.33 string
    1，String 对象的方法可以在所有字符串原始值上调用。3个继     承的方法 valueOf() 、 toLcaleString() 和       toString() 都返回对象的原始字符串值。？？？？？
    2 ，javascipt字符
        javascipt字符串由16位码元组成。对多数字符来说，每16位码元对应一个字符。
        ·2.1字符串的length属性表示字符串包含多少16位码元
        ·2.2charAt() 传入索引位置返回对应的字符

    3，操作字符串值的方法
     3.1concat(),用于将一个或多个字符串拼接成一个新字符串；可以一次性拼接多个字符串，但是不改变原来的字符串
        let stringValue = "hello ";
        let result = stringValue.concat("world","!");
        console.log(result); // "hello world!"
        console.log(stringValue); // "hello"
        3.2 三种从字符串中提取字符串的方法
            slice(start,end)
            substr(start,length) 
            substring(start,length)
# 第六章

## 6.1 Object

### 6.1.1 new操作符 ，创建对象

```js
 let person = new Object();
      perosn.name = "jack";
      person.age =29
```

### 6.1.2 对象字面量

对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建

```js
 let person ={
        name:'jackson',
        age:29
      }
```

也可以使用字符串、数字、Boolean类型来定义

```js
let person = { 
    "name": "jack", 
    "age": 29, 
    5: true,
	true: 123,
    false: 321
};
person[5];	//true
person[true];	//123
person[false];	//321
```

需要注意的是：后面的值会覆盖前面的值

```js
let person = { 
    "name": "Nicholas", 
    "age": 29, 
    5: true,
	true: 123,
    true: 555,
    name: 'jack'
};
console.log(person)
{5: true, name: "jack", age: 29, true: 555}

```

思考：

```js
let person = {
    5:15,
    true: 'yes',
    false: 'no'
};
person.5;	// ? true ,这样写会报错
person.true;	// "yes"
person.false;	// "no"
person.__proto__ === ?;  //答案是 Object.prototype 
person.__proto__.constructor === ?; //Object

let person = new Object();
person.__proto__ === Object.prototype  //true
person.__proto__.constructor === Object //true
```

### 6.1.3 访问对象的属性 有两种方式

点语法  和  中括号 方式

通常，点语法是首选的属性，除非访问属性的时候必须使用变量。

```js
访问变量时候，使用[]
let propertyName = "name";
console.log(person[propertyName]); // "Nicholas"
如果属性名中包含可能会导致语法错误的字符，或者包含关键字和保留字时候，使用中括号
person["first name"] = "Nicholas";
let person = { 
	"name": "Nicholas", 
	"age": 29, 
	5: true,
	true: 123
};
person['name'];	//"Nicholas"
person['age'];		//29
person['name'] = 'jack';
person['age'] = 30;
person[true];	//123
person[5];	//true

但是用点语法 person.5 会报错 Unexpected number
person.true 会打印结果 123

```

思考：

```js
let name = {
    firstName: '张',
    lastName: '三'
};
let person = {
    [name]: '张三'
}
console.log(person[name]) //张三，因为中括号可以访问到变量的值
```

## 6.2 Array

### 6.21 Array 构造函数  创建数组

```js
//1,
      let colors = new Array();
      color.length;
//2,
      let colors = new Array(5);//表示创建一个长度为5的空数组
      colors.length //5
      colors[0]; //undefined
 //2.1
      let colors = Array(5);// 也可以这样创建，不用new
 //3,
      let colors = new Array('red','blue','green'); //表示创建一个数组，并传入三个值
      colors.length; // 3;
      color[0];// "red"
 //3.1 不用new 也可以
      let names = Array('gery');
```

思考：

```js
	  let colors = new Array(3);  //这是创建一个长度为3的空数组
      colors[0] //undefined 
      colors.length;//3
```

### 6.22 用字面量方式创建 数组

```js
//1,
      let colors =['red','blue','green'];//创建一个包含3个元素的数组
      let names =[];//创建一个空数组
      let values = [1,2,] //创建一个包含2个元素的数组
      let ages=[,,,]//创建一个包含三个元素的空数组
//2
      colors.length(2);//直接改变color数组的长度
      colors[2] //undefined

```

思考：

```js
let cars = [1,2,,,];
cars.length;	//4

let cats = [1,2,,,5];
cats.length;	//5
cats[cats.length - 1];	//5    cats.length =5 5-1=4 cats[4]--- 5

let dogs = [1,2,3];
dogs.length = 5;
dogs.length;	//5
dogs[dogs.length - 1];	// 5-1=4 dogs[4]---undefined
```

### 6.23 Array.from

from () 用于将类数组结构转换为数组实例，而of()用于将一组参数转换数组实例

第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构

# 第八章

## 1.1 对象属性的类型

### 1.1.1 configurable

表示属性是否可以通过delete 删除并重新定义，是否可以修改他的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true

```js
let person ={};
Object.defineProperty(person,'name',{
	configurable:false,
	value:undefined
});
console.log(person);
//{name:undefined}
delete person.name;//false
console.log(person);
//{name:undefined}

let person ={};
Object.defineProperty(person,'name',{
    configurable:true,
    value:undefined
});
console.log(person);
//{name:undefined}
delete person.name; // true
console.log(person);// {}
```



### 1.1.2 enumerable

### 1.1.3writable

### 1.1.4value

### 1.1.5get

### 1.1.6 set

## 1.2 getOwnPropertyDescriptor

## 1.2 getOwnPropertyDescriptors

## 1.3 合并对象 -- 深浅拷贝

#### ·在es6 之前，通常会封装一个方法，可参考jquery的extend方法

```js
var obj ={
	a:1,
	b:2
}
var obj1 ={
	c:3,
	a:5
}
{
	a:5,
	b:2,
	c:3
}
```



```js
//一个特别简单的浅拷贝  使用extend
function extend(target,source){
  target = target || {}; //用来判断target是一个对象
  if(typeof target !== 'object'){
    throw new Error('target不是对象');
  }
  if(!source){
    throw new Error('source不能为空');
  }
  if(typeof source !== 'object'){
    throw new Error('source不是对象');
  }
  for(let key in source){
    target[key] = source[key] //然后将源对象的值赋值到target中
  }
  return target;//最后返回target
}
 
    var obj = extend({
        a:1,
        b:2
    },{
        c:3,
        a:5
    })
    console.log(obj)
    /*
    
      a:5,
      b:2,
      c:3

      将source对象中的值，赋值到target上。return出target
      判断是对象；；；循环source中的值 然后赋值；；；返回target对象      
    */
```

#### ·object.assign

用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target).源对象可以是多个，后者替换前者

```js
 let obj = Object.assign({a:1},{b:2},{c:3},{a:5},{b:6})
    console.log(obj)
```

出现的问题：

以上方法都是 **浅拷贝**，如果拷贝属性是对象，那么拷贝的只是引用

```js
 var obj ={
        a:1,
        b:'fff'
    }
    var obj1={
        a:2,
        c:{
            name:'李四',
            age:20
        }
    }
     var obj2 = Object.assign({},obj,obj1);
     obj1.a=3;
     obj1.c.name = "王五";
     obj1.c.age =30;
     console.log(obj2);//obj2.c会跟着obj1.c 的改变而改变
```

#### 深拷贝



## 1.4解构

## 1.5  创建对象

### 1.51 简单工厂模式 

### 1.52 构造函数模式

### 1.53 原型模式

## 1.6 hasOwnProperty

## 1.7 keys

## 1.8 getOwnPropertyNames

## 1.9 values

## 1.10 entries

## 1.11 继承

## 1.12 原型链

## 1.13 面向过程

## 1.14 面向对象

## 1.15继承

### 1.15.1 组合继承

### 1.15.2 原型式继承

### 1.15.3 盗用构造函数

### 1.15.4 组合继承

## 1.16 class类

### 1.16.1 类的构成



### 1.16.2 类构造函数

### 1.16.3 继承

## 1.17作业

- **使用ES5和class两种方法实现以下需求：**

1. 设计一个`Person`（人）基础类，有姓名、年龄、性别、血型等属性。会走路、吃饭、自我介绍、睡觉。
2. 设计`Famer`（农民）类，继承自`Person`，会种地。
3. 设计`BusinessMan`（商人）类，继承自`Person`，会做生意。
4. 设计`Coder`（程序员）类，继承自`Person`，会写代码。
5. 设计`JavaCoder`（`java`程序员）类，继承自`Coder`，会写`Java`的代码。
6. 设计`JSCoder`（`JS`程序员）类，继承自`Coder`，会写`JS`代码。
7. 设计`VueCoder`（`Vue`程序员）类，继承自`JSCoder`，会开发`Vue`项目。
8. 当调用自我介绍的方法时，每个人都要完整的说出自己会的每一项技能，如`VueCoder`会说：我叫xxx，今年xx岁了，我的性别是x，血型是x。我是个程序员，会写代码。JS是我的主力语言。不过我目前主要还是做Vue开发。

```js
 //使用class 完成
        //定义基类 
        class Person {
            constructor(name, age, sex, blood) {
                this.name = name;
                this.age = age;
                this.sex = sex;
                this.blood = blood;
            }
            //定义的函数（自我介绍) 

            introduction() {
                console.log(`我叫${this.name},今年${this.age}岁了,我的性别是${this.sex},血型是${this.blood}型`)
            };

            walk() {
                console.log('我会走路')
            };
            eat() {
                console.log('我会吃饭')
            };
            sleep() {
                console.log('我会睡觉')
            }
        }
        // 农民
        class Famer extends Person {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood)
            }
            //自我介绍
            introduction() {
                super.introduction();
                console.log('会种地')
            }
        }
        let person = new Person('人', 21, '女', 'A')
        let famer = new Famer('农民', 20, "男", "b");
        famer.introduction();
        person.introduction();

        // 商人
        class BusinessMan extends Person {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood)
            }
            //自我介绍
            introduction() {
                super.introduction();
                console.log('会做生意')
            }
        }
        let bussiness = new BusinessMan('商人', 40, '男', 'c')
        bussiness.introduction();

        //Coder 程序员类
        class Coder extends Person {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood);
            }
            //自我介绍
            introduction() {
                super.introduction();
                console.log('会写代码');
            }
        }

        let coder = new Coder('程序员', 18, '女', 'B')
        coder.introduction();

        //Java 程序员
        class JavaCoder extends Coder {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood);
            }
            //自我介绍
            introduction() {
                super.introduction();
                console.log('会写Java代码');
            }
        }

        let javacoder = new JavaCoder('JAVA程序员', 30, '男', 'A');
        javacoder.introduction();

        //jsCoder  
        class jsCoder extends Coder {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood);
            }
            //自我接收
            introduction() {
                super.introduction();
                console.log('会写JS代码');
            }
        }
        let jscoder = new jsCoder('小王', 23, '女', 'A');
        jscoder.introduction();

        // vueCoder 
        class VueCoder extends jsCoder {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood);
            }
            //自我介绍
            introduction() {
                super.introduction();
                console.log('js是我的主力语言。不过我目前主要还是做Vue项目开发');

            }
        }
        let vuecoder = new VueCoder('小敏', 26, '女', 'C');
        vuecoder.introduction();


        // 使用es5 完成  没有完成，不是使用继承父类的方法
        function Person(name, age, sex, blood) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.blood = blood
        }
        Person.prototype.introduction = function () {
            console.log(`我叫${this.name},今年${this.age},性别：${this.sex},血型:${this.blood}`);
        }


        // function Famer() {
        //     Person.call(this);
        // }
        // Famer.prototype = Object.assign(Object.create(Person.prototype), {
        //     constructor: Famer
        // });
        function Famer(){
            
        }
        Famer.prototype = new Person();
        let liye = new Person('立业', 20, '男', 'b');
        liye.introduction();
        let famer = new Famer('农民', 30, '男', 'a')
        famer.introduction();






        // function superType() {
        //     console.log('superType执行了一次');
        //     this.name = '张三';
        //     this.children = ['张欣', '张宇'];
        // }
        // superType.prototype.age = function(){
        //     console.log(`我叫${this.name}`);
        // };

        // function sub() {
        //     superType.call(this);
        // }

        // //直接继承原型，不用再次实例化父类构造函数，防止再次执行父类构造函数
        // //sub.prototype = Object.create(superType.prototype, { constructor:{ value:sub, enumerable:false } });

        // //跟上面的一样，只是最后自己手动修改一下构造函数的指向
        // sub.prototype = Object.create(superType.prototype)
        // sub.prototype.constructor = sub;

        // //使用浅拷贝的方式将自身的构造函数替换掉父类原型的构造函数
        // //sub.prototype = Object.assign(Object.create(superType.prototype), { constructor: sub });

        // var s = new sub();
        // console.log(s.name); //张三
        // console.log(s.hasOwnProperty('name')); //true
        // console.log(s.hasOwnProperty('children')); //true

        // var s1 = new sub();
        // s1.children.push('李四');
        // console.log(s1.children);
        // console.log(s.children);

        // console.log(s.constructor === sub); //true
        // console.log(s instanceof sub); //true
        // console.log(s instanceof superType); //true
        // console.log(s.age, s1.age); //12 12
```



# 一，作用域

javascript 一门解释型语言，运行到哪一段代码，就分析、编译哪一段代码，不会像其他编译型语言会提前将分析、编译等操作完成。所以 JavaScript的运行会分为两个阶段：分析阶段（分词、预编译）、执行阶段。

------

作用域的意思就是变量在哪个区域起作用（可以被访问）。离开这个作用域后无法访问到这个作用域内的变量了，例：

```js
function scope() {
    var a = 1;
    console.log(a); //这个作用域内可以被访问
}
scope();    //1
console.log(a); //报错，因为出了scope函数作用域了
```

作用域又分为：全局作用域、块级作用域、函数作用域

## 1,全局作用域

无论在何处都可以被访问到，全局作用域中定义的变量和方法都会被绑定到window上

```js
var a = 1;  //全局变量
function fnScope() {
    console.log(a); //函数作用域中可以访问到
}
{
    console.log(a); //块级作用域中也可以访问到
}
```



## 2，块级作用域

以{}包裹的就是块级作用域（es6 新增的let、const定义的）。

```js
{
    let a = 1;
    const b = 2;
    console.log(a);     //只有在这个块级作用域中才能访问到a
}
console.log(a);     //出了块级作用域访问不到a了
console.log(b); 
```

```js
{
    var a = 1;  //提升
}
console.log(a);     //1
```

```js
if (false) {
    var a = 1;  //提升，但是执行阶段不赋值
}
console.log(a);     //undefined
```

思考：

```js
{
    function init() { }
}
console.log(init);	// ？

if (false) {
    function init() { }
}
console.log(init);	// ?

{
    function init() { }
    init = 3;
}
console.log(init);	// function init() { }

{
    function init() { }
    init = 3;
    console.log('kuai', init);	// 3
}
console.log(init);	// function init() { }

{
    init = 4;
    function init() { }
    init = 3;
    console.log('kuai', init);	// kuai,3
}
console.log(init);	// 4


{
    init = 4;
    function init() { }
    init = 3;
    console.log('kuai', init);
    function init() { }
    var init = 5;
}
console.log(init);
// Uncaught SyntaxError: Identifier 'init' has already been declared


function fn() {
    console.log('out');
}
if (false) {
    function fn() {
        console.log('inner');
    }
}
fn();	// out
```

在同一个块级作用域中，如果有申明式函数，后面对于此函数的表达式更改都将被保护。但是在申明式函数前面的更改可以生效

```js
{
    init = 4;
    function init() { }
    init = 3;
    console.log('kuai', init);  // kuai 3
    function init() { }
    init = 5;
}
console.log(init);  // 3


{
    init = 4;
    function init() { }
    init = 3;
    console.log('kuai', init);  // kuai 3
    function init() { }
    init = 5;
    function init() { }
}
console.log(init);  // 5
```



## 3，函数作用域

在function 函数中的即是函数作用域

```js
function fnScope() {
    var a = 1;
    console.log(a);     //在此函数作用域中可以访问到a
}
console.log(a);     //出了函数作用域就访问不到a了
```

```js
function fn() {
   console.log('out');
}
function init() {
    if (false) {
        function fn() {       console.log('inner');
        }
    }
    fn();	// Uncaught TypeError: fn is not a function
}
init();
/*
因为函数作用域下fn会提升，但如果为false的话，方法体不会提升。所以最终变为了：
function init() {
	var fn;
    if (false) {
    }
    // fn为undefined
    fn();	// Uncaught TypeError: fn is not a function
}
*/
```

思考：

```js
function fn() {
    console.log('out');
}
function init() {
    if (true) {
        function fn() {
            console.log('inner');
        }
    }
    fn();	// ?
}
init();
```



# 二、词法作用域

JavaScript 采用词法作用域（静态作用域），词法作用域是在分析阶段确定的。无论函数在哪里被调用，也无论他如何被调用，它的此法作用域都只由函数被声明时所处的位置决定（小技巧：除了this定义和调用的值，其他都是在词法作用域中）。

```js
var a = 123;
function parent() {
    var a = 321;
    function child() {
            console.log(a);   //做词法分析的时候就已经确定了调用parent的词法作用域中的a
    }
    child();    //321
    return child
}
const p = parent();     //无论调用位置在哪里
p();    //321
```

在来看看this 绑定的效果：

```js
var a = 123;
function parent() {
    var a = 321;
    function child() {
        console.log(this.a);   //运行时才能确定this的指向，确定了this的指向后才能确定a的值
    }
    child();    //123 this指向window
    return child
}
const p = parent();
p();    //123
```

```js
var a = 123;
function parent() {
    var a = 321;
    function child() {
        console.log(a);   //做词法分析的时候就已经确定了调用parent的词法作用域中的a
    }
    child();    //321
    return child
}
const child = parent();
var obj = {
    a: 555,
    child: child
}
obj.child();    //321 无论怎么调用，在哪里调用这个方法永远都打印321
```



# 三，执行上下文

当JavaScript 代码执行一段可执行代码（executable code)时，会创建对应的执行上下文（execution context)。

对于每个执行上下文，都有三个重要属性：

​	·变量对象（Variable object,vo)

​	·作用域链（Scope chain)

​	· this

## 1.1变量对象

​	 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

### 1.11 全局上下文

可以通过 this 引用，在客户端 JavaScript中，全局对象就是 window对象。

```js
console.log(this);	//window
```

全局对象是由 Object 构造函数实例化的一个对象

```js
xxxxxxxxxx console.log(this instanceof Object);
```

预定义了一堆，大堆函数和属性

```js
//都能生效
console.log(Math.random());
console.log(this.Math.random());
```

作为全局变量的宿主

```js
var a = 1;
console.log(this.a);
```

客户端 JavaScript 中，全局对象有window属性 指向自身

```js
var a = 1;
console.log(window.a);	//1

this.window.b = 2;
console.log(this.b);	//2

console.log(self);	//window
console.log(globalThis);	//window
```

全局上下文中的变量对象其实就是全局对象

### 1.12 函数上下文

在函数上下文中，我们用活动对象`(Activation Object, AO)`来表示变量对象。活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在`JavaScript`环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫`Activation Object`，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。

活动对象是在进入函数上下文时被创建的，他通过函数的 arguments 属性初始化。 arguments属性值是 Arguments对象

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};
  b = 3;
  console.log(a);
  console.log(b);
}
foo(1);
```

在进入执行上下文后。

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}

//var person = { name: '张三', age: 13 }; obj.name;
```



## 1.2作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一致找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链条就叫做作用域链

函数有一个内部属性[scope]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解[scope]就是所有父变量对象的层级链

```js
function foo() {
    function bar() {
        //更多代码
    }
}
```

函数创建时，各自的[scope]为：

```js
foo.[scope] = [
  globalContext.VO
];

bar.[scope] = [
    fooContext.AO,
    globalContext.VO
];
```

子作用域可以访问父作用域的变量，父作用域不能访问子作用域的变量(只能自下往上查找，不能自上往下查找).

```js
x function parent() {    var a = 1;    function child() {        var b = 2;        console.log(a); //可以访问到parent中的a    }    console.log(b);     //报错，因为访问不到child中的b}
```



## 1.3 this

​	前面已经提到 javascript 采用的是静态作用域，但是this 算是模仿了动态作用域，this是在执行阶段是确定的

### 	1.31 默认绑定

​	不带任何修饰的函数进行调用的，只能采用默认绑定，this指向全局对象 window。

###### 注意：

严格模式下不能将全局对象用于默认绑定，因此this绑定到undefined

```js
  function foo(){
        console.log(this); //window
        console.log(this.a); // 12
    }
    var a =12;
    foo(); //foo()这种就是不带任何修饰符，指向全局window

//第二题：
function a() {
    console.log('a', this);	//'a' window
}
function b() {
    a();
    console.log('b', this);	//'b' window
}
function c() {
    b();
    console.log('c', this);	//'c' window
}
c();
```

思考：

```js
var a = 12;
function test() {
    this.a = 13;
}
test();
console.log(a);	//13

分析：
var a = 12,,,window.a = 12
进入test函数中  this= window  则this.a =13,也就是window.a = this.a =13;
下面 test() --->window.a = 13;
所以console.log(a) --->13
var a = 12; // window.a=12
function test(){
    //此时 window = this,因为this.a=13,那么 
    this.a = 13;
    //window.a = 13;
}
test();//window.a = 13;
console.log(a);//13
```



### 	1.32隐式绑定

​		对象内部包含一个指向函数的属性，并通过这个属性间接引用这个函数，从而把this间接（隐式）绑定到这个对象上

·无论是直接在obj中定义还是在添加为引用属性，这个函数严格来说都不属于obj对象

```js
function foo() {
    console.log(this);	//{a: 2, foo: ƒ}
    console.log(this.a);	//2
}

var obj = {
    a: 2,
    foo: foo
}
obj.foo();

var obj = {
    a: 2,
    foo: function() {
        console.log(this);	//{a: 2, foo: ƒ}
        console.log(this.a);	//2
    }
}
obj.foo();
```

·调用位置会使用obj上下文来引用函数，因此你可以说函数被调用是 obj 对象“拥有”或者“包含”函数引用。当foo()被调用时，他的前面确实加上了对obj的引用，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。因此调用foo()时this被绑定到obj，因此在函数中执行this.a和obj.a是一样的。

·对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。

```js
function foo() {
    console.log(this.a);
}

var obj2 = {
    a: 1,
    foo: foo
}

var obj1 = {
    a: 2,
    obj2: obj2
}
obj1.obj2.foo();    //1

var obj3 = {
    a: 3,
    obj1: obj1
}
obj3.obj1.obj2.foo();	//1

```



### 	1.33显示绑定

​		call,apply,bind 都属于显式绑定一类，显示绑定后 this便无法在修改

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.call(obj);
```

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.apply(obj);
```

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);	//2
}
var obj = {
    a: 2
}
var f = foo.bind(obj); 
f();
```



### 	1.34 new绑定

​	实例化一个新对象后，会将实例对象绑定到函数调用中的this上

```js
function foo(a) {
    console.log(this);	//foo {}
    this.a = a;
    console.log(this.a);	//2
}
var bar = new foo(2); 
console.log(bar.a); //2
console.log(a);	//Uncaught ReferenceError: a is not defined
```

思考：

```js
function foo() {
    console.log(this);	//obj
    console.log(this.a);	//2
}
var obj = {
    a: 2
}
var obj1 = {
    a: 20
}
var f = foo.bind(obj);
f = f.bind(obj1);
f();


//思考2
var num = 1;
function a1() {
    'use strict';
    console.log(this.num++); //严格模式下this是undefined，undefined.num++ 是undefined
}

function a2() {
    console.log(++this.num);
}

(function () {
    'use strict';
    a2();	//2
})()
a1();	//  undefined
知识点：
	1，num ++  是先+1，后打印console.log(num)
		++ num  是先打印，后+1
	2默认绑定，this指向全局，严格模式下this不能将指向全局，因此this会绑定到undefined
    3，‘use strict’ 只在当前作用域有效
    

//题3
function c1(name) {
    if (name) {
        this.name = name;
    }
}

function c2(name) {
    this.name = name;
}

function c3(name) {
    this.name = name || 'test'; //如果name是undefined或是null的时候，this.name= “test"
}

c1.prototype.name = 'c1';
c2.prototype.name = 'c2';
c3.prototype.name = 'c3';
console.log(new c1().name + new c2().name + new c3().name);		// c1undefinedtest
//new c2().name 没有传递值，是undefined，所以new c3().name 是test
```



### 	1.35 箭头函数

es6 新增的()=>箭头函数中，this在分析阶段时就确定了（跟函数中的this在执行阶段时确定相反），绑定的是父作用域中的this，指向永远不变。其实总结起来就两点：

· 外层有函数：外层函数的this就是箭头函数的this

```js
function ab() {
    var b = () => {
        console.log(this);
    };
    b();
}
ab();   //window，因为外层函数的this采用了默认绑定规则
```

```js
var obj = {
    a: 1,
    foo() {
        var fn = () => {
            console.log(this.a);
        };
        fn();
    }
}
obj.foo();  //1，外层函数的this采用了隐式绑定规则 foo()绑定到obj上，所以foo的this执行的是obj，， 那么fn里面的this.a指向的是foo()的this.a，，所以obj.a = 1
```

· 外层没有函数：箭头函数的this就是window

```js
var a = 123;
var obj = {
    a: 1,
    foo: () => {
        console.log(this.a);
    }
}
obj.foo();  //123
foo箭头函数外面没有函数，所以this指向的是window，那么window.a = 123；
```

思考：

```js
var a = 666;
var obj = {
    a: 1,
    obj: {
        a: 2,
        obj: {
            a: 3,
            foo: () => {
                console.log(this.a);
            }
        }
    }
}
obj.obj.obj.foo();	//? 666 
外层没有函数，那么foo箭头函数中的this指向window
```

```js
var a = 666;
var obj = {
    a: 1,
    foo() {
        console.log(this.a);
        var obj1 = {
            a: 2,
            foo: () => {
                console.log(this.a);
                function f() {
                    console.log(a);
                    console.log(this.a);
                }
                f();
                return f;
            }
        }
        obj1.foo()();
    }
};
obj.foo();  //? 1,1,666,666,666,666,
var ff = obj.foo;
ff();   //?666,666,666,666,666,666
```



## 1.4 总结

​	到目前为止还不知道执行上下文的结构。

接下来通过例子讲解

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();  // local scope
```

#### 1,全局执行上下文初始化

```js
globalContext = {
    VO: [global],	//window是暴露出来的一个指向全局变量对象的属性
    Scope: [globalContext.VO],
    this: globalContext.VO
}
```

#### 2，初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[scope]

```js
checkscope.[scope] = [
  globalContext.VO
];
```

#### 3,执行 checkscope函数，创建 checkscope 函数执行上下文有开始初始化。

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope: undefined,
        f: reference to function f(){}
    },
    Scope: [AO, globalContext.VO],
    this: undefined
}
```

#### 4，执行 f 函数，创建 f 函数 执行上下文并初始化

```js
fContext = {
    AO: {
        arguments: {
            length: 0
        }
    },
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
    this: undefined
}
```

思考:

```js
this.a = 20;
function go() {
    console.log(this);
    console.log(this.a);
    this.a = 30;
}
go.prototype.a = 40;
var test = {
    a: 50,
    init(fn) {
        fn();
        console.log(this.a);
        return fn;
    }
};
console.log(new go().a);	// 40 30
test.init(go);	// 20 50
var p = test.init(go);	// 30 50
p();	// 30 undefined
```



## 1.5 作业，

在0129 已经讲解

```js
作业1,
alert(a);	// ?	
a();
var a = 3;
function a() {
    alert(10);
}
alert(a);	// ?
a = 6;
a();	// ?

ao:
a:undefind   
a():alert(10)
没有函数嵌套，就没有作用域链；同时也没有this
var a = 3,赋值a = 3  所以第一行alert(a)--->3；；；
a()--->  alert(10)
alert(a)--->3
a=6  这是全局变量 ，所以将6赋值给 a 
a() ---->还是调用a()这个函数，所以还是alert(10)


```

```js
作业 2
var x = 1, y = 0, z = 0;

function add(x) {
    return (x = x + 1);
}
y = add(x);
console.log(y);	// ?
function add(x) {
    return (x = x + 3);
}
z = add(x);
console.log(z);	// ?
```

```js
作业 3
function foo() {
    console.log(this.a);
}
function doFoo(fn) {
    fn();   //调用位置
}
var obj = {
    a: 2,
    foo: foo
}
var a = 'this is global';
obj.foo();	//?
doFoo(obj.foo); //?
```

```js
作业 4 

function foo() {
    console.log(this.a);
}
function doFoo(fn) {
    fn();   //调用位置
}
var obj = {
    a: 2,
    foo: foo
}
var obj1 = {
    a: 3,
    obj: obj
}
var a = 'this is global';
obj1.obj.foo();	//?
doFoo(obj1.obj.foo); //?
```

```js
作业 5
function foo() {
    console.log(this.a);
}
function doFoo(fn) {
    fn();   //调用位置
}
var obj = {
    a: 2,
    foo: foo
}
var a = 'this is global';
setTimeout(obj.foo, 100);	//?
```

```js
作业 6
function foo() {
    console.log(this.a);
}
var obj = {
    a: 2
}
var bar = function () {
    foo.call(obj);
}
var a = 20;
bar();  //?
setTimeout(bar, 100);
bar.call(window);   //?
```

```js
作业 7
function foo() {
    console.log(this.a);
}
var obj1 = {
    a: 2,
    foo: foo
}
var obj2 = {
    a: 3
}
obj1.foo();     //?
obj1.foo.call(obj2);    //?
```

```js
作业 8
function foo(a) {
    this.a = a;
}
var obj1 = {
    foo: foo
}
var obj2 = {}
obj1.foo(2);
console.log(obj1.a);    //?
obj1.foo.call(obj2, 3);
console.log(obj2.a);    //?
var bar = new obj1.foo(4);
console.log(obj1.a);    //?
console.log(bar.a); //?
```

```js
作业 9 
function foo(a) {
    this.a = a;
}
var obj1 = {};
var bar = foo.bind(obj1);
bar(2);
console.log(obj1.a);    //?
var baz = new bar(3);
console.log(obj1.a);    //?
console.log(baz.a); //?
```

```js
作业 10 

var age = 12;
function a() {
    var age = 13;
    function b() {
        console.log(this.age);  //?
        console.log(age);   //?
        var age = 15;
        function c() {
            var age = 16
            console.log(this.age);  //?
            console.log(age);   //?
        }
        c();
    }
    b();
    console.log(age);   //?
    console.log(this.age);  //?
}
a();
```

```js
作业 11 
var age = 12;
function a() {
    var age = 13;
    function b() {
        console.log(age);
        var age = 15;
        function c() {
            var age = 16
            console.log(age);
        }
        c();
    }
    b();
    console.log(age);
}
a();
//请写出以上代码创建执行上下文创建过程
```

# 第十章

## 阅读以下小章节：

\1. 10.1 箭头函数。

\2. 10.3 理解参数。

\3. 10.5 默认参数值。

\4. 10.6.2 收集参数。

\5. 10.9.1 arguments。

\6. 10.9.3 caller

\7. 10.12 递归

\8. 10.14 闭包