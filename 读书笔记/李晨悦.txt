1.18
1、完整的JavaScript实现包含哪几个部分？
核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）
1、文档对象模型（DOM）：一个应用编程接口（API），用在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。HTML或XML页面的每个组成部分都是一种节点，包含不同的数据。
2、浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。

2、script 元素
1、async：表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效。
2、charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
3、crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。
4、src ：可选。表示包含要执行的代码的外部文件。
5、type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。

3、推迟的脚本
script 元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。因此，这个脚本完全可以在整个页面解析完之后再运行。在 script>元素上设置defer 属性，会告诉浏览器应该立即开始下载，但执行应该推迟。

4、异步执行脚本
async 属性从改变脚本处理方式上看defer 类似，两者只适用于外部脚本，会告诉浏览器立即开始下载；不过，与 defer不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执行。

5、动态加载脚本
通过向DOM中动态添加 script元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添加到DOM即可。

6、行内代码与外部文件
推荐使用外部文件，理由：
1、可维护性，用一个目录保存所有JavaScript文件更容易维护。
2、缓存，浏览器会根据特定的设置缓存所有外部链接的JavaScript文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。
3、适应未来。通过把JavaScript放到外部文件中，就不必考虑用XHTML或前面提到的注释黑科技。包含外部JavaScript文件的语法在HTML和XHTML中是一样的。

7、文档模式
概念：即可以使用 doctype 切换文档模式。
混杂模式、标准模式、准标准模式：
主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）；
混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作为开关；
准标准模式通过过渡性文档类型和框架集文档类型来触发。

8、区分大小写
typeof 不能作为函数名，因为它是一个关键字；但 Typeof 是一个完全有效的函数名。

9、标识符
标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：
第一个字符必须是一个字母、下划线（ _ ）或$ ；剩下的其他字符可以是字母、下划线、美元符号或数字。

10.严格模式
1、ECMAScript 5增加了严格模式（strict mode）的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：“use strict”;
2、虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持JavaScrip引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏ECMAScript 3语法。
3、也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可。

11、变量
var 声明作用域：，使用 var 操作符定义的变量会成为包含它的函数的局部变量。

12、var 声明提升
使用这个关键字声明的变量会自动提升到函数作用域顶部；也就是把所有变量声明都拉到函数作用域的顶部；此外，反复多次使用 var 声明同一个变量也没有问题。

13、let 声明
let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是， let 声明的范围是块作用域，而var 声明的范围是函数作用域。

14、 暂时性死区
let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。

15、 全局声明
与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（ var 声明的变量则会）。
为了避免 SyntaxError ，必须确保页面不会重复声明同一个变量。

16、条件声明
在使用 var 声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。
使用 try / catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。

17、for 循环中的 let 声明
在 let 出现之前， for 循环定义的迭代变量会渗透到循环体外部。
改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部。

18、const和let的区别
1、const 声明 const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。
2、const 声明的限制只适用于它指向的变量的引用。如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。

19、数据类型
ECMAScript有6种简单数据类型（也称为原始类型）：
Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。 Symbol （符号）是ECMAScript 6新增的。还有一种复杂数据类型叫 Object （对象）。 Object 是一种无序名值对的集合。因为ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。只有7种数据类型似乎不足以表示全部数据。

20、typeof 操作符
“undefined” 表示值未定义；
“boolean” 表示值为布尔值；
“string” 表示值为字符串；
“number” 表示值为数值；
“object” 表示值为对象（而不是函数）或 null ； “function” 表示值为函数；
“symbol” 表示值为符号。

21、Undefined 类型
Undefined 类型只有一个值，就是特殊值 undefined 。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值。

22、Null 类型
1、Null 类型同样只有一个值，即特殊值 null 。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 “object” 的原因。
2、用等于操作符（ == ）比较 null 和 undefined 始终返回true 。

23、Boolean 类型
Boolean （布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值： true 和 false 。这两个布尔值不同于数值，因此 true 不等于1， false 不等于0。

24、 NaN
有一个特殊的数值叫 NaN ，意思是“不是数值”（Not aNumber），用于表示本来要返回数值的操作失败了（而不是抛出错误）。

25、数值转换
有3个函数可以将非数值转换为数值： Number() 、 parseInt() 和 parseFloat() 。 Number() 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。Number() 函数基于如下规则执行转换。布尔值， true 转换为1， false 转换为0。
数值，直接返回。null ，返回0。 undefined ，返回 NaN 。

26、String 类型
String （字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（"）、单引号（’）或反引号（`）标示。

27、Symbol.isConcatSpreadable
根据ECMAScript规范，这个符号作为一个属性表示“一个布尔值，如果是 true ，则意味着对象应该用Array.prototype.concat() 打平其数组元素”。ES6中的Array.prototype.concat() 方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖Symbol.isConcatSpreadable 的值可以修改这个行为。数组对象默认情况下会被打平到已有的数组， false 或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾， true 或真值会导致这个类数组对象被打平到数
组实例。其他不是类数组对象的对象在Symbol.isConcatSpreadable 被设置为 true 的情况下将被忽略。

28、Symbol.iterator
根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话说，这个符号表示实现迭代器API的函数。

29、Symbol.split
根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由String.prototype.split() 方法使用”。 String.prototype.split() 方法会使用以
Symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数。

30、 Symbol.toStringTag
根据ECMAScript规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法Object.prototype.toString() 使用”。通过 toString() 方法获取对象标识时，会检索由Symbol.toStringTag 指定的实例标识符，默认为 “Object” 。内置类型已经指定了这个值，但自定义类实例还需要明确定义。
1.19
1、传递参数
ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。

2、确定类型
1、typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象，所以ECMAScript提供了 instanceof 操作符。
2、如果变量是给定引用类型的实例，则 instanceof 操作符返回 true 。
3、按照定义，所有引用值都是 Object 的实例，因此通过instanceof 操作符检测任何引用值和 Object 构造函数都会返回 true 。类似地，如果用 instanceof 检测原始值，则始终会返回 false ，因为原始值不是对象。

3、执行上下文
1、全局上下文是最外层的上下文，在浏览器中，全局上下文就是我们常说的 window 对象，因此所有通过var 定义的全局变量和函数都会成为 window 对象的属性和方法。
2、使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。
3、上下文中的代码在执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。

总分类：
全局上下文、 changeColor() 的局部上下文和 swapColors() 的局部上下文。
全局上下文中有一个变量 color 和一个函数 chageColor() 。
changeColor() 的局部上下文中有一个变量 anotherColor 和一个函数swapColors() ，但在这里可以访问全局上下文中的变量color 。
swapColors() 的局部上下文中有一个变量tempColor ，只能在这个上下文中访问到。
全局上下文和changeColor() 的局部上下文都无法访问到 tempColor 。而在swapColors() 中则可以访问另外两个上下文中的变量，因为它们都是父上下文。

4、作用域链
1、虽然执行上下文主要有全局上下文和函数上下文两种，但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。
2、try / catch 语句的 catch 块 with 语句：都会在作用域链前端添加一个变量对象。
对with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

5、变量声明
1、使用 var 的函数作用域声明：
在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。
2. 使用 let 的块级作用域声明
ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号 {} 界定。换句话说， if 块、 while 块、 function块，甚至连单独的块也是 let 声明变量的作用域。
3. 使用 const 的常量声明
除了 let ，ES6同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。

6、垃圾回收
1、标记清理
JavaScript最常用的垃圾回收策略是标记清理。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。
2 、引用计数
另一种没那么常用的垃圾回收策略是引用计数，其思路是对每个值都记录它被引用的次数。
3 、性能
垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。

7、内存管理
1、通过 const 和 let 声明提升性能；
2、 隐藏类和删除操作；
3. 内存泄漏；
4. 静态分配与对象池

8、小结
1、JavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以下6种原始数据类型之一： Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol 。
2、原始值和引用值有以下特点:
原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。引用值是对象，存储在堆内存上。
包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。
1.20
1、基本引用类型
引用值（或者对象）是某个特定引用类型的实例。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。
对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函（constructor）来创建，构造函数就是用来创建新对象的函数。

2、Date
1、要创建日期对象，就使用 new 操作符来调用 Date 构造函数：let now = new Date();
在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示。
2、ECMAScript为此提供了两个辅助方法： Date.parse() 和 Date.UTC() 。
3、Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。
4、Date.UTC() 方法也返回日期的毫秒表示，但使用的是跟Date.parse() 不同的信息来生成这个值。

3、继承的方法
与其他类型一样， Date 类型重写了 toLocaleString() 、 toString() 和 valueOf() 方法。但与其他类型不同，重写后这些方法的返回值不一样。 Date 类型的 toLocaleString() 方法返回与浏览器运行的本地环境一致的日期和时间。

4、日期格式化方法
Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：
toDateString() 显示日期中的周几、月、日、年（格式特定于实现）；
toTimeString() 显示日期中的时、分、秒和时区（格式特定于实现）；
toLocaleDateString() 显示日期中的周几、月、日、年（格式特定于实现和地区）；
toLocaleTimeString() 显示日期中的时、分、秒（格式特定于实现）；
toUTCString() 显示完整的UTC日期（格式特定于实现）。
这些方法的输出与 toLocaleString() 和 toString() 一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。

5、RegExp
1、正则表达式使用类似Perl的简洁语法来创建：let expression = /pattern/flags;
这个正则表达式的 pattern （模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 flags （标记），用于控制正则表达式的行为。
2、g ：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
i ：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。
m ：多行模式，表示查找到一行文本末尾时会继续查找。
y ：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
u ：Unicode模式，启用Unicode匹配。
s ： dotAll 模式，表示元字符 . 匹配任何字符（包括 \n 或 \r ）。

6、RegExp 实例属性
每个 RegExp 实例都有下列属性：
global ：布尔值，表示是否设置了 g 标记。
ignoreCase ：布尔值，表示是否设置了 i 标记。
unicode ：布尔值，表示是否设置了 u 标记。
sticky ：布尔值，表示是否设置了 y 标记。
lastIndex ：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。
multiline ：布尔值，表示是否设置了 m 标记。
dotAll ：布尔值，表示是否设置了 s 标记。
source ：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。
flags ：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。

7、RegExp 实例方法
1、RegExp 实例的主要方法是 exec() ，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回 null 。
2、返回的数组虽然是 Array 的实例，但包含两个额外的属性： index 和 input 。 index 是字符串中匹配模式的起始位置， input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。

8、RegExp 构造函数属性
1、RegExp 构造函数本身也有几个属性。这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。每个属性都有一个全名和一个简写。
2、例：全名/ 简写 /说明
input $_ 最后搜索的字符串
lastMatch $& 最后匹配的文本
lastParen $+ 最后匹配的捕获组
leftContext $` input 字符串中出现在
lastMatch 前面的文本
rightContext $’ input 字符串中出现在lastMatch 后面的文本
3、input 属性中包含原始的字符串。
leftConext 属性包含原始字符串中 “short” 之前的内容，
rightContext 属性包含 “short” 之后的内容。
lastMatch 属性包含匹配整个正则表达式的上一个字符串，即 “short” 。 lastParen 属性包含捕获组的上一次匹配，即 “s” 。

9、原始值包装类型
为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：
Boolean 、 Number 和 String 。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。

10、Boolean
1、Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入 true 或 false：let booleanObject = new Boolean(true);
2、Boolean 的实例会重写 valueOf() 方法，返回一个原始值 true 或 false 。 toString() 方法被调用时也会被覆盖，返回字符串 “true” 或 “false” 。不过， Boolean 对象在ECMAScript中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用Boolean 对象时。

11、Number
1、Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值：let numberObject = new Number(10);
2、与 Boolean 类型一样， Number 类型重写了 valueOf() 、 toLocaleString() 和 toString() 方法。 valueOf() 方法返回Number 对象表示的原始数值，另外两个方法返回数值字符串。toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串。

12、String
1、String 是对应字符串的引用类型。要创建一个 String 对象，使用 String 构造函数并传入一个数值：let stringObject = new String(“hello world”);
2、String 对象的方法可以在所有字符串原始值上调用。3个继承的方法 valueOf() 、toLcaleString() 和 toString() 都返回对象的原始字符串值。每个 String 对象都有一个 length 属性，表示字符串中字符的数量。

13、单例内置对象
1、内置对象包括 Object 、 Array 和 String ，单例内置对象： Global 和 Math 。
2、Global 对象是ECMAScript中最特别的对象，因为代码不会显式地访问它。
isNaN() 、 isFinite() 、 parseInt() 和 parseFloat() ，实际上都是 Global 对象的方法。
3、Global 对象属性：
Global 对象有很多属性：undefined 、 NaN 和 Infinity 等特殊值都是 Global 对象的属性。此外，所有原生引用类型构造函数，比如 Object 和 Function ，也都是 Global 对象的属性。
4、例：
属性 / 说明
undefined 特殊值 undefined
NaN 特殊值 NaN
Infinity 特殊值 Infinity
Object Object 的构造函数
Array Array 的构造函数
Function Function 的构造函数
Boolean Boolean 的构造函数
String String 的构造函数
Number Number 的构造函数
Date Date 的构造函数
RegExp RegExp 的构造函数
Symbol Symbol 的伪构造函数
Error Error 的构造函数
EvalError EvalError 的构造函数
RangeError RangeError 的构造函数
ReferenceError ReferenceError 的构造函数
SyntaxError SyntaxError 的构造函数
TypeError TypeError 的构造函数
URIError URIError 的构造函数

14、Math
1、ECMAScript提供了 Math 对象作为保存数学公式、信息和计算的地方。 Math 对象提供了一些辅助计算的属性和方法。
2、Math 对象属性
Math 对象有一些属性，主要用于保存数学中的一些特殊值。
3、min() 和 max() 方法
Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。min() 和 max() 方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数。
4、 舍入方法
接下来是用于把小数值舍入为整数的4个方法： Math.ceil() 、 Math.floor() 、 Math.round() 和 Math.fround() 。这几个方法处理舍入的方式如下：
Math.ceil() 方法始终向上舍入为最接近的整数。
Math.floor() 方法始终向下舍入为最接近的整数。
Math.round() 方法执行四舍五入。

15、random() 方法
Math.random() 方法返回一个0~1范围内的随机数，其中包含0但不包含1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方便的。

16、总：
1、引用值与传统面向对象编程语言中的类相似，但实现不同。Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。
RegExp 类型是ECMAScript支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。
2、由于原始值包装类型的存在，JavaScript中的原始值可以被当成对象来使用。有3种原始值包装类型： Boolean 、 Number 和 String 。它们都具备如下特点。
每种包装类型都映射到同名的原始类型。
以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。
涉及原始值的语句执行完毕后，包装对象就会被销毁。
3、当代码开始执行时，全局上下文中会存在两个内置对象： Global 和 Math 。其中， Global 对象在大多数ECMAScript实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函数都是Global 对象的属性。 Math 对象包含辅助完成复杂计算的属性和方法。