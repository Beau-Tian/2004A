第 4 章 变量、作用域与内存
	
	1  ECMAScript变量可以包含两种不同类型的数据：原始值和引用
值。原始值（primitive value）就是最简单的数据，引用值（reference
value）则是由多个值构成的对象。

	2  6种原始值： Undefined 、 Null 、
Boolean 、 Number 、 String 和 Symbol 

 1 复制值
除了存储方式不同，原始值和引用值在通过变量复制时也有所不
同。

 2 确定类型
前一章提到的 typeof 操作符最适合用来判断一个变量是否为原
始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔
值或 undefined 的最好方式。如果值是对象或 null ，那么
typeof 返回 "object" 

  3 执行上?文与作用域 
在浏览器中，全局上?文就
是我们常说的 window 对象，因此所有通过
var 定义的全局变量和函数都会成为 window 对象的属性和方法。
使用 let 和 const 的顶级声明不会定义在全局上?文中，但在作用
域链解析上效果是一样的。

每个函数调用都有自己的上?文。


当代码执行流进入函数时，函
数的上?文被推到一个上?文栈上。在函数执行完之后，上?文栈会
弹出该函数上?文，将控制权返还给之前的执行上?文。


上?文中的代码在执行的时候，会创建变量对象的一个作用域链
（sc?pe chain）。这个作用域链决定了各级上?文中的代码在访问变
量和函数时的顺序。代码正在执行的上?文的变量对象始终位于作用
域链的最前端。如果上?文是函数，则其活动对象（activati?n
?b?ect）用作变量对象。活动对象最初只有一个定义变量：
arguments 。



作用域链增强
虽然执行上?文?要有全局上?文和函数上?文两种（ eval()
调用内部存在第三种上?文），但有其他方式来增强作用域链。某些
语句会导致在作用域链前端临时添加一个上?文，这个上?文在代码
执行后会被删除。


try / catch 语句的 catch 块
with 语句
这两种情况?，都会在作用域链前端添加一个变量对象。对
with 语句来说，会向作用域链前端添加指定的对象；对 catch 语
句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的
错误对象的声明。




使用 let 的块级作用域声明
ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级
的，这也是JavaScript中的新概念。块级作用域由最?的一对包含
花括号 {} 界定。换句话说， if 块、 while 块、 function
块，甚至连单独的块也是 let 声明变量的作用域。



let 与 var 的另一个不同之处是在同一作用域内不能声明两
次。重复的 var 声明会被忽略，而重复的 let 声明会抛出
SyntaxError 。

严格来讲， let 在JavaScript运行时中也会被提升，但由于“暂时
性死区”（temp?ral dead ??ne）的缘故，实际上不能在声明之前使
用 let 变量。

使用 const 的常量声明
除了 let ，ES6同时还增加了 const 关键字。使用 const 声
明的变量必须同时初始化为某个值。一经声明，在其生命周期的
任何时候都不能再重新赋予新值。
const 声明只应用到顶级原语或者对象。换句话说，赋值为对
象的 const 变量不能再被重新赋值为其他引用值，但对象的键
则不受限制。


垃圾回收
通过自动内存管理实现内存分配和闲置资源回收
在浏览器的发展史上，用到过两种?要的标记策略：标记清理和引用计
数。


标记清理
JavaScript最常用的垃圾回收策略是标记清理（mark-and-
s?eep）。



myObject.element = null;
element.someObject = null;
把变量设置为 null 实际上会切断变量与其之前引用值之间的关
系。当?次垃圾回收程序运行时，这些值就会被删除，内存也会被回
收。
为了补救这一点，IE9把BOM和DOM对象都改成了JavaScript对
象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消
除了常见的内存泄漏现象。


 内存泄漏
JavaScript中的内存泄漏大部分是由不合
理的引用导致的。
意外声明全局变量是最常见但也最容易修复的内存泄漏问题。

最后  小结
JavaScript变量可以保存两种类型的值：原始值和引用值。原始值
可能是以?6种原始数据类型之一： Undefined 、 Null 、
Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有
以?特点。
原始值大小固定，因此保存在栈内存上。
从一个变量到另一个变量复制原始值会创建该值的第二个副本。
引用值是对象，存储在堆内存上。
包含引用值的变量实际上只包含指向相应对象的一个指针，而不
是对象本身。
从一个变量到另一个变量复制引用值只会复制指针，因此结果是
两个变量都指向同一个对象。
typeof 操作符可以确定值的原始类型，而 instanceof 操作
符用于确保值的引用类型。
任何变量（不管包含的是原始值还是引用值）都存在于某个执行
上?文中（也称为作用域）。这个上?文（作用域）决定了变量的生
命周期，以及它们可以访问代码的哪些部分。执行上?文可以总结如
?。
执行上?文分全局上?文、函数上?文和块级上?文。
代码执行流每进入一个新上?文，都会创建一个作用域链，用于
搜索变量和函数。
函数或块的局部上?文不仅可以访问自己作用域内的变量，而且
也可以访问任何包含上?文乃至全局上?文中的变量。
全局上?文只能访问全局上?文中的变量和函数，不能直接访问
局部上?文中的任何数据。
变量的执行上?文用于确定什么时候释放内存。
JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分
配和回收。JavaScript的垃圾回收程序可以总结如?。
离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被
删除。
?流的垃圾回收算法是标记清理，即先给当前不使用的值加上标
记，再回来回收它们的内存。
引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。
JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这
种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如
DOM元素）。
引用计数在代码中存在循环引用时会出现问题。
解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮
助。为促进内存回收，全局对象、全局对象的属性和循环引用都
应该在不需要时解除引用。
























