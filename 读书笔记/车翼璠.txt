1、什么是JavaScript
核心（ECMAScript）
文档对象模型（DOM）
浏览器对象模型（BOM）
2、ECMAScript
如果不涉及浏览器的话，ECMA-262到底定义了什么？在基本的
层面，它描述这门语言的如下部分：
语法、类型、语句、关键字、保留字、操作符、全局对象
ECMAScript只是对实现这个规范描述的所有方面的一门语言的称
呼。JavaScript实现了ECMAScript，而Adobe ActionScript同样也实现了ECMAScript。
3、ECMAScript符合性是什么意思
ECMA-262阐述了什么是ECMAScript符合性。要成为ECMAScript
实现，必须满足下列条件：
支持ECMA-262中描述的所有“类型、值、对象、属性、函
数，以及程序语法与语义”；
支持Unicode字符标准。
此外，符合性实现还可以满足下列要求。
增加ECMA-262中未提及的“额外的类型、值、对象、属性和
函数”。ECMA-262所说的这些额外内容主要指规范中未给出
的新对象或对象的新属性。
支持ECMA-262中没有定义的“程序和正则表达式语法”（意
思是允许修改和扩展内置的正则表达式特性）。
4、DOM
文档对象模型（DOM，Document Object Model）是一个应用编程
接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽
象为一组分层节点。HTML或XML页面的每个组成部分都是一种节
点，包含不同的数据。比如下面的HTML页面：
<html> <head> <title>Sample Page</title> </head>
<body> <p> Hello World!</p> </body> </html>
这些代码通过DOM可以表示为一组分层节点
DOM通过创建表示文档的树，让开发者可以随心所欲地控制网页
的内容和结构。使用DOM API，可以轻松地删除、添加、替换、修改
节点。
5、为什么DOM是必需的
在IE4和Netscape Navigator 4支持不同形式的动态
HTML（DHTML）的情况下，开发者首先可以做到不刷新页面而
修改页面外观和内容。这代表了Web技术的一个巨大进步，但也
暴露了很大的问题。由于网景和微软采用不同思路开发
DHTML，开发者写一个HTML页面就可以在任何浏览器中运行的
好日子就此终结。
为了保持Web跨平台的本性，必须要做点什么。人们担心如果无
法控制网景和微软各行其是，那么Web就会发生分裂，导致人们
面向浏览器开发网页。就在这时，万维网联盟（W3C，World
Wide Web Consortium）开始了制定DOM标准的进程。
6、DOM级别
1998年10月，DOM Level 1成为W3C的推荐标准。这个规范由两
个模块组成：DOM Core和DOM HTML。前者提供了一种映射XML文档，从而方便访问和操作文档任意部分的方式；后者扩展了前者，并增加了特定于HTML的对象和方法。
DOM Level 1中的DOM Core也被扩展以包含对XML命名空间的支
持。
DOM Level 2新增了以下模块，以支持新的接口。
DOM视图：描述追踪文档不同视图（如应用CSS样式前后的
文档）的接口。
DOM事件：描述事件及事件处理的接口。
DOM样式：描述处理元素CSS样式的接口。
DOM遍历和范围：描述遍历和操作DOM树的接口。
DOM Level 3进一步扩展了DOM，增加了以统一的方式加载和保
存文档的方法（包含在一个叫DOM Load and Save的新模块中），
还有验证文档的方法（DOM Validation）。
7、其他DOM
除了DOM Core和DOM HTML接口，有些其他语言也发布了自己
的DOM标准。下面列出的语言是基于XML的，每一种都增加了
该语言独有的DOM方法和接口：
可伸缩矢量图（SVG，Scalable Vector Graphics）
数学标记语言（MathML，Mathematical Markup Language）
同步多媒体集成语言（SMIL，Synchronized Multimedia
Integration Language）
此外，还有一些语言开发了自己的DOM实现，比如Mozilla的
XML用户界面语言（XUL，XML User Interface Language）。不
过，只有前面列表中的语言是W3C推荐标准。
8、BOM
总体来说，BOM主要针对浏览器窗口和子窗口（frame），不过
人们通常会把任何特定于浏览器的扩展都归在BOM的范畴内。比如，
下面就是这样一些扩展：
弹出新浏览器窗口的能力；
移动、缩放和关闭浏览器窗口的能力；
navigator 对象，提供关于浏览器的详尽信息；
location 对象，提供浏览器加载页面的详尽信息；
screen 对象，提供关于用户屏幕分辨率的详尽信息；
performance 对象，提供浏览器内存占用、导航行为和时间统
计的详尽信息；
对cookie的支持；
其他自定义对象，如 XMLHttpRequest 和IE的
ActiveXObject
9、小结
JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成
部分。
ECMAScript：由ECMA-262定义并提供核心功能。
文档对象模型（DOM）：提供与网页内容交互的方法和接口。
浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。
HTML中的JavaScript
将JavaScript引入网页，首先要解决它与网页的主导语言HTML的
关系问题。在JavaScript早期，网景公司的工作人员希望在将JavaScript引入HTML页面的同时，不会导致页面在其他浏览器中渲染出问题。通过反复试错和讨论，他们最终做出了一些决定，并达成了向网页中引入通用脚本能力的共识。当初他们的很多工作得到了保留，并且最终形成了HTML规范
1、<script> 元素
<script> 元素有下列8个属性。
async ：可选。表示应该立即开始下载脚本，但不能阻止其他
页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文
件有效。
charset ：可选。使用 src 属性指定的代码字符集。这个属
性很少使用，因为大多数浏览器不在乎它的值
crossorigin ：可选。配置相关请求的CORS（跨源资源共
享）设置。默认不使用CORS。crossorigin="anonymous" 配置文件请求不必设置凭据标志。 crossorigin="use-credentials" 设置凭据标志，意味着出站请求会包含凭据。
defer ：可选。表示在文档解析和显示完成后再执行脚本是没
有问题的。只对外部脚本文件有效。在IE7及更早的版本中，对行
内脚本也可以指定这个属性。
integrity ：可选。允许比对接收到的资源和指定的加密签名
以验证子资源完整性（SRI，Subresource Intergrity）。如果接收到
的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚
本不会执行。这个属性可以用于确保内容分发网络（CDN，
Content Delivery Network）不会提供恶意内容
language ：废弃。最初用于表示代码块中的脚本语言
（如 "JavaScript" 、 "JavaScript1.2" 或 "VBScript" ）。大多数浏览器都会忽略这个属性，不应该再使用它。
src ：可选。表示包含要执行的代码的外部文件。
type ：可选。代替 language ，表示代码块中脚本语言的内
容类型（也称MIME类型）。
1 、标签占位符
过去，所有 <script> 元素都被放在页面的 <head> 标签内，
如下面的例子所示：
<!DOCTYPE html>
<html>
<head>
<title>Example HTML Page</title>
<script src="example1.js"></script>
<script src="example2.js"></script>
</head>
<body>
<!-- 这里是页面内容 -->
</body>
</html>
2、推迟执行脚本
HTML 4.01为 <script> 元素定义了一个叫 defer 的属性。这
个属性表示脚本在执行的时候不会改变页面的结构。因此，这个脚本完全可以在整个页面解析完之后再运行。在 <script> 元素上设置
defer 属性，会告诉浏览器应该立即开始下载，但执行应该推
3、异步执行脚本
HTML5为 <script> 元素定义了 async 属性。从改变脚本处
理方式上看， async 属性与 defer 类似。当然，它们两者也都只
适用于外部脚本，都会告诉浏览器立即开始下载。不过，与 defer
不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执
行，比如：
<!DOCTYPE html>
<html>
<head>
<title>Example HTML Page</title>
<script async src="example1.js"></script>
<script async src="example2.js"></script>
</head>
<body>
<!-- 这里是页面内容 -->
</body>
</html>
3、动态加载脚本
除了 <script> 标签，还有其他方式可以加载脚本。因为
JavaScript可以使用DOM API，所以通过向DOM中动态添加 script
元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添
加到DOM即可。
4、XHTML中的变化
可扩展超文本标记语言（XHTML，Extensible HyperText Markup
Language）是将HTML作为XML的应用重新包装的结果。与HTML不
同，在XHTML中使用JavaScript必须指定 type 属性且值为
text/javascript ，HTML中则可以没有这个属性。XHTML虽然
已经退出历史舞台，但实践中偶尔可能也会遇到遗留代码，为此本节
稍作介绍。在XHTML中编写代码的规则比HTML中严格，这会影响使用<script> 元素嵌入JavaScript代码。下面的代码块虽然在HTML中
有效，但在XHML中是无效的


5、在HTML中，解析 <script> 元素会应用特殊规则。XHTML中
则没有这些规则。这意味着 a < b 语句中的小于号（ < ）会被解释
成一个标签的开始，并且由于作为标签开始的小于号后面不能有空
格，这会导致语法错误。
避免XHTML中这种语法错误的方法有两种。第一种是把所有小
于号（ < ）都替换成对应的HTML实体形式（ < ）。结果代码就
是这样的：

6、废弃的语法
自1995年Netscape 2发布以来，所有浏览器都将JavaScript作为默
认的编程语言。 type 属性使用一个MIME类型字符串来标识
<script> 的内容，但MIME类型并没有跨浏览器标准化。即使浏览
器默认使用JavaScript，在某些情况下某个无效或无法识别的MIME类
型也可能导致浏览器跳过（不执行）相关代码。因此，除非你使用
XHML或 <script> 标签要求或包含非JavaScript代码，最佳做法是
不指定 type 属性。在最初采用 script 元素时，它标志着开始走向与传统HTML解
析不同的流程。对这个元素需要应用特殊的解析规则，而这在不支持
JavaScript的浏览器（特别是Mosaic）中会导致问题。不支持的浏览器
会把 <script> 元素的内容输出到页面上，从而破坏页面的外观。

1、行内代码与外部文件
可维护性。JavaScript代码如果分散到很多HTML页面，会导致维
护困难。而用一个目录保存所有JavaScript文件，则更容易维护，这样开发者就可以独立于使用它们的HTML页面来编辑代码。
缓存。浏览器会根据特定的设置缓存所有外部链接的JavaScript文
件，这意味着如果两个页面都用到同一个文件，则该文件只需下
载一次。这最终意味着页面加载更快。
适应未来。通过把JavaScript放到外部文件中，就不必考虑用
XHTML或前面提到的注释黑科技。包含外部JavaScript文件的语
法在HTML和XHTML中是一样的。

在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用
多少带宽。在SPDY/HTTP2中，预请求的消耗已显著降低，以轻量、
独立JavaScript组件形式向客户端送达脚本更具优势。
2、文档模式
IE5.5发明了文档模式的概念，即可以使用 doctype 切换文档模
式。最初的文档模式有两种：混杂模式（quirks mode）和标准模式
（standards mode）。前者让IE像IE5一样（支持一些非标准的特
性），后者让IE具有兼容标准的行为。虽然这两种模式的主要区别只
体现在通过CSS渲染的内容方面，但对JavaScript也有一些关联影响，
或称为副作用。
一、<noscript> 元素
针对早期浏览器不支持JavaScript的问题，需要一个页面优雅降级
的处理方案。最终， <noscript> 元素出现，被用于给不支持
JavaScript的浏览器提供替代内容。虽然如今的浏览器已经100%支持
JavaScript，但对于禁用JavaScript的浏览器来说，这个元素仍然有它的用处

<noscript> 元素可以包含任何可以出现在 <body> 中的
HTML元素， <script> 除外。在下列两种情况下，浏览器将显示包
含在 <noscript> 中的内容：
浏览器不支持脚本；
浏览器对脚本的支持被关闭。任何一个条件被满足，包含在 <noscript> 中的内容就会被渲
染。否则，浏览器不会渲染 <noscript> 中的内容。

一、语言基础
1、语法
ECMAScript的语法很大程度上借鉴了C语言和其他类C语言，如
Java和Perl。熟悉这些语言的开发者，应该很容易理解ECMAScript宽
松的语法。
2、区分大小写
首先要知道的是，ECMAScript中一切都区分大小写。无论是变
量、函数名还是操作符，都区分大小写。换句话说，变量 test 和变
量 Test 是两个不同的变量。类似地， typeof 不能作为函数名，
因为它是一个关键字（后面会介绍）。但 Typeof 是一个完全有效的
函数名。
3、标识符
所谓标识符，就是变量、函数、属性或函数参数的名称。标识符
可以由一或多个下列字符组成：
第一个字符必须是一个字母、下划线（ _ ）或美元符号
（ $ ）；
剩下的其他字符可以是字母、下划线、美元符号或数字
4、注释
ECMAScript采用C语言风格的注释，包括单行注释和块注释。单
行注释以两个斜杠字符开头，如：
// 单行注释
块注释以一个斜杠和一个星号（ /* ）开头，以它们的反向组合
（ */ ）结尾，如：
/* 这是多行
注释 */
5、严格模式
ECMAScript 5增加了严格模式（strict mode）的概念。严格模式是
一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写
法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个
脚本启用严格模式，在脚本开头加上这一行：
"use strict";
严格模式会影响JavaScript执行的很多方面，因此本书在用到它时
会明确指出来。所有现代浏览器都支持严格模式。
6、语句
ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定
语句在哪里结尾
if之类的控制语句只在执行多条语句时要求必须有代码块。不
过，最佳实践是始终在控制语句中使用代码块，即使要执行的只有一
条语句
7、关键字与保留字
ECMA-262描述了一组保留的关键字，这些关键字有特殊用途，
比如表示控制语句的开始和结束，或者执行特定的操作。按照规定，
保留的关键字不能用作标识符或属性名。ECMA-262第6版规定的所有
关键字如下：
break do in typeof
case else instanceof var
catch export new void
class extends return while
const finally super with
continue for switch yield
debugger function this
default if throw
delete import try
以下是ECMA-262第6版为将来保留的所有词汇。
始终保留:
enum
严格模式下保留:
implements package public
interface protected static
let private
模块代码中保留:
await
8、变量
ECMAScript变量是松散类型的，意思是变量可以用于保存任何类
型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量： var 、 const 和 let 。其中， var 在
ECMAScript的所有版本中都可以使用，而 const 和 let 只能在
ECMAScript 6及更晚的版本中使用。
9、var 关键字
要定义变量，可以使用 var 操作符（注意 var 是一个关键
字），后跟变量名（即标识符，如前所述）
1. var 声明作用域
关键的问题在于，使用 var 操作符定义的变量会成为包含它的
函数的局部变量。比如，使用 var 在一个函数内部定义一个变
量，就意味着该变量将在函数退出时被销毁：
去掉之前的 var 操作符之后， message 就变成了全局变量。
只要调用一次函数 test() ，就会定义这个变量，并且可以在函
数外部访问到。
注意 虽然可以通过省略 var 操作符定义全局变量，但不推
荐这么做。在局部作用域中定义的全局变量很难维护，也会造
成困惑。这是因为不能一下子断定省略 var 是不是有意而为之。在严格模式下，如果像这样给未声明的变量赋值，则会导
致抛出 ReferenceError 。
2. var 声明提升
使用 var 时，下面的代码不会报错。这是因为使用这个关键字
声明的变量会自动提升到函数作用域顶部：
所谓的“提升”（hoist），也就是把所有变量声明都拉到函
数作用域的顶部。此外，反复多次使用 var 声明同一个变量也
没有问题：
3、let 声明
let 跟 var 的作用差不多，但有着非常重要的区别。最明显的
区别是， let 声明的范围是块作用域，而 var 声明的范围是函数作
用域。
4、暂时性死区
let 与 var 的另一个重要的区别，就是 let 声明的变量不会
在作用域中被提升。
// name会被提升
console.log(name); // undefined
var name = 'Matt';
// age不会被提升console.log(age); // ReferenceError：age没有定
义
let age = 26;
5、全局声明
与 var 关键字不同，使用 let 在全局作用域中声明的变量不会
成为 window 对象的属性（ var 声明的变量则会）。
6、条件声明
自动将多余的声明在作用域顶部合并为一个声明。因为 let 的
作用域是块，所以不可能检查前面是否已经使用 let 声明过同
名变量，同时也就不可能在没有声明的情况下声明它。
7、for 循环中的 let 声明
在 let 出现之前， for 循环定义的迭代变量会渗透到循环体外
部
for (var i = 0; i < 5; ++i) {
// 循环逻辑
}
console.log(i); //
改成使用 let 之后，这个问题就消失了，因为迭代变量的作用
域仅限于 for 循环块内部：
在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明
和修改
之所以会这样，是因为在退出循环时，迭代变量保存的是导致循
环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个
变量，因而输出的都是同一个最终值。
而在使用 let 声明迭代变量时，JavaScript引擎在后台会为每个
迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都
是不同的变量实例，所以 console.log 输出的是我们期望的
值，也就是循环执行过程中每个迭代变量的值。
 8、const 声明
const 的行为与 let 基本相同，唯一一个重要的区别是用它声
明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导
致运行时错误。
const 声明的限制只适用于它指向的变量的引用。换句话说，
如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。
9、数据类型
ECMAScript有6种简单数据类型（也称为原始类型）：
Undefined 、 Null 、 Boolean 、 Number 、 String 和
Symbol 。 Symbol （符号）是ECMAScript 6新增的。还有一种复
杂数据类型叫 Object （对象）。 Object 是一种无序名值对的集
合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。只有7种数据类型似乎不足以表示全部
数据。但ECMAScript的数据类型很灵活，一种数据类型可以当作多种
数据类型来使用。
10、typeof 操作符
"undefined" 表示值未定义；
"boolean" 表示值为布尔值；
"string" 表示值为字符串；
"number" 表示值为数值；
"object" 表示值为对象（而不是函数）或 null ；
"function" 表示值为函数；
"symbol" 表示值为符号。
11、Undefined 类型
Undefined 类型只有一个值，就是特殊值 undefined 。当使
用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予
了 undefined 值：
12、Null 类型
Null 类型同样只有一个值，即特殊值 null 。逻辑上讲，
null 值表示一个空对象指针，这也是给 typeof 传一个 null 会
返回 "object" 的原因
用等于操作符（ == ）比较 null 和 undefined 始终返回
true 。但要注意，这个操作符会为了比较而转换它的操作数
即使 null 和 undefined 有关系，它们的用途也是完全不一样
的。如前所述，永远不必显式地将变量值设置为 undefined 。但
null 不是这样的。任何时候，只要变量要保存对象，而当时又没有
那个对象可保存，就要用 null 来填充该变量。这样就可以保持
null 是空对象指针的语义，并进一步将其与 undefined 区分开
来。
null 是一个假值。因此，如果需要，可以用更简洁的方式检测
它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明
确自己想检测的就是 null 这个字面值，而不仅仅是假值
13、Boolean 类型
Boolean （布尔值）类型是ECMAScript中使用最频繁的类型之
一，有两个字面值： true 和 false 。这两个布尔值不同于数值，
因此 true 不等于1， false 不等于0。
注意，布尔值字面量 true 和 false 是区分大小写的，因此
True 和 False （及其他大小混写形式）是有效的标识符，但不是
布尔值。
虽然布尔值只有两个，但所有其他ECMAScript类型的值都有相应
布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用
特定的 Boolean() 转型函数
14、Number 类型
ECMAScript中最有意思的数据类型或许就是 Number 了。
Number 类型使用IEEE 754格式表示整数和浮点值（在某些语言中也
叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。
最基本的数值字面量格式是十进制整数，直接写出来即可
八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出
语法错误。1
1. 浮点值
要定义浮点值，数值中必须包含小数点，而且小数点后面必须至
少有一个数字。虽然小数点前面不是必须有整数，但推荐加上
2. 值的范围
由于内存的限制，ECMAScript并不支持表示这个世界上的所有数
值。ECMAScript可以表示的最小数值保存在
Number.MIN_VALUE 中，这个值在多数浏览器中是5e-324；可
以表示的最大数值保存在 Number.MAX_VALUE 中，这个值在多
数浏览器中是1.797 693 134 862 315 7e+308。如果某个计算得到的
数值结果超出了JavaScript可以表示的范围，那么这个数值会被自
动转换为一个特殊的 Infinity （无穷）值。任何无法表示的
负数以 -Infinity （负无穷大）表示，任何无法表示的正数
以 Infinity （正无穷大）表示。
3. NaN
有一个特殊的数值叫 NaN ，意思是“不是数值”（Not a
Number），用于表示本来要返回数值的操作失败了（而不是抛出
错误）。比如，用0除任意数值在其他语言中通常都会导致错误，
从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回
NaN
4. 数值转换
有3个函数可以将非数值转换为数值： Number() 、
parseInt() 和 parseFloat() 。 Number() 是转型函数，
可用于任何数据类型。后两个函数主要用于将字符串转换为数
值。对于同样的参数，这3个函数执行的操作也不同。
Number() 函数基于如下规则执行转换。
布尔值， true 转换为1， false 转换为0。数值，直接返回。
null ，返回0。
undefined ，返回 NaN 。
15、String 类型
String （字符串）数据类型表示零或多个16位Unicode字符序
列。字符串可以使用双引号（"）、单引号（'）或反引号（`）标示，
1. 字符字面量
字符串数据类型包含一些字符字面量，用于表示非打印字符或有
其他用途的字符，如下表所示：
字面量
含义
\n
换行
\t
制表
\b
退格
\r
回车
\f
换页
\\\\
反斜杠（ \ ）
\'
单引号（ ' ），在字符串以单引号标示时使用，例如 'He said, \'hey.\''
\"
双引号（ " ），在字符串以双引号标示时使
用，例如 "He said, \"hey.\""
\\\`
反引号（ \` ），在字符串以反引号标示时
使用，例如 \`He said,
\\\`hey.\\\`\`
\xnn
以十六进制编码 nn 表示的字符（其中 n 是
十六进制数字0~F），例如 \x41 等于 "A"
\unnnn
以十六进制编码 nnnn 表示的Unicode字符
（其中 n 是十六进制数字0~F），例如
\u03a3 等于希腊字符 "Σ"
2. 字符串的特点
ECMAScript中的字符串是不可变的（immutable），意思是一旦
创建，它们的值就不能变了。要修改某个变量中的字符串值，必
须先销毁原始的字符串，然后将包含新值的另一个字符串保存到
该变量
3. 转换为字符串
有两种方式把一个值转换为字符串。首先是使用几乎所有值都有
的 toString() 方法。这个方法唯一的用途就是返回当前值的
字符串等价物。
4、字符串插值
模板字面量最常用的一个特性是支持字符串插值，也就是可以在
一个连续定义中插入一个或多个值。技术上讲，模板字面量不是
字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得
到的是字符串。模板字面量在定义时立即求值并转换为字符串实
例，任何插入的变量也会从它们最接近的作用域中取值。
字符串插值通过在 ${} 中使用一个JavaScript表达式实现
5、原始字符串
使用模板字面量也可以直接获取原始的模板字面量内容（如换行
符或Unicode字符），而不是被转换后的字符表示。为此，可以使
用默认的 String.raw 标签函数
16、Symbol 类型
Symbol （符号）是ECMAScript 6新增的数据类型。符号是原始
值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用
唯一标识符，不会发生属性冲突的危险。
1. 符号的基本用法
符号需要使用 Symbol() 函数初始化。因为符号本身是原始类
型，所以 typeof 操作符对符号返回 symbol 。
2. 使用全局符号注册表
如果运行时的不同部分需要共享和重用符号实例，那么可以用一
个字符串作为键，在全局符号注册表中创建并重用符号。
为此，需要使用 Symbol.for() 方法
3. 使用符号作为属性
凡是可以使用字符串或数值作为属性的地方，都可以使用符号。
这就包括了对象字面量属性和
Object.defineProperty() / Object.definedProperties() 定义的属性。对象字面量只能在计算属性语法中使用符号
作为属性
4. 常用内置符号
ECMAScript 6也引入了一批常用内置符号（well-known
symbol），用于暴露语言内部行为，开发者可以直接访问、重写
或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属
性的形式存在。
5. Symbol.asyncIterator
根据ECMAScript规范，这个符号作为一个属性表示“一个方法，
该方法返回对象默认的 AsyncIterator 。由 for-await-
of 语句使用”。换句话说，这个符号表示实现异步迭代器API的
函数。
6. Symbol.hasInstance
根据ECMAScript规范，这个符号作为一个属性表示“一个方法，
该方法决定一个构造器对象是否认可一个对象是它的实例。由
instanceof 操作符使用”。 instanceof 操作符可以用来确
定一个对象实例的原型链上是否有原型。 instanceof 的典型
使用场景如下：
function Foo() {}
let f = new Foo();
console.log(f instanceof Foo); // trueclass Bar {}
let b = new Bar();
console.log(b instanceof Bar); // true
7. Symbol.isConcatSpreadable
根据ECMAScript规范，这个符号作为一个属性表示“一个布尔
值，如果是 true ，则意味着对象应该用
Array.prototype.concat() 打平其数组元素”。ES6中的
Array.prototype.concat() 方法会根据接收到的对象类型
选择如何将一个类数组对象拼接成数组实例。覆盖
Symbol.isConcatSpreadable 的值可以修改这个行为。
数组对象默认情况下会被打平到已有的数组， false 或假值会
导致整个对象被追加到数组末尾。类数组对象默认情况下会被追
加到数组末尾， true 或真值会导致这个类数组对象被打平到数
组实例。其他不是类数组对象的对象在
Symbol.isConcatSpreadable 被设置为 true 的情况下将
被忽略
8. Symbol.iterator
根据ECMAScript规范，这个符号作为一个属性表示“一个方法，
该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话
说，这个符号表示实现迭代器API的函数。
for-of 循环这样的语言结构会利用这个函数执行迭代操作。循
环时，它们会调用以 Symbol.iterator 为键的函数，并默认
这个函数会返回一个实现迭代器API的对象。很多时候，返回的
对象是实现该API的 Generator ：
class Foo {
*[Symbol.iterator]() {}
}
let f = new Foo();
console.log(f[Symbol.iterator]());
// Generator {<suspended>}
技术上，这个由 Symbol.iterator 函数生成的对象应该通过
其 next() 方法陆续返回值。可以通过显式地调用 next() 方
法返回，也可以隐式地通过生成器函数返回：
9. Symbol.match根据ECMAScript规范，这个符号作为一个属性表示“一个正则表
达式方法，该方法用正则表达式去匹配字符串。由
String.prototype.match() 方法使用”。
String.prototype.match() 方法会使用以
Symbol.match 为键的函数来对正则表达式求值。正则表达式
的原型上默认有这个函数的定义，因此所有正则表达式实例默认
是这个 String 方法的有效参数
10. Symbol.replace
根据ECMAScript规范，这个符号作为一个属性表示“一个正则表
达式方法，该方法替换一个字符串中匹配的子串。由
String.prototype.replace() 方法使用”。
String.prototype.replace() 方法会使用以
Symbol.replace 为键的函数来对正则表达式求值。正则表达
式的原型上默认有这个函数的定义，因此所有正则表达式实例默
认是这个 String 方法的有效参数：
11. Symbol.search
根据ECMAScript规范，这个符号作为一个属性表示“一个正则表
达式方法，该方法返回字符串中匹配正则表达式的索引。由
String.prototype.search() 方法使用”。
String.prototype.search() 方法会使用以
Symbol.search 为键的函数来对正则表达式求值。正则表达
式的原型上默认有这个函数的定义，因此所有正则表达式实例默
认是这个 String 方法的有效参数：
12. Symbol.species
根据ECMAScript规范，这个符号作为一个属性表示“一个函数
值，该函数作为创建派生对象的构造函数”。这个属性在内置类型
中最常用，用于对内置类型实例方法的返回值暴露实例化派生对
象的方法。用 Symbol.species 定义静态的获取器（getter）方
法，可以覆盖新创建实例的原型定义：
13. Symbol.split
根据ECMAScript规范，这个符号作为一个属性表示“一个正则表
达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由
String.prototype.split() 方法使用”。
String.prototype.split() 方法会使用以
Symbol.split 为键的函数来对正则表达式求值。正则表达式
的原型上默认有这个函数的定义，因此所有正则表达式实例默认
是这个 String 方法的有效参数：
14. Symbol.toPrimitive根据ECMAScript规范，这个符号作为一个属性表示“一个方法，
该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作
使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字
符串、数值和未指定的原始类型。对于一个自定义对象实例，通
过在这个实例的 Symbol.toPrimitive 属性上定义一个函数
可以改变默认行为。
根据提供给这个函数的参数（ string 、 number 或
default ），可以控制返回的原始值
15. Symbol.toStringTag
根据ECMAScript规范，这个符号作为一个属性表示“一个字符
串，该字符串用于创建对象的默认字符串描述。由内置方法
Object.prototype.toString() 使用”。
通过 toString() 方法获取对象标识时，会检索由
Symbol.toStringTag 指定的实例标识符，默认
为 "Object" 。内置类型已经指定了这个值，但自定义类实例
还需要明确定义
16. Symbol.unscopables
根据ECMAScript规范，这个符号作为一个属性表示“一个对象，
该对象所有的以及继承的属性，都会从关联对象的 with 环境绑
定中排除”。设置这个符号并让其映射对应属性的键值为true ，就可以阻止该属性出现在 with 环境绑定中，如下例所
示：
17、Object 类型
ECMAScript中的对象其实就是一组数据和功能的集合。对象通
过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建
Object 类型的实例来创建自己的对象，然后再给对象添加属性和方
法：
let o = new Object();这个语法类似Java，但ECMAScript只要求在给构造函数提供参数
时使用括号。如果没有参数，如上面的例子所示，那么完全可以省略
括号（不推荐）：
let o = new Object; // 合法，但不推荐

每个 Object 实例都有如下属性和方法。
constructor ：用于创建当前对象的函数。在前面的例子中，
这个属性的值就是 Object() 函数。
hasOwnProperty(propertyName) ：用于判断当前对象实
例（不是原型）上是否存在给定的属性。要检查的属性名必须是
字符串（如 o.hasOwnProperty("name") ）。
isPrototypeof(object) ：用于判断当前对象是否为另一个
对象的原型。（第5章将详细介绍原型。）
propertyIsEnumerable(propertyName) ：用于判断给定
的属性是否可以使用（本章稍后讨论的） for-in 语句枚举。
与 hasOwnProperty() 一样，属性名必须是字符串。
toLocaleString() ：返回对象的字符串表示，该字符串反映
对象所在的本地化执行环境。
toString() ：返回对象的字符串表示。valueOf() ：返回对象对应的字符串、数值或布尔值表示。通
常与 toString() 的返回值相同。
18、操作符
ECMA-262描述了一组可用于操作数据值的操作符，包括数学操
作符（如加、减）、位操作符、关系操作符和相等操作符等。
ECMAScript中的操作符是独特的，因为它们可用于各种值，包括字符
串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会
调用 valueOf() 和 / 或 toString() 方法来取得可以计算的值。
19、一元操作符
只操作一个值的操作符叫一元操作符（unary operator）。一元操
作符是ECMAScript中最简单的操作符
1. 递增/递减操作符
递增和递减操作符直接照搬自C语言，但有两个版本：前缀版和
后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版
就是位于要操作的变量后头。前缀递增操作符会给数值加1，把两
个加号（ ++ ）放到变量前头即可
2. 一元加和减
一元加和减操作符对大多数开发者来说并不陌生，它们在
ECMAScript中跟在高中数学中的用途一样。一元加由一个加号
（ + ）表示，放在变量前头，对数值没有任何影响：
20、 位操作符
ECMAScript中的所有数值都以IEEE 754 64位
格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32
位整数，再进行位操作，之后再把结果转换为64位。对开发者而言，就好像只有32位整数一样，因为64位整数存储格式是不可见的。既然
知道了这些，就只需要考虑32位整数即可。
有符号整数使用32位的前31位表示整数值。第32位表示数值的符
号，如0表示正，1表示负。这一位称为符号位（sign bit），它的值决
定了数值其余部分的格式。正值以真正的二进制格式存储，即31位中
的每一位都代表2的幂。第一位（称为第0位）表示20，第二位表示
21，依此类推。如果一个位是空的，则以0填充，相当于忽略不计。比
如，数值18的二进制格式为00000000000000000000000000010010，或
更精简的10010。后者是用到的5个有效位，决定了实际的值
1. 按位非
按位非操作符用波浪符（ ~ ）表示，它的作用是返回数值的一补
数。按位非是ECMAScript中为数不多的几个二进制数学操作符之
一。
2. 按位与
按位与操作符用和号（ & ）表示，有两个操作数。本质上，按位
与就是将两个数的每一个位对齐，然后基于真值表中的规则，对
每一位执行相应的与操作。
4. 按位异或
按位异或用脱字符（ ^ ）表示，同样有两个操作数。下面是按位
异或的真值表：
第一个数的位
第二个数的位
结果
1
1
0
1
0
1
0
1
1
0
0
0
按位异或与按位或的区别是，它只在一位上是1的时候返回1（两
位都是1或0，则返回0）
5. 左移
左移操作符用两个小于号（ << ）表示，会按照指定的位数将数
值的所有位向左移动。比如，如果数值2（二进制10）向左移5
位，就会得到64（二进制1000000）
6. 有符号右移
有符号右移由两个大于号（ >> ）表示，会将数值的所有32位都
向右移，同时保留符号（正或负）。有符号右移实际上是左移的
逆运算。比如，如果将64右移5位，那就是2：
7. 无符号右移
无符号右移用3个大于号表示（ >>> ），会将数值的所有32位都
向右移。对于正数，无符号右移与有符号右移结果相同。仍然以
前面有符号右移的例子为例，64向右移动5位，会变成2：
21、布尔操作符
对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如
果没有能力测试两个值的关系，那么像 if-else 和循环这样的语句
也没什么用了。布尔操作符一共有3个：逻辑非、逻辑与和逻辑或。
1. 逻辑非
逻辑非操作符由一个叹号（ ! ）表示，可应用给ECMAScript中
的任何值。这个操作符始终返回布尔值，无论应用到的是什么数
据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其
取反。换句话说，逻辑非操作符会遵循如下规则。
如果操作数是对象，则返回 false 。
如果操作数是空字符串，则返回 true 。
如果操作数是非空字符串，则返回 false 。
如果操作数是数值0，则返回 true 。
如果操作数是非0数值（包括 Infinity ），则返回
false 。
如果操作数是 null ，则返回 true 。
如果操作数是 NaN ，则返回 true 。如果操作数是 undefined ，则返回 true 。
2. 逻辑与
逻辑与操作符由两个和号（ && ）表示，应用到两个值，如下所
示：
let result = true && fal
逻辑与操作符遵循如下真值表：第一个操作数
第二个操作数
结果
true
true
true
true
false
false
false
true
false
false
false
false
逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有
操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循
如下规则。
如果第一个操作数是对象，则返回第二个操作数。
如果第二个操作数是对象，则只有第一个操作数求值为
true 才会返回该对象。
如果两个操作数都是对象，则返回第二个操作数。
如果有一个操作数是 null ，则返回 null 。
如果有一个操作数是 NaN ，则返回 NaN 。
如果有一个操作数是 undefined ，则返回 undefined 。
3. 逻辑或
逻辑或操作符由两个管道符（ || ）表示，比如：
let result = true || false;
逻辑或操作符遵循如下真值表：
第一个操作数
第二个操作数
结果
true
true
true
true
false
true
false
true
true
false
false
false
与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作
符也不一定返回布尔值。它遵循如下规则。如果第一个操作数是对象，则返回第一个操作数。
如果第一个操作数求值为 false ，则返回第二个操作数。
如果两个操作数都是对象，则返回第一个操作数。
如果两个操作数都是 null ，则返回 null 。
如果两个操作数都是 NaN ，则返回 NaN 。
如果两个操作数都是 undefined ，则返回 undefined 。
同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对
逻辑或而言，第一个操作数求值为 true ，第二个操作数就不会
再被求值了
22、乘性操作符
ECMAScript定义了3个乘性操作符：乘法、除法和取模。这些操
作符跟它们在Java、C语言及Perl中对应的操作符作用一样，但在处理
非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不
是数值的操作数，则该操作数会在后台被使用 Number() 转型函数
转换为数值。这意味着空字符串会被当成0，而布尔值 true 会被当
成1。
1. 乘法操作符
乘法操作符由一个星号（ * ）表示，可以用于计算两个数值的乘
积。其语法类似于C语言，比如：
let result = 34 * 56;
不过，乘法操作符在处理特殊值时也有一些特殊的行为。
2. 除法操作符
除法操作符由一个斜杠（ / ）表示，用于计算第一个操作数除以
第二个操作数的商，比如：
let result = 66 / 11;
跟乘法操作符一样，除法操作符针对特殊值也有一些特殊的行
为。
如果操作数都是数值，则执行常规的除法运算，即两个正值
相除是正值，两个负值相除也是正值，符号不同的值相除得
到负值。如果ECMAScript不能表示商，则返回 Infinity
或 -Infinity 。
如果有任一操作数是 NaN ，则返回 NaN 。
如果是 Infinity 除以 Infinity ，则返回 NaN 。
如果是0除以0，则返回 NaN 。如果是非0的有限值除以0，则根据第一个操作数的符号返回
Infinity 或 -Infinity 。
如果是 Infinity 除以任何数值，则根据第二个操作数的
符号返回 Infinity 或 -Infinity 。
如果有不是数值的操作数，则先在后台用 Number() 函数
将其转换为数值，然后再应用上述规则
3. 取模操作符
取模（余数）操作符由一个百分比符号（ % ）表示，比如：
let result = 26 % 5; // 等于1
与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行
为。
如果操作数是数值，则执行常规除法运算，返回余数。
如果被除数是无限值，除数是有限值，则返回 NaN 。
如果被除数是有限值，除数是0，则返回 NaN 。
如果是 Infinity 除以 Infinity ，则返回 NaN 。
如果被除数是有限值，除数是无限值，则返回被除数。
如果被除数是0，除数不是0，则返回0。
如果有不是数值的操作数，则先在后台用 Number() 函数
将其转换为数值，然后再应用上述规则。
23、指数操作符
ECMAScript 7新增了指数操作符， Math.pow() 现在有了自己
的操作符 ** ，结果是一样的：
不仅如此，指数操作符也有自己的指数赋值操作符 **= ，该操
作符执行指数运算和结果的赋值操作
24、加性操作符
加性操作符，即加法和减法操作符，一般都是编程语言中最简单
的操作符。不过，在ECMAScript中，这两个操作符拥有一些特殊的行
为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转
换。只不过对这两个操作符来说，转换规则不是那么直观
1. 加法操作符
加法操作符（ + ）用于求两个数的和，比如：
let result = 1 + 2;
如果两个操作数都是数值，加法操作符执行加法运算并根据如下
规则返回结果：如果有任一操作数是 NaN ，则返回 NaN ；
如果是 Infinity 加 Infinity ，则返回 Infinity ；
如果是 -Infinity 加 -Infinity ，则返回 -
Infinity ；
如果是 Infinity 加 -Infinity ，则返回 NaN ；
如果是 +0 加 +0 ，则返回 +0 ；
如果是 -0 加 +0 ，则返回 +0 ；
如果是 -0 加 -0 ，则返回 -0 。
不过，如果有一个操作数是字符串，则要应用如下规则：
如果两个操作数都是字符串，则将第二个字符串拼接到第一
个字符串后面；
如果只有一个操作数是字符串，则将另一个操作数转换为字
符串，再将两个字符串拼接在一起。
如果有任一操作数是对象、数值或布尔值，则调用它们的
toString() 方法以获取字符串，然后再应用前面的关于字符
串的规则。对于 undefined 和 null ，则调用 String() 函
数，分别获取 "undefined" 和 "null" 。
2. 减法操作符
减法操作符（ - ）也是使用很频繁的一种操作符，比如：
let result = 2 - 1;
与加法操作符一样，减法操作符也有一组规则用于处理
ECMAScript中不同类型之间的转换
如果两个操作数都是数值，则执行数学减法运算并返回结
果。
如果有任一操作数是 NaN ，则返回 NaN 。
如果是 Infinity 减 Infinity ，则返回 NaN 。
如果是 -Infinity 减 -Infinity ，则返回 NaN 。
如果是 Infinity 减 -Infinity ，则返回 Infinity 。
如果是 -Infinity 减 Infinity ，则返回 -
Infinity 。
如果是 +0 减 +0 ，则返回 +0 。
如果是 +0 减 -0 ，则返回 -0 。
如果是 -0 减 -0 ，则返回 +0 。
如果有任一操作数是字符串、布尔值、 null 或
undefined ，则先在后台使用 Number() 将其转换为数
值，然后再根据前面的规则执行数学运算。如果转换结果是
NaN ，则减法计算的结果是 NaN 。
如果有任一操作数是对象，则调用其 valueOf() 方法取得
表示它的数值。如果该值是 NaN ，则减法计算的结果是NaN 。如果对象没有 valueOf() 方法，则调用其
toString() 方法，然后再将得到的字符串转换为数值。
25、关系操作符
关系操作符执行比较两个值的操作，包括小于（ < ）、大于
（ > ）、小于等于（ <= ）和大于等于（ >= ），用法跟数学课上学
的一样。这几个操作符都返回布尔值，
26、相等操作符
判断两个变量是否相等是编程中最重要的操作之一。在比较字符
串、数值和布尔值是否相等时，过程都很直观。但是在比较两个对象
是否相等时，情形就比较复杂了。ECMAScript中的相等和不相等操作
符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是
否应该发生。最终，ECMAScript提供了两组操作符。第一组是等于和
不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在
比较之前不执行转换
下表总结了一些特殊情况及比较的结果。
表达式
结果
null == undefined
true
"NaN" == NaN
false
5 == NaN
false
NaN == NaN
false
NaN != NaN
true
false == 0
true
true == 1
true
true == 2
false
undefined == 0
false
null == 0
false
"5" == 5
true
2. 全等和不全等
全等和不全等操作符与相等和不相等操作符类似，只不过它们在
比较相等时不转换操作数。全等操作符由3个等于号（ === ）表
示，只有两个操作数在不转换的前提下相等才返回 true ，
26、条件操作符
条件操作符是ECMAScript中用途最为广泛的操作符之一，语法跟
Java中一样
variable = boolean_expression ? true_value :
false_value;
上面的代码执行了条件赋值操作，即根据条件表达式
boolean_expression 的值决定将哪个值赋给变量 variable 。
如果 boolean_expression 是 true ，则赋值 true_value ；
如果 boolean_expression 是 false ，则赋值
false_value 。
27、赋值操作符
简单赋值用等于号（ = ）表示，将右手边的值赋给左手边的变
量，如下所示：
let num = 10;复合赋值使用乘性、加性或位操作符后跟等于号（ = ）表示。这
些赋值操作符是类似如下常见赋值操作的简写形式：
let num = 10;
num = num + 10;
每个数学操作符以及其他一些操作符都有对应的复合赋值操作
符：
乘后赋值（ *= ）
除后赋值（ /= ）
取模后赋值（ %= ）
加后赋值（ += ）
减后赋值（ -= ）
左移后赋值（ <<= ）
右移后赋值（ >>= ）
无符号右移后赋值（ >>>= ）
这些操作符仅仅是简写语法，使用它们不会提升性能
28、逗号操作符
逗号操作符可以用来在一条语句中执行多个操作，如下所示：let num1 = 1, num2 = 2, num3 = 3;
在一条语句中同时声明多个变量是逗号操作符最常用的场景。不
过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分
隔值，最终会返回表达式中最后一个值
29、语句
ECMA-262描述了一些语句（也称为流控制语句），而
ECMAScript中的大部分语法都体现在语句中。语句通常使用一或多个
关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉
函数退出，复杂的如列出一堆要重复执行的指令。
30、函数
函数对任何语言来说都是核心组件，因为它们可以封装语句，然
后在任何地方、任何时间执行。ECMAScript中的函数使用
function 关键字声明，后跟一组参数，然后是函数体。
下面是一个例子：
function sayHi(name, message) {
console.log("Hello " + name + ", " + message);
}
可以通过函数名来调用函数，要传给函数的参数放在括号里（如
果有多个参数，则用逗号隔开）。下面是调用函数 sayHi() 的示
例：
sayHi("Nicholas", "how are you today?");
调用这个函数的输出结果是 "Hello Nicholas, how are
you today?" 。参数 name 和 message 在函数内部作为字符串被
拼接在了一起，最终通过 console.log 输出到控制台。
ECMAScript中的函数不需要指定是否返回值。任何函数在任何时
间都可以使用 return 语句来返回函数的值，用法是后跟要返回的
值。
函数 sum() 会将两个值相加并返回结果。注意，除了 return
语句之外没有任何特殊声明表明该函数有返回值。然后就可以这样调用它：
const result = sum(5, 10);
要注意的是，只要碰到 return 语句，函数就会立即停止执行并
退出。因此， return 语句后面的代码不会被执行。比如：
function sum(num1, num2) {
return num1 + num2;
console.log("Hello world"); // 不会执行
}
在这个例子中， console.log 不会执行，因为它在 return
语句后面。
一个函数里也可以有多个 return 语句，像这样：
function diff(num1, num2) {
if (num1 < num2) {
return num2 - num1;
} else {
return num1 - num2;
}
}
这个 diff() 函数用于计算两个数值的差。如果第一个数值小于
第二个，则用第二个减第一个；否则，就用第一个减第二个。代码中
每个分支都有自己的 return 语句，返回正确的差值。
return 语句也可以不带返回值。这时候，函数会立即停止执行
并返回 undefined 。这种用法最常用于提前终止函数执行，并不是为了返回值。比如在下面的例子中， console.log 不会执行：
function sayHi(name, message) {
return;
console.log("Hello " + name + ", " + message);
// 不会执行
}
注意 最佳实践是函数要么返回值，要么不返回值。只在某个条件
下返回值的函数会带来麻烦，尤其是调试时。
严格模式对函数也有一些限制：
函数不能以 eval 或 arguments 作为名称；
函数的参数不能叫 eval 或 arguments ；
两个函数的参数不能叫同一个名称
31、小结
ECMAScript中的基本元素。
ECMAScript中的基本数据类型包括 Undefined 、 Null 、
Boolean 、 Number 、 String 和 Symbol 。与其他语言不同，ECMAScript不区分整数和浮点值，只有
Number 一种数值数据类型。
Object 是一种复杂数据类型，它是这门语言中所有对象的基
类。
严格模式为这门语言中某些容易出错的部分施加了限制。
ECMAScript提供了C语言和类C语言中常见的很多基本操作符，
包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值
操作符等。
这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如
if 语句、 for 语句和 switch 语句等。
ECMAScript中的函数与其他语言中的函数不一样。
不需要指定函数的返回值，因为任何函数可以在任何时候返回任
何值。
不指定返回值的函数实际上会返回特殊值 undefined 。
32、原始值与引用值
ECMAScript变量可以包含两种不同类型的数据：原始值和引用
值。原始值（primitive value）就是最简单的数据，引用值（reference
value）则是由多个值构成的对象。
在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值
还是引用值。上一章讨论了6种原始值： Undefined 、 Null 、
Boolean 、 Number 、 String 和 Symbol 。保存原始值的变量
是按值（by value）访问的，因为我们操作的就是存储在变量中的实际
值。
33、动态属性
原始值和引用值的定义方式很类似，都是创建一个变量，然后给
它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什
么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属
性和方法。
注意，原始类型的初始化可以只使用原始字面量形式。如果使用
的是 new 关键字，则JavaScript会创建一个 Object 类型的实例，但
其行为类似原始值。
34、复制值
除了存储方式不同，原始值和引用值在通过变量复制时也有所不
同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制
到新变量的位置。请看下面的例子：
let num1 = 5;
let num2 = num1;
这里， num1 包含数值5。当把 num2 初始化为 num1 时，
num2 也会得到数值5。这个值跟存储在 num1 中的5是完全独立的，
因为它是那个值的副本。
这两个变量可以独立使用，互不干扰。
35、传递参数
ECMAScript中所有函数的参数都是按值传递的。这意味着函数外
的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变
量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引
用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块
可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值
传递。
在按值传递参数时，值会被复制到一个局部变量（即一个命名参
数，或者用ECMAScript的话说，就是 arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部
变量，这意味着对本地变量的修改会反映到函数外部。（这在
ECMAScript中是不可能的。）


function addTen(num) {
num += 10;
return num;
}
let count = 20;
let result = addTen(count);
console.log(count); // 20，没有变化
console.log(result); // 30
这里，函数 addTen() 有一个参数 num ，它其实是一个局部变
量。在调用时，变量 count 作为参数传入。 count 的值是20，这
个值被复制到参数 num 以便在 addTen() 内部使用。在函数内部，
参数num的值被加上了10，但这不会影响函数外部的原始变量
count 。参数 num 和变量 count 互不干扰，它们只不过碰巧保存
了一样的值。如果 num 是按引用传递的，那么 count 的值也会被修
改为30。这个事实在使用数值这样的原始值时是非常明显的。但是，
如果变量中传递的是对象，就没那么清楚了
36、确定类型
typeof 虽然对原始值很有用，但它对引用值的用处不大。我们
通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript提供了 instanceof 操作符，语法如
下：
result = variable instanceof constructor
如果变量是给定引用类型（由其原型链决定，将在第8章详细介
绍）的实例，则 instanceof 操作符返回 true 。来看下面的例
子：
console.log(person instanceof Object); // 变量
persion是Object吗？
console.log(colors instanceof Array); // 变量
colors是Array吗？
console.log(pattern instanceof RegExp); // 变量
pattern是RegExp吗？
按照定义，所有引用值都是 Object 的实例，因此通过
instanceof 操作符检测任何引用值和 Object 构造函数都会返
回 true 。类似地，如果用 instanceof 检测原始值，则始终会返
回 false ，因为原始值不是对象。
37、执行上下文与作用域
执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重
要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们
的行为。每个上下文都有一个关联的变量对象（variable object），而
这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法
通过代码访问变量对象，但后台处理数据会用到它。
全局上下文是最外层的上下文。根据ECMAScript实现的宿主环
境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就
是我们常说的 window 对象（第12章会详细介绍），因此所有通过
var 定义的全局变量和函数都会成为 window 对象的属性和方法。
使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用
域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销
毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退
出前才会被销毁，比如关闭网页或退出浏览器）。
每个函数调用都有自己的上下文。当代码执行流进入函数时，函
数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会
弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript
程序的执行流就是通过这个上下文栈进行控制的。
上下文中的代码在执行的时候，会创建变量对象的一个作用域链
（scope chain）。这个作用域链决定了各级上下文中的代码在访问变
量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用
域链的最前端。如果上下文是函数，则其活动对象（activation
object）用作变量对象。活动对象最初只有一个定义变量：
arguments 。（全局上下文中没有这个变量。）作用域链中的下一
个变量对象来自包含上下文，再下一个对象来自再下一个包含上下
文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域
链的最后一个变量对象。代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称
完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直
到找到标识符。
38、作用域链增强
虽然执行上下文主要有全局上下文和函数上下文两种（ eval()
调用内部存在第三种上下文），但有其他方式来增强作用域链。某些
语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码
执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到
下面任意一种情况时：
try / catch 语句的 catch 块
with 语句
这两种情况下，都会在作用域链前端添加一个变量对象。对
with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的
错误对象的声明。
39、变量声明
ES6之后，JavaScript的变量声明经历了翻天覆地的变化。直到
ECMAScript 5.1， var 都是声明变量的唯一关键字。ES6不仅增加了
let 和 const 两个关键字，而且还让这两个关键字压倒性地超越
var 成为首选。
1. 使用 var 的函数作用域声明
在使用 var 声明变量时，变量会被自动添加到最接近的上下
文。在函数中，最接近的上下文就是函数的局部上下文。在
with 语句中，最接近的上下文也是函数上下文。如果变量未经
声明就被初始化了，那么它就会自动被添加到全局上下文，如下
面的例子所示：
function add(num1, num2) {
var sum = num1 + num2;
return sum;
}
let result = add(10, 20); // 30
console.log(sum); // 报错：sum在这里不是
有效变量
2. 使用 let 的块级作用域声明
ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级
的，这也是JavaScript中的新概念。块级作用域由最近的一对包含
花括号 {} 界定。换句话说， if 块、 while 块、 function
块，甚至连单独的块也是 let 声明变量的作用域。
if (true) {
let a;}
console.log(a); // ReferenceError: a没有定义
while (true) {
let b;
}
console.log(b); // ReferenceError: b没有定义
function foo() {
let c;
}
console.log(c); // ReferenceError: c没有定义
// 这没什么可奇怪的
// var声明也会导致报错
// 这不是对象字面量，而是一个独立的块
// JavaScript解释器会根据其中内容识别出它来
{
let d;
}
console.log(d); // ReferenceError: d没有定义
let 与 var 的另一个不同之处是在同一作用域内不能声明两
次。重复的 var 声明会被忽略，而重复的 let 声明会抛出
SyntaxError 。
3. 使用 const 的常量声明
除了 let ，ES6同时还增加了 const 关键字。使用 const 声
明的变量必须同时初始化为某个值。一经声明，在其生命周期的
任何时候都不能再重新赋予新值。
const a; // SyntaxError: 常量声明时没有初始化
const b = 3;console.log(b); // 3
b = 4; // TypeError: 给常量赋值
const 除了要遵循以上规则，其他方面与 let 声明是一样的
4. 标识符查找
当在特定上下文中为读取或写入而引用一个标识符时，必须通过
搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给
定的名称搜索对应的标识符。如果在局部上下文中找到该标识
符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此
搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至
全局上下文的变量对象。如果仍然没有找到标识符，则说明其未
声明。
40、垃圾回收
JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码
执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是
个很大的负担，也是很多问题的来源。JavaScript为开发者卸下了这个
负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很
简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程
是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程
中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且
不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，
意味着靠算法是解决不了的。
我们以函数中局部变量的正常生命周期为例。函数中的局部变量
会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应
的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局
部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不
再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序
必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回
收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏
览器的发展史上，用到过两种主要的标记策略：标记清理和引用计
数。
41、标记清理
JavaScript最常用的垃圾回收策略是标记清理（mark-and
sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑
上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运
行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下
文的标记。
给变量加标记的方式有很多种。比如，当变量进入上下文时，反
转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列
表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不
重要，关键是策略。
垃圾回收程序运行的时候，会标记内存中存储的所有变量（记
住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以
及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标
记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到
它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并
收回它们的内存。
到了2008年，IE、Firefox、Opera、Chrome和Safari都在自己的
JavaScript实现中采用标记清理（或其变体），只是在运行垃圾回收的
频率上有所差异。
42、引用计数
另一种没那么常用的垃圾回收策略是引用计数（reference
counting）。其思路是对每个值都记录它被引用的次数。声明变量并给
它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一
个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他
值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办
法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序
下次运行的时候就会释放引用数为0的值的内存。
引用计数最早由Netscape Navigator 3.0采用，但很快就遇到了严重
的问题：循环引用。所谓循环引用，就是对象A有一个指针指向对象B，而对象B也引用了对象A。
43、性能
垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可
能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有
限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。
开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代
码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工
作。
现代垃圾回收程序会基于对JavaScript运行时环境的探测来决定何
时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小
和数量来判断的。比如，根据V8团队2016年的一篇博文的说法：“在
一次完整的垃圾回收之后，V8的堆增长策略会根据活跃对象的数量外
加一些余量来确定何时再次垃圾回收。”
由于调度垃圾回收程序方面的问题会导致性能下降，IE曾饱受诟
病。它的策略是根据分配数，比如分配了256个变量、4096个对象/数
组字面量和数组槽位（slot），或者64KB字符串。只要满足其中某个
条件，垃圾回收程序就会运行。这样实现的问题在于，分配那么多变
量的脚本，很可能在其整个生命周期内始终需要那么多变量，结果就
会导致垃圾回收程序过于频繁地运行。由于对性能的严重影响，IE7最
终更新了垃圾回收程序。
IE7发布后，JavaScript引擎的垃圾回收程序被调优为动态改变分
配变量、字面量或数组槽位等会触发垃圾回收的阈值。IE7的起始阈值
都与IE6的相同。如果垃圾回收程序回收的内存不到已分配的15%，这
些变量、字面量或数组槽位的阈值就会翻倍。如果有一次回收的内存
达到已分配的85%，则阈值重置为默认值。这么一个简单的修改，极
大地提升了重度依赖JavaScript的网页在浏览器中的性能。
44、内存管理
在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。
不过，JavaScript运行在一个内存管理与垃圾回收都很特殊的环境。分
配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏
览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运
行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存
限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执
行的语句数量。
将内存占用量保持在一个较小的值可以让页面性能更好。优化内
存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数
据不再必要，那么把它设置为 null ，从而释放其引用。这也可以叫
作解除引用。这个建议最适合全局变量和全局对象的属性。局部变量
在超出作用域后会被自动解除引用
不过要注意，解除对一个值的引用并不会自动导致相关内存被回
收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它
在下次垃圾回收时会被回收。
1. 通过 const 和 let 声明提升性能
ES6增加这两个关键字不仅有助于改善代码风格，而且同样有助
于改进垃圾回收的过程。因为 const 和 let 都以块（而非函
数）为作用域，所以相比于使用 var ，使用这两个新关键字可
能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在
块作用域比函数作用域更早终止的情况下，这就有可能发生。
2. 隐藏类和删除操作
根据JavaScript所在的运行环境，有时候需要根据浏览器使用的
JavaScript引擎来采取不同的性能优化策略。截至2017年，Chrome
是最流行的浏览器，使用V8 JavaScript引擎。V8在将解释后的
JavaScript代码编译为实际的机器码时会利用“隐藏类”。如果你的
代码非常注重性能，那么这一点可能对你很重要。
运行期间，V8会将创建的对象与隐藏类关联起来，以跟踪它们的
属性特征。能够共享相同隐藏类的对象性能会更好，V8会针对这
种情况进行优化，但不一定总能够做到。比如下面的代码：function Article() {
this.title = 'Inauguration Ceremony
Features Kazoo Band';
}
let a1 = new Article();
let a2 = new Article();
V8会在后台配置，让这两个类实例共享相同的隐藏类，因为这两
个实例共享同一个构造函数和原型。假设之后又添加了下面这行
代码：
a2.author = 'Jake';
此时两个 Article 实例就会对应两个不同的隐藏类。根据这种
操作的频率和隐藏类的大小，这有可能对性能产生明显影响。
当然，解决方案就是避免JavaScript的“先创建再补充”（ready-fire
aim）式的动态属性赋值，并在构造函数中一次性声明所有属性，
如下所示：
function Article(opt_author) {
this.title = 'Inauguration Ceremony
Features Kazoo Band';
this.author = opt_author;
}
let a1 = new Article();
let a2 = new Article('Jake');这样，两个实例基本上就一样了（不考虑 hasOwnProperty 的
返回值），因此可以共享一个隐藏类，从而带来潜在的性能提
升。不过要记住，使用 delete 关键字会导致生成相同的隐藏类
片段。看一下这个例子：
function Article() {
this.title = 'Inauguration Ceremony
Features Kazoo Band';
this.author = 'Jake';
}
let a1 = new Article();
let a2 = new Article();
delete a1.author;
在代码结束后，即使两个实例使用了同一个构造函数，它们也不
再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一
样。最佳实践是把不想要的属性设置为 null 。这样可以保持隐
藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序
回收的效果。比如：
function Article() {
this.title = 'Inauguration Ceremony
Features Kazoo Band';
this.author = 'Jake';
}
let a1 = new Article();let a2 = new Article();
a1.author = null;
3. 内存泄漏
写得不好的JavaScript可能出现难以察觉且有害的内存泄漏问题。
在内存有限的设备上，或者在函数会被调用很多次的情况下，内
存泄漏可能是个大问题。JavaScript中的内存泄漏大部分是由不合
理的引用导致的。
意外声明全局变量是最常见但也最容易修复的内存泄漏问题。下
面的代码没有使用任何关键字声明变量
4. 静态分配与对象池
为了提升JavaScript性能，最后要考虑的一点往往就是压榨浏览器
了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次
数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控
制触发垃圾回收的条件。理论上，如果能够合理使用分配的内
存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失
的性能。
浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速
度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样
当然会影响性能。看一看下面的例子，这是一个计算二维矢量加
法的函数
45、基本引用类型
引用值（或者对象）是某个特定引用类型的实例。在ECMAScript中，
引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽
然从技术上讲JavaScript是一门面向对象语言，但ECMAScript缺少传统的面
向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也
被称为对象定义，因为它们描述了自己的对象应有的属性和方法。
46、Date
TC，Universal Time Coordinated）时间1970年1月1日午夜（零时）至今
所经过的毫秒数。使用这种存储格式， Date 类型可以精确表示1970年1月
1日之前及之后285 616年的日期。
要创建日期对象，就使用 new 操作符来调用 Date 构造函数：
let now = new Date();
在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期
和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示
（UNIX纪元1970年1月1日午夜之后的毫秒数）。ECMAScript为此提供了两
个辅助方法： Date.parse() 和 Date.UTC() 。
Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字
符串转换为表示该日期的毫秒数。ECMA-262第5版定义了
Date.parse() 应该支持的日期格式，填充了第3版遗留的空白。所有实
现都必须支持下列日期格式：
“月/日/年”，如 "5/23/2019" ；
“月名 日, 年”，如 "May 23, 2019" ；
“周几 月名 日 年 时:分:秒 时区”，如 "Tue May 23 2019 00:00:00
GMT-0700" ；
ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-
23T00:00:00 （只适用于兼容ES5的实现）。
47、继承的方法
与其他类型一样， Date 类型重写了 toLocaleString() 、
toString() 和 valueOf() 方法。但与其他类型不同，重写后这些方法
的返回值不一样。 Date 类型的 toLocaleString() 方法返回与浏览器
运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的
AM（上午）或PM（下午），但不包含时区信息（具体格式可能因浏览器而
不同）。 toString() 方法通常返回带时区信息的日期和时间，而时间也
是以24小时制（0~23）表示的。下面给出了 toLocaleString() 和
toString() 返回的2019年2月1日零点的示例（地区为 "en-US" 的
PST，即Pacific Standard Time，太平洋标准时间）：
toLocaleString() - 2/1/2019 12:00:00 AM
toString() - Thu Feb 1 2019 00:00:00 GMT-0800
(Pacific Standard Time)
现代浏览器在这两个方法的输出上已经趋于一致。在比较老的浏览器
上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味
着 toLocaleString() 和 toString() 可能只对调试有用，不能用于
显示
48、日期格式化方法
Date 类型有几个专门用于格式化日期的方法，它们都会返回字符
串：
toDateString() 显示日期中的周几、月、日、年（格式特定于实
现）；
toTimeString() 显示日期中的时、分、秒和时区（格式特定于实
现）；
toLocaleDateString() 显示日期中的周几、月、日、年（格式特
定于实现和地区）；
toLocaleTimeString() 显示日期中的时、分、秒（格式特定于实
现）；
toUTCString() 显示完整的UTC日期（格式特定于实现）。
这些方法的输出与 toLocaleString() 和 toString() 一样，会
因浏览器而异。因此不能用于在用户界面上一致地显示日期。
49、日期/时间组件方法
Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定
部分。注意表中“UTC日期”，指的是没有时区偏移（将日期转换为GMT）时
的日期。







50、RegExp
ECMAScript通过 RegExp 类型支持正则表达式。正则表达式使用类似
Perl的简洁语法来创建：
let expression = /pattern/flags;
这个正则表达式的 pattern （模式）可以是任何简单或复杂的正则表
达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式
可以带零个或多个 flags （标记），用于控制正则表达式的行为。下面给
出了表示匹配模式的标记。
g ：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配
的内容就结束。
i ：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大
小写。
m ：多行模式，表示查找到一行文本末尾时会继续查找。
y ：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
u ：Unicode模式，启用Unicode匹配。
s ： dotAll 模式，表示元字符 . 匹配任何字符（包括 \n 或
\r ）。
使用不同模式和标记可以创建出各种正则表达式

51、RegExp 实例属性
每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。
global ：布尔值，表示是否设置了 g 标记。
ignoreCase ：布尔值，表示是否设置了 i 标记。
unicode ：布尔值，表示是否设置了 u 标记。
sticky ：布尔值，表示是否设置了 y 标记。
lastIndex ：整数，表示在源字符串中下一次搜索的开始位置，始
终从0开始。
multiline ：布尔值，表示是否设置了 m 标记。
dotAll ：布尔值，表示是否设置了 s 标记。
source ：正则表达式的字面量字符串（不是传给构造函数的模式字
符串），没有开头和结尾的斜杠。
flags ：正则表达式的标记字符串。始终以字面量而非传入构造函数
的字符串模式形式返回（没有前后斜杠）。
通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并
不多，因为模式声明中包含这些信息。
52、RegExp 实例方法
RegExp 实例的主要方法是 exec() ，主要用于配合捕获组使用。这
个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返
回包含第一个匹配信息的数组；如果没找到匹配项，则返回 null 。返回
的数组虽然是 Array 的实例，但包含两个额外的属性： index 和
input 。 index 是字符串中匹配模式的起始位置， input 是要查找的
字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表
达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个
元素。
52、RegExp 构造函数属性
为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据
最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过
两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。
下表列出了 RegExp 构造函数的属性。

通过这些属性可以提取出与 exec() 和 test() 执行的操作相关的信
息。
不同属性包含的内容如下。
input 属性中包含原始的字符串。
leftConext 属性包含原始字符串中 "short" 之前的内容，
rightContext 属性包含 "short" 之后的内容。
lastMatch 属性包含匹配整个正则表达式的上一个字符串，
即 "short" 。
lastParen 属性包含捕获组的上一次匹配，即 "s" 。
53、模式局限
虽然ECMAScript对正则表达式的支持有了长足的进步，但仍然缺少Perl
语言中的一些高级特性。下列特性目前还没有得到ECMAScript的支持（想
要了解更多信息，可以参考Regular-Expressions.info网站）：
\A 和 \Z 锚（分别匹配字符串的开始和末尾）
联合及交叉类
原子组
x （忽略空格）匹配模式
条件式匹配
正则表达式注释
虽然还有这些局限，但ECMAScript的正则表达式已经非常强大，可以
用于大多数模式匹配任务。
54、原始值包装类型
为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：
Boolean 、 Number 和 String 。这些类型具有本章介绍的其他引用类
型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴
露出操作原始值的各种方法。

我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操
作。具体来说，当第二行访问 s1 时，是以读模式访问的，也就是要从内存
中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行
以下3步：
(1) 创建一个 String 类型的实例；
(2) 调用实例上的特定方法；
(3) 销毁实例。
可以把这3步想象成执行了如下3行ECMAScript代码：
let s1 = new String("some text");
let s2 = s1.substring(2);
s1 = null;
55、Boolean
Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就
使用 Boolean 构造函数并传入 true 或 false ，如下例所示：
let booleanObject = new Boolean(true);
Boolean 的实例会重写 valueOf() 方法，返回一个原始值 true
或 false 。 toString() 方法被调用时也会被覆盖，返回字符
串 "true" 或 "false" 。不过， Boolean 对象在ECMAScript中用得很
少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用
Boolean 对象时
56、Number
Number 是对应数值的引用类型。要创建一个 Number 对象，就使
用 Number 构造函数并传入一个数值，如下例所示：
let numberObject = new Number(10);
与 Boolean 类型一样， Number 类型重写了 valueOf() 、
toLocaleString() 和 toString() 方法。 valueOf() 方法返回
Number 对象表示的原始数值，另外两个方法返回数值字符串。
toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式
的数值字符串
57、String
String 是对应字符串的引用类型。要创建一个 String 对象，使
用 String 构造函数并传入一个数值，如下例所示：
let stringObject = new String("hello world");
String 对象的方法可以在所有字符串原始值上调用。3个继承的方
法 valueOf() 、 toLcaleString() 和 toString() 都返回对象的原
始字符串值。
每个 String 对象都有一个 length 属性，表示字符串中字符的数
量。
1. JavaScript字符JavaScript字符串由16位码元（code unit）组成。对多数字符来说，每16
位码元对应一个字符。换句话说，字符串的 length 属性表示字符串
包含多少16位码元：
2. normalize() 方法
某些Unicode字符可以有多种编码方式。有的字符既可以通过一个BMP
字符表示，也可以通过一个代理对表示。比如：
// U+00C5：上面带圆圈的大写拉丁字母A
console.log(String.fromCharCode(0x00C5));
// Å
// U+212B：长度单位“埃”
console.log(String.fromCharCode(0x212B));
// Å
// U+004：大写拉丁字母A
// U+030A：上面加个圆圈
console.log(String.fromCharCode(0x0041, 0x030A));
// Å
比较操作符不在乎字符看起来是什么样的，因此这3个字符互不相等。
3. 字符串操作方法
本节介绍几个操作字符串值的方法。首先是 concat() ，用于将一个
或多个字符串拼接成一个新字符串。来看下面的例子：
let stringValue = "hello ";
let result = stringValue.concat("world");
console.log(result); // "hello world"
console.log(stringValue); // "hello"
在这个例子中，对 stringValue 调用 concat() 方法的结果是得
到 "hello world" ，但 stringValue 的值保持不变。
concat() 方法可以接收任意多个参数，因此可以一次性拼接多个字
符串
4. 字符串位置方法
有两个方法用于在字符串中定位子字符串： indexOf() 和
lastIndexOf() 。这两个方法从字符串中搜索传入的字符串，并返
回位置（如果没找到，则返回 -1 ）。两者的区别在于，
indexOf() 方法从字符串开头开始查找子字符串，而lastIndexOf() 方法从字符串末尾开始查找子字符串。
5. 字符串包含方法
ECMAScript 6增加了3个用于判断字符串中是否包含另一个字符串的方
法： startsWith() 、 endsWith() 和 includes() 。这些方法
都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔
值。它们的区别在于， startsWith() 检查开始于索引0的匹配项，
endsWith() 检查开始于索引 (string.length -
substring.length) 的匹配项，而 includes() 检查整个字符
串：
6. trim() 方法
ECMAScript在所有字符串上都提供了 trim() 方法。这个方法会创建
字符串的一个副本，删除前、后所有空格符，再返回结果。比如：
let stringValue = " hello world ";
let trimmedStringValue = stringValue.trim();
console.log(stringValue); // " hello
world "
console.log(trimmedStringValue); // "hello
world"
由于 trim() 返回的是字符串的副本，因此原始字符串不受影响，即
原本的前、后空格符都会保留。
另外， trimeLeft() 和 trimRight() 方法分别用于从字符串开始
和末尾清理空格符。
7. repeat() 方法
ECMAScript在所有字符串上都提供了 repeat() 方法。这个方法接收
一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后
的结果。
let stringValue = "na ";
console.log(stringValue.repeat(16) + "batman");
// na na na na na na na na na na na na na na na
na batman
8. padStart() 和 padEnd() 方法
padStart() 和 padEnd() 方法会复制字符串，如果小于指定长
度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个
参数是长度，第二个参数是可选的填充字符串，默认为空格
（U+0020）
9. 字符串迭代与解构
字符串的原型上暴露了一个 @@iterator 方法，表示可以迭代字符串
的每个字符。可以像下面这样手动使用迭代器：let message = "abc";
let stringIterator = message[Symbol.iterator]();
console.log(stringIterator.next()); // {value:
"a", done: false}
console.log(stringIterator.next()); // {value:
"b", done: false}
console.log(stringIterator.next()); // {value:
"c", done: false}
console.log(stringIterator.next()); // {value:
undefined, done: true}
在 for-of 循环中可以通过这个迭代器按序访问每个字符：
10. 字符串大小写转换
下一组方法涉及大小写转换，包括4个方法： toLowerCase() 、
toLocaleLowerCase() 、 toUpperCase() 和
toLocaleUpperCase() 。 toLowerCase() 和
toUpperCase() 方法是原来就有的方法，与 java.lang.String
中的方法同名。 toLocaleLowerCase() 和
toLocaleUpperCase() 方法旨在基于特定地区实现。在很多地
区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳
其语），Unicode大小写转换需应用特殊规则，要使用地区特定的方法
才能实现正确转换。下面是几个例子：
let stringValue = "hello world";
console.log(stringValue.toLocaleUpperCase()); //
"HELLO WORLD"
console.log(stringValue.toUpperCase()); //
"HELLO WORLD"
console.log(stringValue.toLocaleLowerCase()); //
"hello world"
console.log(stringValue.toLowerCase()); //
"hello world"
这里， toLowerCase() 和 toLocaleLowerCase() 都返回
hello world ，而 toUpperCase() 和
toLocaleUpperCase() 都返回 HELLO WORLD 。通常，如果不知
道代码涉及什么语言，则最好使用地区特定的转换方法。
11. 字符串模式匹配方法
String 类型专门为在字符串中实现模式匹配设计了几个方法。第一
个就是 match() 方法，这个方法本质上跟 RegExp 对象的 exec()
方法相同。 match() 方法接收一个参数，可以是一个正则表达式字符
串，也可以是一个 RegExp 对象。

12. localeCompare() 方法
最后一个方法是 localeCompare() ，这个方法比较两个字符串，返
回如下3个值中的一个。
如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负
值。（通常是 -1 ，具体还要看与实际值相关的实现。）
如果字符串与字符串参数相等，则返回 0 。
如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正
值。（通常是 1 ，具体还要看与实际值相关的实现。）
13. HTML方法
早期的浏览器开发商认为使用JavaScript动态生成HTML标签是一个需
求。因此，早期浏览器扩展了规范，增加了辅助生成HTML标签的方
法。下表总结了这些HTML方法。不过，这些方法基本上已经没有人使
用了，因为结果通常不是语义化的标记。

58、单例内置对象
ECMA-262对内置对象的定义是“任何由ECMAScript实现提供、与宿主
环境无关，并在ECMAScript程序开始执行时就存在的对象”。这就意味着，
开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已
经接触了大部分内置对象，包括 Object 、 Array 和 String 。本节介
绍ECMA-262定义的另外两个单例内置对象： Global 和 Math 。
59、Global
Global 对象是ECMAScript中最特别的对象，因为代码不会显式地访
问它。ECMA-262规定 Global 对象为一种兜底对象，它所针对的是不属于
任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在
全局作用域中定义的变量和函数都会变成 Global 对象的属性 。本书前面
介绍的函数，包括 isNaN() 、 isFinite() 、 parseInt() 和
parseFloat() ，实际上都是 Global 对象的方法。除了这些，
Global 对象上还有另外一些方法。
1. URL编码方法
encodeURI() 和 encodeURIComponent() 方法用于编码统一资
源标识符（URI），以便传给浏览器。有效的URI不能包含某些字符，比如空格。使用URI编码方法来编码URI可以让浏览器能够理解它们，
同时又以特殊的UTF-8编码替换掉所有无效字符。
ecnodeURI() 方法用于对整个URI进行编码，比
如 "www.wrox.com/illegal value.js" 。而
encodeURIComponent() 方法用于编码URI中单独的组件，比如前
面URL中的 "illegal value.js" 。这两个方法的主要区别是，
encodeURI() 不会编码属于URL组件的特殊字符，比如冒号、斜
杠、问号、井号，而 encodeURIComponent() 会编码它发现的所有
非标准字符
2. eval() 方法
最后一个方法可能是整个ECMAScript语言中最强大的了，它就是
eval() 。这个方法就是一个完整的ECMAScript解释器，它接收一个
参数，即一个要执行的ECMAScript（JavaScript）字符串。来看一个例
子：
eval("console.log('hi')");
上面这行代码的功能与下一行等价：
console.log("hi");
当解释器发现 eval() 调用时，会将参数解释为实际的ECMAScript语
句，然后将其插入到该位置。通过 eval() 执行的代码属于该调用所
在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定
义在包含上下文中的变量可以在 eval() 调用内部被引用
3. Global 对象属性
Global 对象有很多属性，其中一些前面已经提到过了。像
undefined 、 NaN 和 Infinity 等特殊值都是 Global 对象的属
性。此外，所有原生引用类型构造函数，比如 Object 和
Function ，也都是 Global 对象的属性。下表列出了所有这些属
性。

4. window 对象
虽然ECMA-262没有规定直接访问 Global 对象的方式，但浏览器将
window 对象实现为 Global 对象的代理。因此，所有全局作用域中
声明的变量和函数都变成了 window 的属性。
60、Math
ECMAScript提供了 Math 对象作为保存数学公式、信息和计算的地
方。 Math 对象提供了一些辅助计算的属性和方法。
1. Math 对象属性
Math 对象有一些属性，主要用于保存数学中的一些特殊值。下表列
出了这些属性。

2. min() 和 max() 方法
Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。
min() 和 max() 方法用于确定一组数值中的最小值和最大值。这两
个方法都接收任意多个参数
3. 舍入方法
接下来是用于把小数值舍入为整数的4个方法： Math.ceil() 、
Math.floor() 、 Math.round() 和 Math.fround() 。这几个
方法处理舍入的方式如下所述。
Math.ceil() 方法始终向上舍入为最接近的整数。
Math.floor() 方法始终向下舍入为最接近的整数。
Math.round() 方法执行四舍五入。
Math.fround() 方法返回数值最接近的单精度（32位）浮点值
表示
4. random() 方法
Math.random() 方法返回一个0~1范围内的随机数，其中包含0但不
包含1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方
便的。可以基于如下公式使用 Math.random() 从一组整数中随机选
择一个数
5. 其他方法
Math 对象还有很多涉及各种简单或高阶数运算的方法。讨论每种方
法的具体细节或者它们的适用场景超出了本书的范畴。不过，下表还是
总结了 Math 对象的其他方法

61、Object
到目前为止，大多数引用值的示例使用的是 Object 类型。
Object 是ECMAScript中最常用的类型之一。虽然 Object 的实例没有
多少功能，但很适合存储和在应用程序间交换数据。
显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符
和 Object 构造函数，如下所示：
let person = new Object();
person.name = "Nicholas";
person.age = 29;
另一种方式是使用对象字面量（object literal）表示法。对象字面量是
对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。比
如，下面的代码定义了与前面示例相同的 person 对象，但使用的是对象
字面量表示法：
let person = {
name: "Nicholas",
age: 29
}
62、Array
除了 Object ， Array 应该就是ECMAScript中最常用的类型了。
ECMAScript数组跟其他编程语言的数组有很大区别。跟其他语言中的数组
一样，ECMAScript数组也是一组有序的数据，但跟其他语言不同的是，数
组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它
的第一个元素是字符串，第二个元素是数值，第三个是对象。ECMAScript
数组也是动态大小的，会随着数据添加而自动增长。
63、创建数组
有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比
如：
let colors = new Array();
如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然
后 length 属性就会被自动创建并设置为这个值。比如，下面的代码会创
建一个初始 length 为20的数组：
let colors = new Array(20);
也可以给 Array 构造函数传入要保存的元素。比如，下面的代码会
创建一个包含3个字符串值的数组：
let colors = new Array("red", "blue", "green");
64、数组空位
使用数组字面量初始化数组时，可以使用一串逗号来创建空位
（hole）。ECMAScript会将逗号之间相应索引位置的值当成空位，ES6规
范重新定义了该如何处理这些空位。
可以像下面这样创建一个空位数组：
const options = [,,,,,]; // 创建包含5个元素的数组
console.log(options.length); // 5console.log(options); // [,,,,,]
65、数组索引
要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，
如下所示：
let colors = ["red", "blue", "green"]; // 定义一个字
符串数组
alert(colors[0]); // 显示第一项colors[2] = "black"; // 修改第三项
colors[3] = "brown"; // 添加第四项
在中括号中提供的索引表示要访问的值。如果索引小于数组包含的元
素数，则返回存储在相应位置的元素，就像示例中 colors[0] 显
示 "red" 一样。设置数组的值方法也是一样的，就是替换指定位置的
值。如果把一个值设置给超过数组最大索引的索引，就像示例中的
colors[3] ，则数组长度会自动扩展到该索引值加1（示例中设置的索
引3，所以数组长度变成了4）。
66、检测数组
一个经典的ECMAScript问题是判断一个对象是不是数组。在只有一个
网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符
就足矣：
if (value instanceof Array){
// 操作数组
}
67、迭代器方法
在ES6中， Array 的原型上暴露了3个用于检索数组内容的方法：
keys() 、 values() 和 entries() 。 keys() 返回数组索引的迭
代器， values() 返回数组元素的迭代器，而 entries() 返回索引/值
对的迭代器：
const a = ["foo", "bar", "baz", "qux"];
// 因为这些方法都返回迭代器，所以可以将它们的内容
// 通过Array.from()直接转换为数组实例
const aKeys = Array.from(a.keys());
const aValues = Array.from(a.values());
const aEntries = Array.from(a.entries());
console.log(aKeys); // [0, 1, 2, 3]
console.log(aValues); // ["foo", "bar", "baz",
"qux"]
console.log(aEntries); // [[0, "foo"], [1, "bar"],
[2, "baz"], [3, "qux"]]
68、复制和填充方法
ES6新增了两个方法：批量复制方法 fill() ，以及填充数组方法
copyWithin() 。这两个方法的函数签名类似，都需要指定既有数组实
例上的一个范围，包含开始索引，不包含结束索引。使用这个方法创建的
数组不能缩放。
使用 fill() 方法可以向一个已有的数组中插入全部或部分相同的
值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索
引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负
索引想象成数组长度加上它得到的一个正索引：
const zeroes = [0, 0, 0, 0, 0];
// 用5填充整个数组
zeroes.fill(5);
console.log(zeroes); // [5, 5, 5, 5, 5]
zeroes.fill(0); // 重置// 用6填充索引大于等于3的元素
zeroes.fill(6, 3);
console.log(zeroes); // [0, 0, 0, 6, 6]
zeroes.fill(0); // 重置
// 用7填充索引大于等于1且小于3的元素
zeroes.fill(7, 1, 3);
console.log(zeroes); // [0, 7, 7, 0, 0];
zeroes.fill(0); // 重置
// 用8填充索引大于等于1且小于4的元素
// (-4 + zeroes.length = 1)
// (-1 + zeroes.length = 4)
zeroes.fill(8, -4, -1);
console.log(zeroes); // [0, 8, 8, 8, 0];
69、转换方法
前面提到过，所有对象都有 toLocaleString() 、 toString()
和 valueOf() 方法。其中， valueOf() 返回的还是数组本身。而
toString() 返回由数组中每个值的等效字符串拼接而成的一个逗号分
隔的字符串。也就是说，对数组的每个值都会调用其 toString() 方
法，以得到最终的字符串。来看下面的例子：
let colors = ["red", "blue", "green"]; // 创建一个包含
3个字符串的数组
alert(colors.toString()); // red,blue,green
alert(colors.valueOf()); // red,blue,green
alert(colors); // red,blue,green
70、栈方法
ECMAScript给数组提供几个方法，让它看起来像是另外一种数据结
构。数组对象可以像栈一样，也就是一种限制插入和删除项的数据结构。
栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就是最近添加的
项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）
只在栈的一个地方发生，即栈顶。ECMAScript数组提供了 push() 和
pop() 方法，以实现类似栈的行为。
push() 方法接收任意数量的参数，并将它们添加到数组末尾，返回
数组的最新长度。 pop() 方法则用于删除数组的最后一项，同时减少数
组的 length 值，返回被删除的项。
71、队列方法
就像栈是以LIFO形式限制访问的数据结构一样，队列以先进先出
（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但
从列表开头获取数据。因为有了在数据末尾添加数据的 push() 方法，所
以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫
shift() ，它会删除数组的第一项并返回它，然后数组长度减1。使用
shift() 和 push() ，可以把数组当成队列来使用：
let colors = new Array(); // 创建一个
数组
let count = colors.push("red", "green"); // 推入两项
alert(count); // 2
count = colors.push("black"); // 再推入一项
alert(count); // 3
let item = colors.shift(); // 取得第一项alert(item); // red
alert(colors.length); /
72、排序方法
数组有两个方法可以用来对元素重新排序： reverse() 和
sort() 。顾名思义， reverse() 方法就是将数组元素反向排列。比
如：
let values = [1, 2, 3, 4, 5];
values.reverse();
alert(values); // 5,4,3,2,1
这里，数组 values 的初始状态为 [1,2,3,4,5] 。通过调用
reverse() 反向排序，得到了 [5,4,3,2,1] 。这个方法很直观，但
不够灵活，所以才有了 sort() 方法。
73、操作方法
对于数组中的元素，我们有很多操作方法。比如， concat() 方法
可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前
数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的
数组。如果传入一个或多个数组，则 concat() 会把这些数组的每一项
都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末
尾。
let colors = ["red", "green", "blue"];
let colors2 = colors.concat("yellow", ["black",
"brown"]);
console.log(colors); // ["red", "green","blue"]
console.log(colors2); // ["red", "green", "blue",
"yellow", "black", "brown"]
这里先创建一个包含3个值的数组 colors 。然后 colors 调用
concat() 方法，传入字符串 "yellow" 和一个包
含 "black" 和 "brown" 的数组。保存在 colors2 中的结果就是
["red", "green", "blue", "yellow", "black",
"brown"] 。原始数组 colors 保持不变。
打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的
符号： Symbol.isConcatSpreadable 。这个符号能够阻止
concat() 打平参数数组。相反，把这个值设置为 true 可以强制打平
类数组对象：
let colors = ["red", "green", "blue"];
let newColors = ["black", "brown"];
let moreNewColors = {
[Symbol.isConcatSpreadable]: true,
length: 2,0: "pink",
1: "cyan"
};
newColors[Symbol.isConcatSpreadable] = false;
// 强制不打平数组
let colors2 = colors.concat("yellow", newColors);
// 强制打平类数组对象
let colors3 = colors.concat(moreNewColors);
console.log(colors); // ["red", "green", "blue"]
console.log(colors2); // ["red", "green", "blue",
"yellow", ["black", "brown"]]
console.log(colors3); // ["red", "green", "blue",
"pink", "cyan"]
或许最强大的数组方法就属 splice() 了，使用它的方式可以有很
多种。 splice() 的主要目的是在数组中间插入元素，但有 3 种不同的
方式使用这个方法。
删除。需要给 splice() 传2个参数：要删除的第一个元素的位置和
要删除的元素数量。可以从数组中删除任意多个元素，比如
splice(0, 2) 会删除前两个元素。
插入。需要给 splice() 传3个参数：开始位置、0（要删除的元素
数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个
参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元
素。比如， splice(2, 0, "red", "green") 会从数组位置2开
始插入字符串 "red" 和 "green" 。
替换。 splice() 在删除元素的同时可以在指定位置插入新元素，
同样要传入3个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，
splice(2, 1, "red", "green") 会在位置2删除一个元素，然
后从该位置开始向数组中插入 "red" 和 "green" 。
74、搜索和位置方法
ECMAScript提供两类搜索数组的方法：按严格相等搜索和按断言函数
搜索。
1. 严格相等
ECMAScript提供了3个严格相等的搜索方法： indexOf() 、
lastIndexOf() 和 includes() 。其中，前两个方法在所有版本
中都可用，而第三个方法是ECMAScript 7新增的。这些方法都接收两
个参数：要查找的元素和一个可选的起始搜索位置。 indexOf()
和 includes() 方法从数组前头（第一项）开始向后搜索，而
lastIndexOf() 从数组末尾（最后一项）开始向前搜索。
indexOf() 和 lastIndexOf() 都返回要查找的元素在数组中的
位置，如果没找到则返回-1。 includes() 返回布尔值，表示是否
至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项
时，会使用全等（ === ）比较，也就是说两项必须严格相等。下面
来看一些例子：
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
alert(numbers.indexOf(4)); // 3
alert(numbers.lastIndexOf(4)); // 5
alert(numbers.includes(4)); // truealert(numbers.indexOf(4, 4)); // 5
alert(numbers.lastIndexOf(4, 4)); // 3
alert(numbers.includes(4, 7)); // false
let person = { name: "Nicholas" };
let people = [{ name: "Nicholas" }];
let morePeople = [person];
alert(people.indexOf(person)); // -1
alert(morePeople.indexOf(person)); // 0
alert(people.includes(person)); // false
alert(morePeople.includes(person)); // true
2. 断言函数
ECMAScript也允许按照定义的断言函数搜索数组，每个索引都会调用
这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹
配。
断言函数接收3个参数：元素、索引和数组本身。其中元素是数组中
当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数
组。断言函数返回真值，表示是否匹配。
find() 和 findIndex() 方法使用了断言函数。这两个方法都从
数组的最小索引开始。 find() 返回第一个匹配的元素，
findIndex() 返回第一个匹配元素的索引。这两个方法也都接收第
二个可选的参数，用于指定断言函数内部 this 的值。
75、迭代方法
ECMAScript为数组定义了5个迭代方法。每个方法接收两个参数：以
每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象
（影响函数中 this 的值）。传给每个方法的函数接收3个参数：数组元
素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会
也可能不会影响方法的返回值。数组的5个迭代方法如下。
every() ：对数组每一项都运行传入的函数，如果对每一项函数都
返回 true ，则这个方法返回 true 。
filter() ：对数组每一项都运行传入的函数，函数返回 true 的
项会组成数组之后返回。
forEach() ：对数组每一项都运行传入的函数，没有返回值。
map() ：对数组每一项都运行传入的函数，返回由每次函数调用的
结果构成的数组。
some() ：对数组每一项都运行传入的函数，如果有一项函数返回
true ，则这个方法返回 true 。
这些方法都不改变调用它们的数组。
在这些方法中， every() 和 some() 是最相似的，都是从数组中搜
索符合某个条件的元素。对 every() 来说，传入的函数必须对每一项都
返回 true ，它才会返回 true ；否则，它就返回 false 。而对
some() 来说，只要有一项让传入的函数返回 true ，它就会返回
true 。
76、归并方法
ECMAScript为数组提供了两个归并方法： reduce() 和
reduceRight() 。这两个方法都会迭代数组的所有项，并在此基础上
构建一个最终返回值。 reduce() 方法从数组第一项开始遍历到最后一
项。而 reduceRight() 从最后一项开始遍历至第一项。
这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可
选的以之为归并起点的初始值。传给 reduce() 和 reduceRight() 的
函数接收4个参数：上一个归并值、当前项、当前项的索引和数组本身。
这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如
果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的
第一项，第二个参数是数组的第二项
77、定型数组
定型数组（typed array）是ECMAScript新增的结构，目的是提升向原
生库传输数据的效率。实际上，JavaScript并没有“TypedArray”类型，它所
指的其实是一种特殊的包含数值类型的数组。为理解如何使用定型数组，
有必要先了解一下它的用途。
78、历史
随着浏览器的流行，不难想象人们会满怀期待地通过它来运行复杂的
3D应用程序。早在2006年，Mozilla、Opera等浏览器提供商就实验性地在
浏览器中增加了用于渲染复杂图形应用程序的编程平台，无须安装任何插
件。其目标是开发一套JavaScript API，从而充分利用3D图形API和GPU加
速，以便在 <canvas> 元素上渲染复杂的图形。
1. WebGL
最后的JavaScript API是基于OpenGL ES（OpenGL for Embedded
Systems）2.0规范的。OpenGL ES是OpenGL专注于2D和3D计算机图形
的子集。这个新API被命名为WebGL（Web Grapics Library），于2011
年发布1.0版。有了它，开发者就能够编写涉及复杂图形的应用程序，
它会被兼容WebGL的浏览器原生解释执行。
在WebGL的早期版本中，因为JavaScript数组与原生数组之间不匹配，
所以出现了性能问题。图形驱动程序API通常不需要以JavaScript默认
双精度浮点格式传递给它们的数值，而这恰恰是JavaScript数组在内存
中的格式。因此，每次WebGL与JavaScript运行时之间传递数组时，
WebGL绑定都需要在目标环境分配新数组，以其当前格式迭代数组，
然后将数值转型为新数组中的适当格式，而这些要花费很多时间。
2. 定型数组
这当然是难以接受的，Mozilla为解决这个问题而实现了
CanvasFloatArray 。这是一个提供JavaScript接口的、C语言风格
的浮点值数组。JavaScript运行时使用这个类型可以分配、读取和写入
数组。这个数组可以直接传给底层图形驱动程序API，也可以直接从底层获取到。最终， CanvasFloatArray 变成了
Float32Array ，也就是今天定型数组中可用的第一个“类型”。
79、ArrayBuffer
Float32Array 实际上是一种“视图”，可以允许JavaScript运行时访
问一块名为 ArrayBuffer 的预分配内存。 ArrayBuffer 是所有定型
数组及视图引用的基本单位。
ArrayBuffer 某种程度上类似于C++的 malloc() ，但也有几个
明显的区别。
malloc() 在分配失败时会返回一个 null 指针。 ArrayBuffer
在分配失败时会抛出错误。malloc() 可以利用虚拟内存，因此最大可分配尺寸只受可寻址系
统内存限制。 ArrayBuffer 分配的内存不能超过
Number.MAX_SAFE_INTEGER （）字节。
malloc() 调用成功不会初始化实际的地址。声明 ArrayBuffer
则会将所有二进制位初始化为0。
通过 malloc() 分配的堆内存除非调用 free() 或程序退出，否则
系统不能再使用。而通过声明 ArrayBuffer 分配的堆内存可以被当
成垃圾回收，不用手动释放。
不能仅通过对 ArrayBuffer 的引用就读取或写入其内容。要读取或
写入 ArrayBuffer ，就必须通过视图。视图有不同的类型，但引用的都
是 ArrayBuffer 中存储的二进制数据。
80、DataView
第一种允许你读写 ArrayBuffer 的视图是 DataView 。这个视图
专为文件I/O和网络I/O设计，其API支持对缓冲数据的高度控制，但相比于
其他类型的视图性能也差一些。 DataView 对缓冲内容没有任何预设，
也不能迭代。
必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView
实例。这个实例可以使用全部或部分 ArrayBuffer ，且维护着对该缓冲
实例的引用，以及视图在缓冲中开始的位置。
要通过 DataView 读取缓冲，还需要几个组件。
• 首先是要读或写的字节偏移量。可以看成 DataView 中的某种“地
址”。
• DataView 应该使用 ElementType 来实现JavaScript的 Number
类型到缓冲内二进制格式的转换。
• 最后是内存中值的字节序。默认为大端字节序。
1. ElementType
DataView 对存储在缓冲内的数据类型没有预设。它暴露的API强制
开发者在读、写时指定一个 ElementType ，然后 DataView 就会
忠实地为读、写而完成相应的转换。
ECMAScript 6支持8种不同的 ElementType （见下表）。



2. 字节序前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系
统维护的一种字节顺序的约定。 DataView 只支持两种约定：大端
字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高
有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端
字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存
在最后一个字节。
JavaScript运行时所在系统的原生字节序决定了如何读取或写入字节，
但 DataView 并不遵守这个约定。对一段内存而言， DataView 是
一个中立接口，它会遵循你指定的字节序。 DataView 的所有API方
法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置
为 true 即可启用小端字节序。
3. 边界情形
DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就
会抛出 RangeError ：
const buf = new ArrayBuffer(6);
const view = new DataView(buf);// 尝试读取部分超出缓冲范围的值
view.getInt32(4);
// RangeError
// 尝试读取超出缓冲范围的值
view.getInt32(8);
// RangeError
// 尝试读取超出缓冲范围的值
view.getInt32(-1);
// RangeError
// 尝试写入超出缓冲范围的值
view.setInt32(4, 123);
// RangeError
81、定型数组
定型数组是另一种形式的 ArrayBuffer 视图。虽然概念上与
DataView 接近，但定型数组的区别在于，它特定于一种
ElementType 且遵循系统原生的字节序。相应地，定型数组提供了适用
面更广的API和更高的性能。设计定型数组的目的就是提高与WebGL等原
生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言
是一种容易使用的格式，JavaScript引擎可以重度优化算术运算、按位运算
和其他对定型数组的常见操作，因此使用它们速度极快。
创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭
代结构，以及填充基于任意类型的定型数组。另外，通过
<ElementType>.from() 和 <ElementType>.of() 也可以创建定型
数组
1. 定型数组行为
从很多方面看，定型数组与普通数组都很相似。定型数组支持如下操
作符、方法和属性：
[]
copyWithin()
entries()
every()
fill()
filter()
find()findIndex()
forEach()
indexOf()
join()
keys()
lastIndexOf()
length
map()
reduce()
reduceRight()
reverse()
slice()
some()
sort()
toLocaleString()
toString()
values()
其中，返回新数组的方法也会返回包含同样元素类型（element type）
的新定型数组
2. 合并、复制和修改定型数组
定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。
因此，下列方法不适用于定型数组：
concat()
pop()
push()
shift()
splice()
unshift()
不过，定型数组也提供了两个新方法，可以快速向外或向内复制数
据： set() 和 subarray() 。
set() 从提供的数组或定型数组中把值复制到当前定型数组中指定
的索引位置：
3. 下溢和上溢
定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数
组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受
一个相关位，而不考虑它们对实际数值的影响。以下代码演示了如何
处理下溢和上溢：
82、Map
ECMAScript 6以前，在JavaScript中实现“键/值”式存储可以使用
Object 来方便高效地完成，也就是使用对象属性作为键，再使用属性来
引用值。但这种实现并非没有问题，为此TC39委员会专门为“键/值”存储定
义了一个规范。
作为ECMAScript 6的新增特性， Map 是一种新的集合类型，为这门
语言带来了真正的键/值存储机制。 Map 的大多数特性都可以通过Object 类型实现，但二者之间还是存在一些细微的差异。具体实践中使
用哪一个，还是值得细细甄别。
83、基本API
使用 new 关键字和 Map 构造函数可以创建一个空映射：
const m = new Map();
如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可
迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照
迭代顺序插入到新映射实例中：
84、顺序与迭代
与 Object 类型的一个主要差异是， Map 实例会维护键值对的插入
顺序，因此可以根据插入顺序执行迭代操作。
映射实例可以提供一个迭代器（ Iterator ），能以插入顺序生成
[key, value] 形式的数组。可以通过 entries() 方法（或者
Symbol.iterator 属性，它引用 entries() ）取得这个迭代器
85、选择 Object 还是 Map
对于多数Web开发任务来说，选择 Object 还是 Map 只是个人偏好
问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射
之间确实存在显著的差别。
1. 内存占用
Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存
储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加
或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。不同
浏览器的情况不同，但给定固定大小的内存， Map 大约可以比
Object 多存储50%的键/值对。
2. 插入性能
向 Object 和 Map 中插入新键/值对的消耗大致相当，不过插入
Map 在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插
入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操
作，那么显然 Map 的性能更佳。
3. 查找速度
与插入不同，从大型 Object 和 Map 中查找键/值对的性能差异极
小，但如果只包含少量键/值对，则 Object 有时候速度更快。在把
Object 当成数组使用的情况下（比如使用连续整数作为属性），浏
览器引擎可以进行优化，在内存中使用更高效的布局。这对 Map 来
说是不可能的。对这两个类型而言，查找速度不会随着键/值对数量增
加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选
择 Object 更好一些。4. 删除性能
使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在
很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，
包括把属性值设置为 undefined 或 null 。但很多时候，这都是一
种讨厌的或不适宜的折中。而对大多数浏览器引擎来说， Map 的
delete() 操作都比插入和查找更快。如果代码涉及大量删除操
作，那么毫无疑问应该选择 Map 。
86、WeakMap
ECMAScript 6新增的“弱映射”（ WeakMap ）是一种新的集合类型，
为这门语言带来了增强的键/值对存储机制。 WeakMap 是 Map 的“兄
弟”类型，其API也是 Map 的子集。 WeakMap 中的“weak”（弱），描述
的是JavaScript垃圾回收程序对待“弱映射”中键的方式。
87、基本API
可以使用 new 关键字实例化一个空的 WeakMap ：
const wm = new WeakMap();
弱映射中的键只能是 Object 或者继承自 Object 的类型，尝试使
用非对象设置键会抛出 TypeError 。值的类型没有限制。
如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对
象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代
顺序插入新实例中：
88、弱键
WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，
这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中
值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射
中，并被当作对值的引用，因此就不会被当作垃圾回收。
来看下面的例子：
const wm = new WeakMap();
wm.set({}, "val");
set() 方法初始化了一个新对象并将它用作一个字符串的键。因为
没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键
就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失了，使其成为
一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏
以后，值本身也会成为垃圾回收的目标。
89、不可迭代键
因为 WeakMap 中的键/值对任何时候都可能被销毁，所以没必要提供
迭代其键/值对的能力。当然，也用不着像 clear() 这样一次性销毁所有
键/值的方法。 WeakMap 确实没有这个方法。因为不可能迭代，所以也
不可能在不知道对象引用的情况下从弱映射中取得值。即便代码可以访问
WeakMap 实例，也没办法看到其中的内容。
WeakMap 实例之所以限制只能用对象作为键，是为了保证只有通过
键对象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使
用的字符串字面量和初始化之后使用的一个相等的字符串了。
90、使用弱映射
WeakMap 实例与现有JavaScript对象有着很大不同，可能一时不容易
说清楚应该怎么使用它。这个问题没有唯一的答案，但已经出现了很多相
关策略。
1. 私有变量
弱映射造就了在JavaScript中实现真正私有变量的一种新方式。前提很
明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的
字典为值。
下面是一个示例实现：const wm = new WeakMap();
class User {
constructor(id) {
this.idProperty = Symbol('id');
this.setId(id);
}
setPrivate(property, value) {
const privateMembers = wm.get(this) || {};
privateMembers[property] = value;
wm.set(this, privateMembers);
}
getPrivate(property) {
return wm.get(this)[property];
}
setId(id) {
this.setPrivate(this.idProperty, id);
}
getId() {
return this.getPrivate(this.idProperty);
}
}
const user = new User(123);
alert(user.getId()); // 123
user.setId(456);alert(user.getId()); // 456
// 并不是真正私有的
alert(wm.get(user)[user.idProperty]); // 456
2. DOM节点元数据
因为 WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数
据。来看下面这个例子，其中使用了常规的 Map ：
const m = new Map();
const loginButton =
document.querySelector('#login');
// 给这个节点关联一些元数据
m.set(loginButton, {disabled: true});假设在上面的代码执行后，页面被JavaScript改变了，原来的登录按钮
从DOM树中被删掉了。但由于映射中还保存着按钮的引用，所以对应
的DOM节点仍然会逗留在内存中，除非明确将其从映射中删除或者等
到映射本身被销毁。
91、Set
ECMAScript 6新增的 Set 是一种新集合类型，为这门语言带来集合
数据结构。 Set 在很多方面都像是加强的 Map ，这是因为它们的大多数
API和行为都是共有的。
92、基本API
使用 new 关键字和 Set 构造函数可以创建一个空集合：
const m = new Set();
如果想在创建的同时初始化实例，则可以给 Set 构造函数传入一个
可迭代对象，其中需要包含插入到新集合实例中的元素：
93、顺序与迭代
Set 会维护值插入时的顺序，因此支持按顺序迭代。
集合实例可以提供一个迭代器（ Iterator ），能以插入顺序生成
集合内容。可以通过 values() 方法及其别名方法 keys() （或者
Symbol.iterator 属性，它引用 values() ）取得这个迭代器
94、定义正式集合操作
从各方面来看， Set 跟 Map 都很相似，只是API稍有调整。唯一需
要强调的就是集合的API只支持自引用操作。很多开发者都喜欢使用 Set
操作，但需要手动实现：或者是子类化 Set ，或者是定义一个实用函数
库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方
法中使用这些静态方法。在实现这些操作时，需要考虑几个地方。
某些 Set 操作是有关联性的，因此最好让实现的方法能支持处理任
意多个集合实例。
Set 保留插入顺序，所有方法返回的集合必须保证顺序。
尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集
合和数组间的相互转换能够节省对象初始化成本。
不要修改已有的集合实例。 union(a, b) 或 a.union(b) 应该返
回包含结果的新集合实例。
class XSet extends Set {
union(...sets) {
return XSet.union(this, ...sets)
}
intersection(...sets) {
return XSet.intersection(this, ...sets);
}
difference(set) {
return XSet.difference(this, set);
}
symmetricDifference(set) {return XSet.symmetricDifference(this, set);
}
cartesianProduct(set) {
return XSet.cartesianProduct(this, set);
}
powerSet() {
return XSet.powerSet(this);
}
// 返回两个或更多集合的并集
static union(a, ...bSets) {
const unionSet = new XSet(a);
for (const b of bSets) {
for (const bValue of b) {
unionSet.add(bValue);
}
}
return unionSet;
}
// 返回两个或更多集合的交集
static intersection(a, ...bSets) {
const intersectionSet = new XSet(a);
for (const aValue of intersectionSet) {
for (const b of bSets) {
if (!b.has(aValue)) {
intersectionSet.delete(aValue);
}}
}
return intersectionSet;
}
// 返回两个集合的差集
static difference(a, b) {
const differenceSet = new XSet(a);
for (const bValue of b) {
if (a.has(bValue)) {
differenceSet.delete(bValue);
}
}
return differenceSet;
}
// 返回两个集合的对称差集
static symmetricDifference(a, b) {
// 按照定义，对称差集可以表达为
return a.union(b).difference(a.intersection(b));
}
// 返回两个集合（数组对形式）的笛卡儿积
// 必须返回数组集合，因为笛卡儿积可能包含相同值的对
static cartesianProduct(a, b) {
const cartesianProductSet = new XSet();
for (const aValue of a) {
for (const bValue of b) {
cartesianProductSet.add([aValue, bValue]);
}}
return cartesianProductSet;
}
// 返回一个集合的幂集
static powerSet(a) {
const powerSet = new XSet().add(new XSet());
for (const aValue of a) {
for (const set of new XSet(powerSet)) {
powerSet.add(new XSet(set).add(aValue));
}
}
return powerSet;
}
}
95、WeakSet
ECMAScript 6新增的“弱集合”（ WeakSet ）是一种新的集合类型，
为这门语言带来了集合数据结构。 WeakSet 是 Set 的“兄弟”类型，其
API也是 Set 的子集。 WeakSet 中的“weak”（弱），描述的是JavaScript
垃圾回收程序对待“弱集合”中值的方式。
96、基本API
可以使用 new 关键字实例化一个空的 WeakSet ：
const ws = new WeakSet();
弱集合中的值只能是 Object 或者继承自 Object 的类型，尝试使
用非对象设置值会抛出 TypeError 。如果想在初始化时填充弱集合，则构造函数可以接收一个可迭代对
象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插
入到新实例中
97、弱值
WeakSet 中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，
这些值不属于正式的引用，不会阻止垃圾回收。
来看下面的例子：
const ws = new WeakSet();
ws.add({});
add() 方法初始化了一个新对象，并将它用作一个值。因为没有指
向这个对象的其他引用，所以当这行代码执行完成后，这个对象值就会被
当作垃圾回收。然后，这个值就从弱集合中消失了，使其成为一个空集
合。
98、不可迭代值
因为 WeakSet 中的值任何时候都可能被销毁，所以没必要提供迭代
其值的能力。当然，也用不着像 clear() 这样一次性销毁所有值的方
法。 WeakSet 确实没有这个方法。因为不可能迭代，所以也不可能在不
知道对象引用的情况下从弱集合中取得值。即便代码可以访问 WeakSet
实例，也没办法看到其中的内容。
WeakSet 之所以限制只能用对象作为值，是为了保证只有通过值对
象的引用才能取得值。如果允许原始值，那就没办法区分初始化时使用的
字符串字面量和初始化之后使用的一个相等的字符串了。
99、使用弱集合
相比于 WeakMap 实例， WeakSet 实例的用处没有那么大。不过，
弱集合在给对象打标签时还是有价值的。
来看下面的例子，这里使用了一个普通 Set ：
const disabledElements = new Set();
const loginButton =
document.querySelector('#login');
// 通过加入对应集合，给这个节点打上“禁用”标签
disabledElements.add(loginButton);
这样，通过查询元素在不在 disabledElements 中，就可以知道它
是不是被禁用了。不过，假如元素从DOM树中被删除了，它的引用却仍然保存在 Set 中，因此垃圾回收程序也不能回收它
100、迭代与扩展操作
ECMAScript 6新增的迭代器和扩展操作符对集合引用类型特别有用。
这些新特性让集合类型之间相互操作、复制和修改变得异常方便。
注意 第7章会更详细地介绍迭代器和生成器。
如本章前面所示，有4种原生集合类型定义了默认迭代器：
Array
所有定型数组
Map
Set
很简单，这意味着上述所有类型都支持顺序迭代，都可以传入 for-
of 循环
101、小结
JavaScript中的对象是引用值，可以通过几种内置引用类型创建特定类
型的对象。
引用类型与传统面向对象编程语言中的类相似，但实现不同。
Object 类型是一个基础类型，所有引用类型都从它继承了基本的行
为。
Array 类型表示一组有序的值，并提供了操作和转换值的能力。定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。
Date 类型提供了关于日期和时间的信息，包括当前日期和时间以及
计算。
RegExp 类型是ECMAScript支持的正则表达式的接口，提供了大多
数基本正则表达式以及一些高级正则表达式的能力。
JavaScript比较独特的一点是，函数其实是 Function 类型的实例，
这意味着函数也是对象。由于函数是对象，因此也就具有能够增强自身行
为的方法。
因为原始值包装类型的存在，所以JavaScript中的原始值可以拥有类似
对象的行为。有3种原始值包装类型： Boolean 、 Number 和
String 。它们都具有如下特点。
每种包装类型都映射到同名的原始类型。
在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过
这个对象可以操作数据。
涉及原始值的语句只要一执行完毕，包装对象就会立即销毁。
JavaScript还有两个在一开始执行代码时就存在的内置对象：
Global 和 Math 。其中， Global 对象可以在大多数ECMAScript实现
中访问。不过浏览器将 Global 实现为 window 对象。所有全局变量和
函数都是 Global 对象的属性。 Math 对象包含辅助完成复杂数学计算
的属性和方法。
ECMAScript 6新增了一批引用类型： Map 、 WeakMap 、 Set 和
WeakSet 。这些类型为组织应用程序数据和简化内存管理提供了新能
力
102、迭代器与生成器
迭代的英文“iteration”源自拉丁文itero，意思是“重复”或“再来”。
在软件开发领域，“迭代”的意思是按照顺序反复多次执行一段程序，
通常会有明确的终止条件。ECMAScript 6规范新增了两个高级特性：
迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现
迭代。
103、理解迭代
在JavaScript中，计数循环就是一种最简单的迭代：
for (let i = 1; i <= 10; ++i) {
console.log(i);
}
循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及
每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完
成，而每次迭代的顺序都是事先定义好的。
迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有
项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定
义。）数组是JavaScript中有序集合的最典型例子。
因为数组有已知的长度，且数组每一项都可以通过索引获取，所
以整个数组可以通过递增索引来遍历。
由于如下原因，通过这种循环来执行例程并不理想。
迭代之前需要事先知道如何使用数据结构。数组中的每一项都只
能先通过引用取得数组对象，然后再通过 [] 操作符取得特定索
引位置上的项。这种情况并不适用于所有数据结构。
遍历顺序并不是数据结构固有的。通过递增索引来访问数据是特
定于数组类型的方式，并不适用于其他具有隐式顺序的数据结
构。
ES5新增了 Array.prototype.forEach() 方法，向通用迭代
需求迈进了一步（但仍然不够理想）：
let collection = ['foo', 'bar', 'baz'];
collection.forEach((item) => console.log(item));
// foo
// bar
// baz这个方法解决了单独记录索引和通过数组对象取得值的问题。不
过，没有办法标识迭代何时终止。因此这个方法只适用于数组，而且
回调结构也比较笨拙。
在ECMAScript较早的版本中，执行迭代必须使用循环或其他辅助
结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生
语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现迭
代操作。这个解决方案就是迭代器模式。Python、Java、C++，还有其
他很多语言都对这个模式提供了完备的支持。JavaScript在ECMAScript
6以后也支持了迭代器模式。
104、迭代器模式
迭代器模式（特别是在ECMAScript这个语境下）描述了一个方
案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现
了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。
可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解
成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，
而且都具有无歧义的遍历顺序：
// 数组的元素是有限的
// 递增索引可以按序访问每个元素
let arr = [3, 1, 4];
// 集合的元素是有限的
// 可以按插入顺序访问每个元素
let set = new Set().add(3).add(1).add(4);
不过，可迭代对象不一定是集合对象，也可以是仅仅具有类似数
组行为的其他数据结构，比如本章开头提到的计数循环。该循环中生成的值是暂时性的，但循环本身是在执行迭代。计数循环和数组都具
有可迭代对象的行为。
105、可迭代协议
实现 Iterable 接口（可迭代协议）要求同时具备两种能力：
支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能
力。在ECMAScript中，这意味着必须暴露一个属性作为“默认迭代
器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键。这
个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数
必须返回一个新迭代器。
很多内置类型都实现了 Iterable 接口：
字符串
数组
映射
集合
arguments 对象
NodeList 等DOM集合类型检查是否存在默认迭代器属性可以暴露这个工厂函数：
let num = 1;
let obj = {};
// 这两种类型没有实现迭代器工厂函数
console.log(num[Symbol.iterator]); // undefined
console.log(obj[Symbol.iterator]); // undefined
let str = 'abc';
let arr = ['a', 'b', 'c'];
let map = new Map().set('a', 1).set('b',
2).set('c', 3);
let set = new Set().add('a').add('b').add('c');
let els = document.querySelectorAll('div');
// 这些类型都实现了迭代器工厂函数
console.log(str[Symbol.iterator]); // f values()
{ [native code] }
console.log(arr[Symbol.iterator]); // f values()
{ [native code] }
console.log(map[Symbol.iterator]); // f values()
{ [native code] }
console.log(set[Symbol.iterator]); // f values()
{ [native code] }
console.log(els[Symbol.iterator]); // f values()
{ [native code] }// 调用这个工厂函数会生成一个迭代器
console.log(str[Symbol.iterator]()); //
StringIterator {}
console.log(arr[Symbol.iterator]()); //
ArrayIterator {}
console.log(map[Symbol.iterator]()); //
MapIterator {}
console.log(set[Symbol.iterator]()); //
SetIterator {}
console.log(els[Symbol.iterator]()); //
ArrayIterator {}
实际写代码过程中，不需要显式调用这个工厂函数来生成迭代
器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何
语言特性。接收可迭代对象的原生语言特性包括：
for-of 循环
数组解构
扩展操作符
Array.from()
创建集合
创建映射
Promise.all() 接收由期约组成的可迭代对象
Promise.race() 接收由期约组成的可迭代对象
yield* 操作符，在生成器中使用这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函
数，从而创建一个迭代器：
let arr = ['foo', 'bar', 'baz'];
// for-of循环
for (let el of arr) {
console.log(el);
}
// foo
// bar
// baz
// 数组解构
let [a, b, c] = arr;
console.log(a, b, c); // foo, bar, baz
// 扩展操作符
let arr2 = [...arr];
console.log(arr2); // ['foo', 'bar', 'baz']
// Array.from()
let arr3 = Array.from(arr);
console.log(arr3); // ['foo', 'bar', 'baz']
// Set构造函数
let set = new Set(arr);
console.log(set); // Set(3) {'foo', 'bar','baz'}
// Map构造函数
let pairs = arr.map((x, i) => [x, i]);
console.log(pairs); // [['foo', 0], ['bar', 1],
['baz', 2]]
let map = new Map(pairs);
console.log(map); // Map(3) { 'foo'=>0,
'bar'=>1, 'baz'=>2 }
如果对象原型链上的父类实现了 Iterable 接口，那这个对象
也就实现了这个接口：
class FooArray extends Array {}
let fooArr = new FooArray('foo', 'bar', 'baz');
for (let el of fooArr) {
console.log(el);
}
// foo
// bar
// baz
106、迭代器协议
迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对
象。迭代器API使用 next() 方法在可迭代对象中遍历数据。每次成
功调用 next() ，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next() ，则无法知道迭代器的
当前位置。
next() 方法返回的迭代器对象 IteratorReault 包含两个
属性： done 和 value 。 done 是一个布尔值，表示是否还可以再
次调用 next() 取得下一个值； value 包含可迭代对象的下一个值
（ done 为 false ），或者 undefined （ done 为 true ）。
done: true 状态称为“耗尽”。
这里通过创建迭代器并调用 next() 方法按顺序迭代了数组，直
至不再产生新值。迭代器并不知道怎么从可迭代对象中取得下一个
值，也不知道可迭代对象有多大。只要迭代器到达 done: true 状
态，后续调用 next() 就一直返回同样的值了
107、自定义迭代器
与 Iterable 接口类似，任何实现 Iterator 接口的对象都可
以作为迭代器使用。下面这个例子中的 Counter 类只能被迭代一定
的次数：
class Counter {
// Counter的实例应该迭代limit次
constructor(limit) {
this.count = 1;
this.limit = limit;
}
next() {
if (this.count <= this.limit) {
return { done: false, value: this.count++
};
} else {
return { done: true, value: undefined };
}
}
[Symbol.iterator]() {
return this;
}
}
let counter = new Counter(3);
for (let i of counter) {
console.log(i);}
// 1
// 2
// 3
108、提前终止迭代器
可选的 return() 方法用于指定在迭代器提前关闭时执行的逻
辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽
时，就可以“关闭”迭代器。可能的情况包括：
for-of 循环通过 break 、 continue 、 return 或
throw 提前退出；
解构操作并未消费所有值。
return() 方法必须返回一个有效的 IteratorResult 对
象。简单情况下，可以只返回 { done: true } 。因为这个返回值
只会用在生成器的上下文中，所以本章后面再讨论这种情况。
如下面的代码所示，内置语言结构在发现还有更多值可以迭代，
但不会消费这些值时，会自动调用 return() 方法。
109、生成器
生成器是ECMAScript 6新增的一个极为灵活的结构，拥有在一个
函数块内暂停和恢复代码执行的能力。这种新能力具有深远的影响，
比如，使用生成器可以自定义迭代器和实现协程。
110、生成器基础
生成器的形式是一个函数，函数名称前面加一个星号（ * ）表示
它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。
// 生成器函数声明
function* generatorFn() {}
// 生成器函数表达式
let generatorFn = function* () {}// 作为对象字面量方法的生成器函数
let foo = {
* generatorFn() {}
}
// 作为类实例方法的生成器函数
class Foo {
* generatorFn() {}
}
// 作为类静态方法的生成器函数
class Bar {
static * generatorFn() {}
}
110、通过 yield 中断执行
yield 关键字可以让生成器停止和开始执行，也是生成器最有
用的地方。生成器函数在遇到 yield 关键字之前会正常执行。遇到
这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行
的生成器函数只能通过在生成器对象上调用 next() 方法来恢复执
行
1. 生成器对象作为可迭代对象
在生成器对象上显式调用 next() 方法的用处并不大。其实，如
果把生成器对象当成可迭代对象，那么使用起来会更方便
在需要自定义迭代对象时，这样使用生成器对象会特别有用。比
如，我们需要定义一个可迭代对象，而它会产生一个迭代器，这
个迭代器会执行指定的次数。使用生成器，可以通过一个简单的
循环来实现
2. 使用 yield 实现输入和输出
除了可以作为函数的中间返回语句使用， yield 关键字还可以
作为函数的中间参数使用。上一次让生成器函数暂停的 yield
关键字会接收到传给 next() 方法的第一个值。这里有个地方不
太好理解——第一次调用 next() 传入的值不会被使用，因为这
一次调用是为了开始执行生成器函数
3. 产生可迭代对象
可以使用星号增强 yield 的行为，让它能够迭代一个可迭代对
象，从而一次产出一个值
yield* 的值是关联迭代器返回 done: true 时的 value 属
性。对于普通迭代器来说，这个值是 undefined
4. 使用 yield* 实现递归算法
yield* 最有用的地方是实现递归操作，此时生成器可以产生自
身。看下面的例子：function* nTimes(n) {
if (n > 0) {
yield* nTimes(n - 1);
yield n - 1;
}
}
for (const x of nTimes(3)) {
console.log(x);
}
// 0
// 1
// 2
111、生成器作为默认迭代器
因为生成器对象实现了 Iterable 接口，而且生成器函数和默
认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭
代器。下面是一个简单的例子，这个类的默认迭代器可以用一行代码
产出类的内容
112、提前终止生成器
与迭代器类似，生成器也支持“可关闭”的概念。一个实现
Iterator 接口的对象一定有 next() 方法，还有一个可选的
return() 方法用于提前终止迭代器。生成器对象除了有这两个方
法，还有第三个方法： throw() 。
return() 和 throw() 方法都可以用于强制生成器进入关闭
状态。
1. return()
return() 方法会强制生成器进入关闭状态。提供给
return() 方法的值，就是终止迭代器对象的值
2. throw()
throw() 方法会在暂停的时候将一个提供的错误注入到生成器
对象中。如果错误未被处理，生成器就会关闭
113、小结
迭代是一种所有编程语言中都可以看到的模式。ECMAScript 6正
式支持迭代模式并引入了两个新的语言特性：迭代器和生成器。
迭代器是一个可以由任意对象实现的接口，支持连续获取对象产
出的每一个值。任何实现 Iterable 接口的对象都有一个
Symbol.iterator 属性，这个属性引用默认迭代器。默认迭代器
就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现
Iterator 接口的对象。
迭代器必须通过连续调用 next() 方法才能连续取得值，这个方
法返回一个 IteratorObject 。这个对象包含一个 done 属性和一
个 value 属性。前者是一个布尔值，表示是否还有更多值可以访
问；后者包含迭代器返回的当前值。这个接口可以通过手动反复调用
next() 方法来消费，也可以通过原生消费者，比如 for-of 循环
来自动消费。生成器是一种特殊的函数，调用之后会返回一个生成器对象。生
成器对象实现了 Iterable 接口，因此可用在任何消费可迭代对象
的地方。生成器的独特之处在于支持 yield 关键字，这个关键字能
够暂停执行生成器函数。使用 yield 关键字还可以通过 next() 方
法接收输入和产生输出。在加上星号之后， yield 关键字可以将跟
在它后面的可迭代对象序列化为一连串值。












































