#    一.JavaScript核心

核心（ECMAScript）

文档对象模型（DOM）

浏览器对象模型（BOM） 

# 二.DOM   

1.文档对象模型（DOM，Document Object Model），是一个应用编程接口（API），用于在HTML中使用扩展的XML。               

2.DOM Level 1中的DOM Core也被扩展以包含对XML命名空间的支持。

3.DOM Level 2新增了以下模块，以支持新的接口。

DOM视图：描述追踪文档不同视图（如应用CSS样式前后的

文档）的接口。

DOM事件：描述事件及事件处理的接口。

DOM样式：描述处理元素CSS样式的接口。

DOM遍历和范围：描述遍历和操作DOM树的接口。

4.其他DOM

除了DOM Core和DOM HTML接口，有些其他语言也发布了自己的DOM标准。

# 三.BOM

1.    IE3和Netscape Navigator 3提供了浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。使用BOM，开发者可以操控浏览器显示页面之外的部分。而BOM真正独一无二的地方，当然也是问题最多的地方，就是它是唯一一个没有相关标准的JavaScript实现。
2. BOM主要针对浏览器窗口和子窗口（frame），
3. 扩展

弹出新浏览器窗口的能力；移动、缩放和关闭浏览器窗口的能力；

navigator 对象，提供关于浏览器的详尽信息；

location 对象，提供浏览器加载页面的详尽信息；

screen 对象，提供关于用户屏幕分辨率的详尽信息；

performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；

对cookie的支持；

其他自定义对象，如 XMLHttpRequest 和IE的 ActiveXObject 。

# 四.**HTML**中的JavaScript

1.<script> 元素

async ：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。

charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值

crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。 

defer ：可选。表示在文档解析和显示完成后再执行脚本是没有问题的。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。

src ：可选。表示包含要执行的代码的外部文件。

type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。

2.  标签占位符

过去，所有 <script> 元素都被放在页面的 <head> 标签内，

```
<!DOCTYPE html> 

<html> 

<head> 

<title>Example HTML Page</title> 

<script src="example1.js"></script> 

<script src="example2.js"></script> 

</head> 

<body> 

<!--这里是页面内容-->

</body> 

</html>
```

不过这种方法会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。所以我们把标签放在 <body> 元素中的页面内容后面

```
<!DOCTYPE html> 

<html> 

<head> 

<title>Example HTML Page</title> 

</head> 

<body> 
<!--这里是页面内容-->

<script src="example1.js"></script> 

<script src="example2.js"></script> 

</body> 

</html>
```

3.推迟执行脚本

4. 异步执行脚本
5. 动态加载脚本
6. XHTML中的变化

#  五.语言基础

**.1** 语法

ECMAScript的语法很大程度上借鉴了C语言和其他类C语言，如Java和Perl。熟悉这些语言的开发者，应该很容易理解ECMAScript宽松的语法 

2. 区分大小写
3. 标识符
4. 注释
5. 严格模式
6. 语句
7. 关键字与保留字

break do in typeof  case else instanceof var  catch export new void  class extends return while  const finally super with  continue for switch yield  debugger function this  default if throw  delete import try 

8.  变量

有3个关键字可以声明变量： var 、 const 和 let 。其中， var 在ECMAScript的所有版本中都可以使用，而 const 和 let 只能在ECMAScript 6及更晚的版本中使用

9.数据类型

ECMAScript有6种简单数据类型（也称为原始类型）：Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。

10. typeof 操作符

"undefined" 表示值未定义；

"boolean" 表示值为布尔值；

"string" 表示值为字符串；

"number" 表示值为数值；

"object" 表示值为对象（而不是函数）或 null ； 

"function" 表示值为函数；

"symbol" 表示值为符号

### 操作符

ECMA-262描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。

1.一元操作符

2. 一元加和减

```
let num = 25; 

num = +num; 

console.log(num); // 25
```

3.位操作符

3.1   按位非

3.2 按位与

3.3  按位或

3.4 按位异或

3.5 左移

3.6 有符号右移

3.7 无符号右移

### 布尔值

1. 逻辑非
2. 逻辑与
3. 逻辑或

### 乘法操作符

1. 乘法操作符
2. 除法操作符
3. 取模操作符

### 指数操作符

ECMAScript 7新增了指数操作符， Math.pow() 现在有了自己

的操作符 ** ，结果是一样的：

```
console.log(Math.pow(3, 2); // 9

console.log(3 ** 2); // 9console.log(Math.pow(16, 0.5); // 4

console.log(16** 0.5); // 4
```

不仅如此，指数操作符也有自己的指数赋值操作符 **= ，该操

作符执行指数运算和结果的赋值操作：

```
let squared = 3; 

squared **= 2; 

console.log(squared); // 9

let sqrt = 16; 

sqrt **= 0.5; 

console.log(sqrt); // 4
```



### 加性操作符

1. 加法操作符

   加法操作符（ + ）用于求两个数的和，比如：

   let result = 1 + 2;

   如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：

   如果有任一操作数是 NaN ，则返回 NaN ；

   如果是 Infinity 加 Infinity ，则返回 Infinity ；

   如果是 -Infinity 加 -Infinity ，则返回 - Infinity ；

   如果是 Infinity 加 -Infinity ，则返回 NaN ；

   如果是 +0 加 +0 ，则返回 +0 ；

   如果是 -0 加 +0 ，则返回 +0 ；

   如果是 -0 加 -0 ，则返回 -0 。

   不过，如果有一个操作数是字符串，则要应用如下规则：

   如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；

   如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。

   如果有任一操作数是对象、数值或布尔值，则调用它们的toString() 方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null ，则调用 String() 函数，分别获取 "undefined" 和 "null" 。

   看下面的例子：

   let result1 = 5 + 5; *//* *两个数值*

   console.log(result1); *// 10* 

   let result2 = 5 + "5"; *//* *一个数值和一个字*

   *符串*

   console.log(result2); *// "55"*

   以上代码展示了加法操作符的两种运算模式。正常情况下， 5 + 

   5 等于10（数值），如前两行代码所示。但是，如果将一个操作数改为字符串，比如 "5" ，则相加的结果就变成了 "55" （原始字符串值），因为第一个操作数也会被转换为字符串。

   ECMAScript中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如下面这个例子：

   let num1 = 5; 

   let num2 = 10; 

   let message = "The sum of 5 and 10 is " + 

   num1 + num2; 

   console.log(message); *// "The sum of 5 and* 

   *10 is 510"*

   这里，变量 message 中保存的是一个字符串，是执行两次加法操作之后的结果。有人可能会认为最终得到的字符串是 "The sum of 5 and 10 is 15" 。可是，实际上得到的是 "The 

   sum of 5 and 10 is 510" 。这是因为每次加法运算都是独立完成的。第一次加法的操作数是一个字符串和一个数值（5），结果还是一个字符串。第二次加法仍然是用一个字符串去加一个数值（10），同样也会得到一个字符串。如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：

   let num1 = 5; 

   let num2 = 10; 

   let message = "The sum of 5 and 10 is " + 

   (num1 + num2); 

   console.log(message); *// "The sum of 5 and 10* 

   *is 15"*在此，我们用括号把两个数值变量括了起来，意思是让解释器先

   执行两个数值的加法，然后再把结果追加给字符串。因此，最终

   得到的字符串变成了 "The sum of 5 and 10 is 15" 。

2. 减法操作符

减法操作符（ - ）也是使用很频繁的一种操作符，比如：

let result = 2 - 1;

与加法操作符一样，减法操作符也有一组规则用于处理ECMAScript中不同类型之间的转换。

如果两个操作数都是数值，则执行数学减法运算并返回结果。

如果有任一操作数是 NaN ，则返回 NaN 。

如果是 Infinity 减 Infinity ，则返回 NaN 。

如果是 -Infinity 减 -Infinity ，则返回 NaN 。

如果是 Infinity 减 -Infinity ，则返回 Infinity 。

如果是 -Infinity 减 Infinity ，则返回 - Infinity 。

如果是 +0 减 +0 ，则返回 +0 。

如果是 +0 减 -0 ，则返回 -0 。

如果是 -0 减 -0 ，则返回 +0 。

如果有任一操作数是字符串、布尔值、 null 或 

undefined ，则先在后台使用 Number() 将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是NaN ，则减法计算的结果是 NaN 。

如果有任一操作数是对象，则调用其 valueOf() 方法取得        表示它的数值。如果该值是 NaN ，则减法计算的结果是NaN 。如果对象没有 valueOf() 方法，则调用其toString() 方法，然后再将得到的字符串转换为数值。

以下示例演示了上面的规则：

let result1 = 5 - true; *// true**被转换为**1**，所以结*

*果是**4* 

let result2 = NaN - 1; *// NaN* 

let result3 = 5 - 3; *// 2* 

let result4 = 5 - ""; *// ""**被转换为**0**，所以结果*

*是**5*

let result5 = 5 - "2"; *// "2"**被转换为**2**，所以结*

*果是**3* 

let result6 = 5 - null; *// null**被转换为**0**，所以结*

*果是**5* 

### 关系操作符

关系操作符执行比较两个值的操作，包括小于（ < ）、大于（ > ）、小于等于（ <= ）和大于等于（ >= ），用法跟数学课上学的一样。这几个操作符都返回布尔值，如下所示：

let result1 = 5 > 3; *// true* 

let result2 = 5 < 3; *// false*

### 相等操作符

1. 等于和不等于
2. 全等和不全等

### 条件操作符

条件操作符是ECMAScript中用途最为广泛的操作符之一，语法跟Java中一样：

variable = boolean_expression ? true_value :      false_value;

###  赋值操作符

简单赋值用等于号（ = ）表示，将右手边的值赋给左手边的变量，如下所示：

let num = 10;

每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：

乘后赋值（ *= ）

除后赋值（ /= ）

取模后赋值（ %= ）

加后赋值（ += ）

减后赋值（ -= ）

左移后赋值（ <<= ）

右移后赋值（ >>= ）

无符号右移后赋值（ >>>= ）

这些操作符仅仅是简写语法，使用它们不会提升性能。

### 逗号操作符

逗号操作符可以用来在一条语句中执行多个操作，如下所示：let num1 = 1, num2 = 2, num3 = 3;

##   语句

1. if 语句
2. do-while 语句
3. while 语句
4. for 语句
5. for-in 语句
6. for-of 语句
7. 标签语句
8. break 和 continue 语句
9. with 语句
10. switch 语句

### 函数

函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript中的函数使用function 关键字声明，后跟一组参数，然后是函数体。





#### ECMAScript中的基本数据类型包括 Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。

# 六 变量，作用域与内存

## 1.原始值与引用值

### 1.1动态属性

原始值和引用值的定义方式很类似，都是创建一个变量，然后给

它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什

么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属

性和方法。

### 1.2复制值

除了存储方式不同，原始值和引用值在通过变量复制时也有所不

同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制

到新变量的位置。

```
let num1 = 5; 

let num2 = num1;
```

### 1.3传递参数

ECMAScript中所有函数的参数都是按值传递的。这意味着函数外

的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变

量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引

用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块

可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值

传递

## 2.执行上下文与作用域

### 2.1作用域链增强

try / catch 语句的 catch 块 

with 语句

### 2.2变量声明

1. 使用 var 的函数作用域声明

2. 使用 let 的块级作用域声明
   3. 使用 const 的常量声明
   4. 标识符查找

## 3.垃圾回收

JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码

执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是

个很大的负担，也是很多问题的来源。JavaScript为开发者卸下了这个

负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很

简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程

是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程

中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且

不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，

意味着靠算法是解决不了的。

### 3.1标记清理

JavaScript最常用的垃圾回收策略是标记清理（mark-and

sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑

上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运

行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下

文的标记。

### 3.2引用计数

另一种没那么常用的垃圾回收策略是引用计数（reference

counting）。其思路是对每个值都记录它被引用的次数。声明变量并给

它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一

个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他

值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办

法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序

下次运行的时候就会释放引用数为0的值的内存。

### 3.3 性能

垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可

能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有

限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。

开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代

码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工

作

### 3.4内存管理

1. 通过 const 和 let 声明提升性能

2. 隐藏类和删除操作

### 4.内存泄漏

写得不好的JavaScript可能出现难以察觉且有害的内存泄漏问题。

在内存有限的设备上，或者在函数会被调用很多次的情况下，内

存泄漏可能是个大问题。JavaScript中的内存泄漏大部分是由不合

理的引用导致的

### 5.静态分配与对象池

为了提升JavaScript性能，最后要考虑的一点往往就是压榨浏览器

了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次

数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控

制触发垃圾回收的条件。理论上，如果能够合理使用分配的内

存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失

的性能。

## 总结

JavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以下6种原始数据类型之一： Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有以下特点。

原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。引用值是对象，存储在堆内存上。

包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。执行上下文分全局上下文、函数上下文和块级上下文。代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。

函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。

变量的执行上下文用于确定什么时候释放内存。JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript的垃圾回收程序可以总结如下。

离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。

主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。

引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。

JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素）。

引用计数在代码中存在循环引用时会出现问题。

解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都

应该在不需要时解除引用。

# 第五章  基本引用数据类型

本章节主要理解的是   

1.对象，

2.基本JavaScript数据类型 ， 

3.原始值与原始值包装类型

引用值（或者对象）是某个特定引用类型的实例。在ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲JavaScript是一门面向对象语言，但ECMAScript缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。

在这里要注意一点

引用类型虽然有点像类，但跟类并不是一个概念。

对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函数（constructor）来创建。构造函数就是用来创建新对象的函数。

let now = new Date();

 

函数也是一种引用类型，但有关函数的内容太多了，一章放不下，所以本书专门用第10章来介绍函数。

## Date

ECMAScript的 Date 类型参考了Java早期版本中的java.util.Date 。为此， Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种存储格式， Date 类型可以精确表示1970年1月 1日之前及之后285 616年的日期。

下面是一个创建时间的代码  用到了new和Data

```
let now = new Date();
```

Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262第5版定义了Date.parse() 应该支持的日期格式，填充了第3版遗留的空白。所有实现都必须支持下列日期格式：

“月/日/年”，如 "5/23/2019" ； 

“月名 日, 年”，如 "May 23, 2019" ； 

“周几 月名 日 年 时:分:秒 时区”，如 "Tue May 23 2019 00:00:00GMT-0700" ；

ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05- 

23T00:00:00 （只适用于兼容ES5的实现）。

要创建一个表示“2019年5月23日”的日期对象，可以使用以下代

码：let someDate = new Date(Date.parse("May 23, 2019"));

1. 继承的方法
2. 日期格式化方法
3. 日期**/**时间组件方法 

方法 说明

getTime()返回日期的毫秒表示；与valueOf() 相同setTime(*milliseconds*)设置日期的毫秒表示，从而修改整个日期

getFullYear()返回4位数年（即2019而不是19） 

getUTCFullYear()返回UTC日期的4位数年

setFullYear(*year*)设置日期的年（ *year* 必须是4位数）

setUTCFullYear(*year*)设置UTC日期的年（ *year* 必须是4位数）

getMonth()返回日期的月（0表示1月，11表 示12月）

getUTCMonth()返回UTC日期的月（0表示1月，11表示12月）

setMonth(*month*)设置日期的月（ *month* 为大于0的数值，大于11加年）

setUTCMonth(*month*)设置UTC日期的月（ *month* 为大于0的数值，大于11加年）

getDate()返回日期中的日（1~31） 

getUTCDate()返回UTC日期中的日（1~31） 

setDate(*date*)设置日期中的日（如果 *date* 大于该月天数，则加月）

setUTCDate(*date*)设置UTC日期中的日（如果date大于该月天数，则加月）

getDay()返回日期中表示周几的数值（0表示周日，6表示周六）

##  RegExp

1. RegExp 实例属性

   每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。

   global ：布尔值，表示是否设置了 g 标记。

   ignoreCase ：布尔值，表示是否设置了 i 标记。

   unicode ：布尔值，表示是否设置了 u 标记。

   sticky ：布尔值，表示是否设置了 y 标记。

   lastIndex ：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。

   multiline ：布尔值，表示是否设置了 m 标记。

   dotAll ：布尔值，表示是否设置了 s 标记。

   source ：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。

   flags ：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）

2. RegExp 实例方法 

3. RegExp 构造函数属性

4. 模式局限

## 原始值包装类型

1. Boolean

2. Number

3. String

   3.1    JavaScript字符

   3.2   normalize() 方法

   3.3   字符串操作方法

   3.4    字符串位置方法

   3.5    字符串包含方法

   3.6    trim() 方法

   3.7    repeat() 方法

   3.8    padStart() 和 padEnd() 方法

   3.9   字符串迭代与解构

   3.10   字符串大小写转换

   3.11   字符串模式匹配方法

   3.12    localeCompare() 方法

   3.13      HTML方法

## 单例内置对象

### Global

​	1. URL编码方法

2. eval() 方法

3. Global 对象属性

4. window 对象

### Math

1. Math 对象属性
2. min() 和 max() 方法
3. 舍入方法
4. random() 方法
5. 其他方法

## 小结

JavaScript中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。

引用值与传统面向对象编程语言中的类相似，但实现不同。

Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。

RegExp 类型是ECMAScript支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。

JavaScript比较独特的一点是，函数实际上是 Function 类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。

由于原始值包装类型的存在，JavaScript中的原始值可以被当成对象来使用。有3种原始值包装类型： Boolean 、 Number 和 String 。它们都具备如下特点。

1. 每种包装类型都映射到同名的原始类型。

2. 以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。

3. 涉及原始值的语句执行完毕后，包装对象就会被销毁。

当代码开始执行时，全局上下文中会存在两个内置对象： Global 和 Math 。其中， Global 对象在大多数ECMAScript实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函数都是Global 对象的属性。 Math 对象包含辅助完成复杂计算的属性和方法。