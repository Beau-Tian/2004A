#### **第 4 章 变量、作用域与内存**

​             1 . JavaScript中的变量可谓独树一帜。，JavaScript变量是松散类型的，而且变量不过就是特定时间点一个特定值的名称而已。由于没有规则定义变量必须包含什么数据类型，变量的值和数据类型在脚本生命期内可以改变。

**原始值与引用值**

			1. 变量可以包含两种不同类型的数据：原始值和引用值。
   			2. 原始值（primitive value）就是最简单的数据    引用值（referencevalue）则是由多个值构成的对象。
   			3. 引用值（referencevalue）则是由多个值构成的对象。引用值是保存在内存中的对象

**动态属性**

​                 1.  原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。比如，看下面的例子：

```
let person = new Object(); 
person.name = "Nicholas"; 
console.log(person.name); // "Nicholas"
```

​             这里，首先创建了一个对象，并把它保存在变量 person 中。然后，给这个对象添加了一个名为 name 的属性，并给这个属性赋值了一个字符串 "Nicholas" 。在此之后，就可以访问这个新属性，直到对象被销毁或属性被显式地删除。

​         **注意**，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则JavaScript会创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：

```
let name1 = "Nicholas";
let name2 = new String("Matt");
name1.age = 27; 
name2.age = 26; 
console.log(name1.age); // undefined console.log(name2.age); // 26 
console.log(typeof name1); // string console.log(typeof name2); // object
```

**复制值**

​          1. 除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。

**传递参数**

			1. ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中
   			2. 如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。

**确定类型**

​            1.   typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null ，那么typeof 返回 "object" 

- ```
  let s = "Nicholas";
  let b = true; 
  let i = 22;
  let u; 
  let n = null;
  let o = new Object();
  console.log(typeof s); // string 
  console.log(typeof i); // number 
  console.log(typeof b); // boolean 
  console.log(typeof u); // undefined console.log(typeof n); // object 
  console.log(typeof o); // object
  
  typeof 虽然对原始值很有用，但它对引用值的用处不大
  ```

![](D:\田松\笔记\原型原型链\变量.png)

**执行上下文与作用域**

​       1. 变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。

​        2.全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象

​       3. 上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。

​        4. 每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。

​         5. 上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activationobject）用作变量对象。活动对象最初只有一个定义变量：arguments 。

**变量声明**

​         1. var 都是声明变量的唯一关键字。

**使用 var 的函数作用域声明**

​           1. 在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，如下面的例子所示

```
function add(num1, num2) { 
var sum = num1 + num2;
return sum; 
}
let result = add(10, 20); // 30 
console.log(sum); // 报错：sum在这里不是有效变量
```

​          这里，函数 add() 定义了一个局部变量 sum ，保存加法操作的结果。这个值作为函数的值被返回，但变量 sum 在函数外部是访问不到的。



### var ， let  ，const，的区别

- 1. var声明的变量存在变量提升，值为：undefined。允许重复声明变量，var和let可以修改已经声明的变量
- 2. let和const不存在变量提升。但是存在暂时性死区和块级作用域
- 3. （暂时性死区：在代码块内，let命令声明之前，该变量都是不可用的）
- 4. （块级作用域是由{ }包裹的，if语句和for语句里的{ }也属于块作用域）
- 5. const声明一个只读的常量，值不能改变。（引用数据类型可以改变内部的值）

**垃圾回收**

​       1.函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。

**标记清理**

​          1. 当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。

​         2. 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

**引用计数**

​        1.是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。

​        2.为避免类似的循环引用问题，应该在确保不使用的情况下切断原生JavaScript对象与DOM元素之间的连接。比如，通过以下代码可以清除前面的例子中建立的循环引用：

```
myObject.element = null; 
element.someObject = null;
```

​        把变量设置为 null 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收

**性能**

​          1 . 垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。

```
在某些浏览器中是有可能（但不推荐）主动触发垃圾回收
的。在IE中， window.CollectGarbage() 方法会立即触发垃圾回收。在Opera 7及更高版本中，调用window.opera.collect() 也会启动垃圾回收程序。
```

**内存管理**

​      1 . 将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用，如下面的例子所示：

```
function createPerson(name){
let localPerson = new Object();
localPerson.name = name; 
return localPerson;
}
let globalPerson = createPerson("Nicholas"); // 解除globalPerson对值的引用
globalPerson = null;
```

**1. 通过 const 和 let 声明提升性能**

​          1.  ES6增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为 const 和 let 都以块（而非函数）为作用域，所以相比于使用 var ，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下这就有可能发生

 **隐藏类和删除操作**

​        1 . 根据JavaScript所在的运行环境，有时候需要根据浏览器使用的JavaScript引擎来采取不同的性能优化策略。

\**3. 内存泄漏**

​         1. 写得不好的JavaScript可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript中的内存泄漏大部分是由不合理的引用导致的。