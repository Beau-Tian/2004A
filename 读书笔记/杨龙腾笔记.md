##### ECMAScript不区分整数和浮点值，只有Number 一种数值数据类型

Object 是一种复杂数据类型，它是这门语言中所有对象的基类 

#####  变量作用域：就是一个变量可以使用的范围。 

```
js中首先有一个最外层的作用域，`全局作用域`；

js中可以通过函数来创建一个独立作用域称为`函数作用域`，函数可以嵌套，所以作用域也可以嵌套；

es6中新增了`块级作用域`（大括号，比如：if{},for(){},while(){}）；
```

垃圾回收 

JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码 

执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是 

个很大的负担，也是很多问题的来源。JavaScript为开发者卸下了这个 

负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很 

简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程 

是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程 

中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且 

不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题， 

意味着靠算法是解决不了的。 

我们以函数中局部变量的正常生命周期为例。函数中的局部变量 

会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应 

的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局 

部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不 

再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序 

必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回 

收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏 

览器的发展史上，用到过两种主要的标记策略：标记清理和引用计 

数

**执行上下文（栈）context(context stack)**

```
每一次代码执行和函数调用都会产生一个执行环境，称为执行上下文。

一个执行上下文（caller）又可以激活（调用）另一个执行上下文（callee），这时caller会暂停自身的执行把控制权交给callee进入callee的执行上下文，callee执行完毕后将控制权交回caller，callee可以用return或者抛出Exception来结束自己的执行。

多个执行上下文会形成执行上下文栈，最顶层是当前执行上下文，底层是全局执行上下文。
三、JS执行上下文栈(后面简称执行栈)

　　执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。

规则如下：

　　首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。
```

##### 作用域

　**作用域**就是变量和函数的可访问范围，控制这个变量或者函数可访问行和生命周期。

　　作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。( with 和 eval 能够修改词法作用域，但是不推荐使用，对此不做特别说明)

　　在 js 中是词法作用域，意思就是你的变量函数的作用域是由你的编码中的位置决定的，当然可以通过 apply、call、 bind 等函数进行修改。

　　在 ES6 之前，js 中的作用域分为两种：函数作用域和全局作用域，现在作用域分为：全局作用域、函数作用域、块级作用域。

　　全局作用域顾名思义，浏览器下就是 window ，作用域链的顶级就是它，那么只要不是被函数包裹的变量或者函数，它的作用域就是全局。



#### 作用域链

```
　　我们知道函数在执行时是有个执行栈，在函数执行的时候会创建执行环境，也就是执行上下文，在上下文中有个大对象，保存执行环境定义的变量和函数，在使用变量的时候，就会访问这个大对象，这个对象会随着函数的调用而创建，函数执行结束出栈而销毁，那么这些大对象组成一个链，就是作用域链。那么函数内部未定义的变量，就会顺着作用域链向上查找，一直找到同名的属性。
作用域是每一个执行上下文自身持有的活动对象的集合，如在本执行上下文中声明的变量和函数以及方法参数传入的对象。

每一个执行上下文可以访问的对象包括自身的作用域和父执行上下文的作用域和父父执行上下文作用域直到全局作用域，这就产生了作用域链。

作用域链的工作原理跟原型链十分相似：如果本身的作用域中查找不到标识符，那么就查找父作用域，直到顶层。

目前假设作用域的联动是用的__parent__对象，它指向作用域链的下一个对象

 全局上下文的作用域包含Object.prototype中的对象，with和catch会改变作用域链：  

在with中，查询__parent__之前会先去查询__proto__，会使作用域链增大。

```

#### js起源

JavaScript 诞生于 1995 年。当时，它的主要目的是处理以前由服务器端语言负责的一些输入验证操作。如今， JavaScript 的用途早已不再局限于简单的数据验证，而是具备了与浏览器窗口及其内容等几乎所有方面交互的能力。今天的JavaScript 已经成为一门功能全面的编程语言，能够处理复杂的计算和交互。JavaScript成为市面上所有浏览器得标配， js使用度高。

##### 布尔操作符 

1. 逻辑非 

逻辑非操作符由一个叹号（ ! ）表示，可应用给ECMAScript中 

的任何值。这个操作符始终返回布尔值，无论应用到的是什么数 

据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其 

取反。换句话说，逻辑非操作符会遵循如下规则。 

如果操作数是对象，则返回 false 。 

如果操作数是空字符串，则返回 true 。 

如果操作数是非空字符串，则返回 false 。 

如果操作数是数值0，则返回 true 。 

如果操作数是非0数值（包括 Infinity ），则返回 

false 。 

如果操作数是 null ，则返回 true 。 

如果操作数是 NaN ，则返回 true 。

如果操作数是 undefined ，则返回 true 。 

以下示例验证了上述行为： 

```
console.log(!false); *// true* 

console.log(!"blue"); *// false* 

console.log(!0); *// true* 

console.log(!NaN); *// true* 

console.log(!""); *// true* 

console.log(!12345); *// false*

```

2. 逻辑与 

逻辑与操作符由两个和号（ && ）表示，应用到两个值，如下所 

示.

  

相等操作符 

判断两个变量是否相等是编程中最重要的操作之一。在比较字符 

串、数值和布尔值是否相等时，过程都很直观。但是在比较两个对象 

是否相等时，情形就比较复杂了。ECMAScript中的相等和不相等操作 

符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是 

否应该发生。最终，ECMAScript提供了两组操作符。第一组是等于和 

不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在 

比较之前不执行转换。 

\1. 等于和不等于 

ECMAScript中的等于操作符用两个等于号（ == ）表示，如果操 

作数相等，则会返回 true 。不等于操作符用叹号和等于号 

（ != ）表示，如果两个操作数不相等，则会返回 true 。这两 

个操作符都会先进行类型转换（通常称为强制类型转换）再确定 

操作数是否相等。 

在转换操作数的类型时，相等和不相等操作符遵循如下规则。 

如果任一操作数是布尔值，则将其转换为数值再比较是否相 

等。 false 转换为0， true 转换为1。 

如果一个操作数是字符串，另一个操作数是数值，则尝试将 

字符串转换为数值，再比较是否相等。 

如果一个操作数是对象，另一个操作数不是，则调用对象的 

valueOf() 方法取得其原始值，再根据前面的规则进行比 

较。 

在进行比较时，这两个操作符会遵循如下规则。 

null 和 undefined 相等。



##### 加性操作符 

加性操作符，即加法和减法操作符，一般都是编程语言中最简单 

的操作符。不过，在ECMAScript中，这两个操作符拥有一些特殊的行 

为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转 

换。只不过对这两个操作符来说，转换规则不是那么直观。 

#### JavaScript语言的特点

###### 一、脚本编写语言

```
      JavaScript 是一种脚本语言，它采用小程序段的方式实现编程。像其它脚本语言一样,JavaScript 同样已是一种解释性语言，它提供了一个简易的开发过程。

```



###### 二、基于对象的语言

```
      JavaScript 是一种基于对象的语言，同时也可以看作一种面向对象的语言。这意味着它能运用自己已经创建的对象。因此，许多功能可以来自于脚本环境中对象的方法与脚本的相互作用。

```



###### 三、简单性

```
      JavaScript是一种基于Java基本语句和控制流之上的简单而紧凑的设计，从而对于学习Java是一种非常好的过渡。它的变量类型是采用弱类型，并未使用严格的数据类型。

```



###### 四、动态性

```
      JavaScript是动态的，它可以直接对用户或客户输入做出响应，无须经过Web服务程序。它对用户的反映响应，是采用以事件驱动的方式进行的。
所谓事件驱动，就是指在主页（Home Page）中执行了某种操作所产生的动作，就称为“事件”（Event）。比如按下鼠标、移动窗口、选择菜单等都可以视为事件。当事件发生后，可能会引起相应的事件响应。

```

###### 五、安全性

```
    JavaScript是一种安全性语言，它不允许访问本地的硬盘，并不能将数据存入到服务器上，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互。从而有效地防止数据的丢失。

```



###### 六、跨平台性

  

```
  JavaScript 是依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持 JavaScript 的浏览器就可正确执行。从而实现了“编写一次，走遍天下”的梦想。
实际上 JavaScript 最杰出之处在于可以用很小的程序做大量的事。
综合所述 JavaScript 是一种新的描述语言，它可以被嵌入到 HTML 的文件之中。 JavaScript 语言可以做到回应使用者的需求事件 (如： form 的输入) ，而不用任何的网络来回传输资料。

```

#### JavaScript  的组成

```
ECMAScript 描述了该语言的语法和基本对象；
DOM 描述了处理网页内容的方法和接口；
BOM 描述了与浏览器进行交互的方法和接口

```

##### Js 语法的基本要素

```
区分大小写
变量不区分类型
每条语句结尾可以省略分号
注释与C,C++,java,php相同
代码段要封闭

```

##### 全局变量的三种声明方式：

```
（1）声明方式一：
使用var（关键字）+变量名(标识符)的方式在function外部声明，即为全局变量，否则在function声明的是局部变量。该方式即为显式声明详细如下：
                        var test = 5;  //全局变量
			    function a（）
			   {
                        var cc=3; //局部变量
                        alert(test);
			   }
                       function b（）{alert(test);}

```

```
（2）没有使用var，直接给标识符test赋值，这样会隐式的声明了全局变量test。即使该语句是在一个function内，当该function被执行后test变成了全局变量。
                         test = 5;//全局变量 
                         function a()
                        {
                        aa=3; //全局变量
                        alert(test);
                         }

```

```
(3)使用window全局对象来声明，全局对象的属性对应也是全局变量，
                    window.test;
                    window.test = 5;

```

#### 什么是javascript？

​	1、javascript是一种基于对象和事件驱动的客户端脚本语言。
​	2、javascript最初的设计师为了检验HTML表单输入的正确性
​	3、javascript起源于Netscape公司的livescript语言。

#### JavaScript 是什么

JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。



```
JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的 

形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对 

象，能完成基本的计算任务，但没有提供获得输入和产生输出的机 

制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的 

关键。

 ECMAScript中的基本数据类型包括 Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。

```

严格模式对函数也有一些限制： 

函数不能以 eval 或 arguments 作为名称； 

函数的参数不能叫 eval 或 arguments ； 

两个函数的参数不能叫同一个名称。 

如果违反上述规则，则会导致语法错误，代码也不会执行。

#####  const关键字声明变量是在es6中引入的 ，使用const声明变量主要有以下特点： 

1 **使用const声明的常量具有块级作用域**  

```
if(true){ 
const a = 10;   
console.log(a) //输出
}
console.log(a) //报错
```

 **2 const声明常量之后必须设置初始值** 

```
const PI ; // 报错
```

 **3 const声明的常量 值不能更改** 

```
const arr = [100,200]

arr[0] = "a";

arr[1] = "b";

console.log(arr)*//正常输出*

const arr = ['a','b'];

console.log(arr) *//报错

对于简单的数据类型，const声明之后，值不能改变，对于复杂的数据类型，比如对象或者数组，可以修改其中的值，但是不能修改对应的内存地址。
```

**一、块级作用域**

在ES6之前我们脑海里应该只存在全局作用域和函数级作用域，没有块级作用域。那么为什么要引入块级作用域呢？

- **避免外层变量被覆盖**

相信很多刚入门的同学看到上述代码会有所不解，其实在全局作用域str变量已经被声明且赋值，为什么我函数里面访问不到呢。这里就牵扯到变量提升和函数级作用域的概念。上述代码其实等同于下放代码，当函数被执行的时候生成了一个新的作用域也就是函数作用域，js引擎会把变量声明提到方法体的最前面，大家可以看到只是声明了并没有赋值。所以就是 undefined。

- **循环变量污染全变量**

很多同学面试的时候可能会遇到上面类似的代码，疑惑点应该在为什么会打印出来为什么会是5，同样的道理代码如同下方。变量会被提升，所以在循环结束之后i就被累加到了5.

es6的let和const声明符，是不存在变量提升的；同时也只在块级作用域生效。

这个答案应该很明显了吧

**二、暂时性死区DN**

什么是暂时性死区呢？很多人可能很迷惑。那就听我娓娓道来，如果说我们使用了let和const命令，作用域内会对这些命令声明的变量，在它的声明周期内形成一种封闭作用域。这在语法上，称为“暂时性死区”。代码展示如下:

因为let和const声明是不会被提升的，所以为了保障声明的有效性，js的解释引擎会对变量所处的块级作用域形成一种保护，因此在声明之前使用会有语法错误，是不被允许的。

**不能重复声明
**

相信大家一般不会声明重复变量编码，所以在这里就不做解释了。如果大家感兴趣可以自己研究或者来现场一起学习。

**三、const常量**

const声明符的大多特性和let相同，这里就不多做解释了。大家都知道const是声明常量的，一但变量被声明成常量它就不能再被继续修改了。大家要注意的是这里变量不可被修改的是存储的地址值不可被修改，意思就是简单类型的数据是不能修改的。复合类型的数据（主要是对象和数组）const只能保证这个指针是固定的，而这个具体的对象实例包含的属性是可以被修改的。看看代码我们可能会更清楚：

正如大家所看到的字符串a被复制后就不能在修改，而对象和数组是可以改变它里面的元素的，但是不能给重新复制一个新的对象实例。由此就可以断定const声明出来的变量存的是固定的地址值。

