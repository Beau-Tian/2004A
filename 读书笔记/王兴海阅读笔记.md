### JavaScript笔记

**javascript简介:**   ECMASCript 、JScript 、ES5 、ES6 、ECMA2016 、ES7

**六种基本数据类型数据类型**

**String   Number   Boolean   Object   Null   Undefined**

**javascript算术运算符：** ==   ===   +   ++   -   --   /   %   +=   -=   /=   *=   try catch

**数据类型的基本方法和操作：**

typeof   instanceof   toString判断类型

if   switch   for   while   for-in   for-of



function(函数是一等公民，可以作为函数参数，可以作为函数返回值，也可以赋值给变量)、匿名函数  声明式函数      

函数表达式  arguments  callee  caller

**作用域**（全局作用域  函数作用域  块级作用域）var   for  settimeout  

哪些方式实现块级作用域（try catch IIFE with）

作用域链  this   bind   call   apply   IIFE的诡异执行方式和为什么   闭包

setInterval   setTimeout   setImmediate



全局变量，或者函数，可以覆盖 window 对象的变量或者函数。

局部变量，包括 window 对象可以覆盖全局变量和函数。



------

**面向对象   原型（私有和公有，this.变量的问题）原型链   原型对象共享问题  Function的诡异问题**

**正则表达式  递归   严格模式   调试方式   驼峰命名法**



#### 	为什么使用严格模式：

​				消除Javascript语法的一些**不合理**、**不严谨之处**，减少一些**怪异**行为；

​				消除代码运行的一些**不安全之处**，保证代码运行的**安全**；

​				提高编译器效率，增加运行速度；

​				为未来新版本的**JavaScript**做好铺垫。

​				"严格模式"体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。

​				另一方面，同样的代码，在"严格模式"中，可能会有不一样的运行结果；一些在"正常模式"下可以运行的语句，在"严格模式"下将不能运行。掌握这些内

​				容，有助于更细致深入地理解Javascript，



"严格模式"体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。

另一方面，同样的代码，在"严格模式"中，可能会有不一样的运行结果；一些在"正常模式"下可以运行的语句，在"严格模式"下将不能运行。掌握这些内容，有助

于更细致深入地理解Javascript



原型与原型链

prototype ，理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，

这个对象就是我们所说的原型，每一个对象都会从原型继承属性。

​	![](C:\Users\Moon\Desktop\原型\1490251-48851bf37a08259d.webp)

__proto__，这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。

![](C:\Users\Moon\Desktop\原型\1490251-e7476a8697e97aab.webp)

constructor，每个原型都有一个 constructor 属性指向关联的构造函数。

![](C:\Users\Moon\Desktop\原型\1490251-0cac772635e8a128.webp)

然后我们引入原形链的概念：当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，

如果还查不到，就去找原型的原型，一直找到最顶层为止。

```javascript
function Person() {

}

Person.prototype.name = 'Kevin';

var person = new Person();

person.name = 'Daisy';
console.log(person.name) // Daisy

delete person.name;
console.log(person.name) // Kevin

var obj = new Object();
obj.name = 'Kevin'
console.log(obj.name) // Kevin
```

![](C:\Users\Moon\Desktop\原型\1490251-293b8fe01cf2ef5f.webp)

JavaScript 默认并不会**复制**对象的属性，相反，JavaScript 只是在两个对象之间创建一个**关联**，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所

以与其叫继承，**委托**的说法反而更准确些

![](C:\Users\Moon\Desktop\原型\1490251-3089c135df71c956.webp)

#### 原型链继承的优缺点

**优点：**

​				非常简便的实现了多重继承的关系；

​				能够确定原型和实例之间的关系；

**缺点：**

​				创建子类型实例时，无法向父类型传递参数，尤其是多重继承时，弊端非常明显；

​				所有的实例会共享通过原型链继承的属性，在一个实例中改变了，会在另一个实例中反映出来；

​				不能使用字面量添加新方法，会使继承关系中断（会重写constructor属性）；



#### 封装一个面包屑导航

```js
	<strong class="title">{{$route.name}}</strong>
	<el-breadcrumb separator="/" class="breadcrumb-inner">
		<el-breadcrumb-item v-for="item in $route.matched" :key="item.path">
			{{ item.name }}
		</el-breadcrumb-item>
	</el-breadcrumb>
```

```
封装面包屑的好处

它是一种线性的导航方式，是一种“历史记录”的应用方式，目的是帮助你追溯来路，现在变成用来表达内容归属关系的界面元素。 我们经常看到的“主分类>一级分类>二级分类>三级分类>……>最终内容页面”这样的方式。
但是一般正常的来讲目录结构由3层结构组成。分别是首页>栏目页>内容页。
合理的构建目录结构可以让用户随时随地的找到自己所在的位置又能保证栏目分类后的各个栏目的权重不至于太分散。

目的：
 	1、让用户了解目前所处位置，以及当前页面在整个网站中的位置。
	2、体现了网站的架构层级，能够帮助用户快速学习和了解网站内容和组织方式，从而形成很好的位置感。
 	3、提供返回各个层级的快速入口，方便用户操作。
	4、Google已经将面包屑导航整合到搜索结果里面，因此优化面包屑导航每个层级的名称，多使用关键字，都可以实现SEO优化。面包屑路径，对于提高用户体验来说，是很有		帮助的。
 	5、方便用户，面包屑主要用于为用户提供导航一个网站的次要方法，通过为一个大型多级网站的所有页面提供面包屑路径，用户可以更容易的定位到上一次目录，引导用户通		行。
 	6、减少返回到上一级页面的点击或操作，不用使用浏览器的“返回”按钮或网站的主要导航来返回到上一级页面。
 	7、不用常常占用屏幕空间，因为它们通常是水平排列以及简单的样式，面包屑路径不会占用页面太多的空间。这样的好处是，从内容过载方面来说，他们几乎没有任何负面影		响。
	8、降低跳出率，面包屑路径会是一个诱惑首次访问者在进入一个页面后去浏览这个网站的非常好的方法。比如说，一个用户通过谷歌搜索到一个页面，然后看到一个面包屑路		径，这将会诱使用户点击上一级页面去浏览感兴趣的相关主题。这样，从而，可以降低网站的总体跳出率。

	9、有利用百度蜘蛛对网站的抓取，蜘蛛直接沿着那个链走就可以了，很方便。

 	10、面包屑有利于网站内链的建设，用面包屑大大增加了网站的内部连接，提高用户体验。

```



# Javascript文章笔记



##### 2021-01-18阅读文章总结



**在基本的层面的语言如下部分：**

语法  类型  语句  关键字  保留字  操作符  全局对象



**JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。ECMAScript：由ECMA-262定义并提供核心功能。**

- 文档对象模型（DOM）：提供与网页内容交互的方法和接口。

- 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。

- JavaScript的这三个部分得到了五大Web浏览器（IE、Firefox、

Chrome、Safari和Opera）不同程度的支持。所有浏览器基本上对

ES5（ECMAScript 5）提供了完善的支持，而对ES6（ECMAScript 6） 

和ES7（ECMAScript 7）的支持度也在不断提升。这些浏览器对DOM的支持各不相同，但对Level 3的支持日益趋于规范。HTML5中收录的

BOM会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共

特性。



**文档模式**

IE5.5发明了文档模式的概念，即可以使用 doctype 切换文档模式。最初的文档模式有两种：混杂模式（quirks mode）和标准模式（standards mode）。

前者让IE像IE5一样（支持一些非标准的特性），后者让IE具有兼容标准的行为。虽然这两种模式的主要区别只体现在通过CSS渲染的内容方面，

但对JavaScript也有一些关联影响，或称为副作用。



**知识点**

JavaScript是通过<style>元素插入到HTML页面中的。这个

元素可用于把JavaScript代码嵌入到HTML页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的JavaScript。



**ECMAScript**的语法很大程度上借鉴了**C语言**和其他类C语言，如

Java和Perl。熟悉这些语言的开发者，应该很容易理解ECMAScript宽

松的语法



**严格模式**

ECMAScript 5增加了严格模式（strict mode）的概念。严格模式是

一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写

法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个

脚本启用严格模式，在脚本开头加上这一行：

```js
"use strict";
```

**关于变量的知识**

ECMAScript变量是松散类型的，意思是变量可以用于保存任何类

型的数据。每个变量只不过是一个用于保存任意值的命名占位符。**有3个关键字**可以声明变量： **var** 、 **const** 和**let** 。其中， var 在

ECMAScript的所有版本中都可以使用，而 const 和 let 只能在

ECMAScript 6及更晚的版本中使用。



**let 声明 **

let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是， let 声明的范围是块作用域，而 var 声明的范围是函数作用域。



**在解析代码时，JavaScript引擎也会注意出现在块后面的 let 声**

**明，只不过在此之前不能以任何方式来引用未声明的变量。在**

**let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead**

**zone），在此阶段引用任何后面才声明的变量都会抛出**



**const 声明** 

const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。

```js
const age = 26; 

age = 36; *// TypeError:* *给常量赋值*

*// const**也不允许重复声明*

const name = 'Matt'; 

const name = 'Nicholas'; *// SyntaxError* 

*// const**声明的作用域也是块*

const name = 'Matt'; 

if (true) { 

const name = 'Nicholas'; 

}

console.log(name); *// Matt* 
```

const 声明的限制只适用于它指向的变量的引用。换句话说，

如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。



**var 关键字**

要定义变量，可以使用 var 操作符（注意 var 是一个关键字），后跟变量名;

------

**数据类型**

ECMAScript有6种简单数据类型（也称为原始类型）：**Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。 Symbol （符号）**

是ECMAScript 6新增的。还有一种复杂数据类型叫 **Object （对象）**。 Object 是一种无序名值对的集

合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述**7**种数据类型之一来表示。只有7种数据类型似乎不足以表示全部

数据。但ECMAScript的数据类型很灵活，一种数据类型可以当作多种

数据类型来使用。



##### 2021-01-19阅读文章总结



**typeof 操作符**

因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。 typeof 操作符就是为此而生的。对一个值使用 typeof 操作符会返回下列字符串之一：

"undefined" 表示值未定义；

"boolean" 表示值为布尔值；

"string" 表示值为字符串；

"number" 表示值为数值；

"object" 表示值为对象（而不是函数）或 null ； 

"function" 表示值为函数；

"symbol" 表示值为符号。



**Undefined 类型 **

Undefined 类型只有一个值，就是特殊值 undefined 。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值

```js
let message; console.log(message == undefined); // truelet message; console.log(message == undefined); // true
在这个例子中，变量 message 在声明的时候并未初始化。而在
比较它和 undefined 的字面值时，两者是相等的。这个例子等同于
如下示例：
let message = undefined; console.log(message == undefined); // true
```



**Null 类型** 

Null 类型同样只有一个值，即特殊值 null 。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 "object" 的原因

```js
let car = null; console.log(typeof car); // "object"
在定义将来要保存对象值的变量时，建议使用 null 来初始化，
不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以
知道这个变量是否在后来被重新赋予了一个对象的引用，比如：
if (car != null) { // car是一个对象的引用
} undefined 值是由 null 值派生而来的，因此ECMA-262将它
们定义为表面上相等，如下面的例子所示：
console.log(null == undefined); // true
```



**Boolean 类型 **

Boolean （布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值： true 和 false 。这两个布尔值不同于数值，

因此 true 不等于1， false 不等于0。

```js
let found = true; let lost = false;
注意，布尔值字面量 true 和 false 是区分大小写的，因此
True 和 False （及其他大小混写形式）是有效的标识符，但不是
布尔值。
虽然布尔值只有两个，但所有其他ECMAScript类型的值都有相应
布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用
特定的 Boolean() 转型函数：
let message = "Hello world!"; let messageAsBoolean = Boolean(message);
```



**Number 类型**

ECMAScript中最有意思的数据类型或许就是 Number 了。Number 类型使用IEEE 754格式表示整数和浮点值（在某些语言中也

叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。整数也可以用八进制（以8为基数）或十六进制（以16为基数）字面量表示。对于八进制字面

量，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）。如果字面量中包含的数字超出了应有

的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数



**String 类型 **

String （字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（"）、单引号（'）或反引号（`）标示.

```js
let firstName = "John"; let lastName = 'Jacob'; let lastName = `Jingleheimerschmidt`
跟某些语言中使用不同的引号会改变对字符串的解释方式不同，
ECMAScript语法中表示字符串的引号没有区别。不过要注意的是，以
某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。比
如，下面的写法会导致语法错误：
let firstName = 'Nicholas"; // 语法错误：开头和结尾
的引号必须是同一种
```



![](C:\Users\Moon\Desktop\原型\1.png)



##### 2021-01-20阅读文章总结



**常用内置符号**

ECMAScript 6也引入了一批常用内置符号（well-knownsymbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 

Symbol 工厂函数字符串属性的形式存在。这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道 for-of 循环会在相关对象

上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义 Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。这些内置符号也没有什么

特别之处，它们就是全局函数 Symbol的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。



**操作符**

ECMA-262描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript中的操作符是独特的，因

为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf() 和 / 或 toString() 方法来取得可以计算的值。



**一元操作符**

只操作一个值的操作符叫一元操作符（unary operator）。一元操作符是ECMAScript中最简单的操作符。



**布尔操作符**

对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如果没有能力测试两个值的关系，那么像 if-else 和循环这样的语句也没什么用了。布尔操作符一共

有3个：逻辑非、逻辑与和逻辑或。

\1. 逻辑非逻辑非操作符由一个叹号（ ! ）表示，可应用给ECMAScript中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首

先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。如果操作数是对象，则返回 false 。如果操作数是空字符串，则返回 true 

。如果操作数是非空字符串，则返回 false 。如果操作数是数值0，则返回 true 。如果操作数是非0数值（包括 Infinity ），则返回false 。如果操作数是 null ，则

返回 true 。如果操作数是 NaN ，则返回 true 。



**乘性操作符**

ECMAScript定义了3个乘性操作符：乘法、除法和取模。这些操作符跟它们在Java、C语言及Perl中对应的操作符作用一样，但在处理非数值时，它们也会包含一

些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用 Number() 转型函数转换为数值。这意味着空字符串会被当成0，而布尔值 

true 会被当成1。

\1. 乘法操作符乘法操作符由一个星号（ * ）表示，可以用于计算两个数值的乘积。其语法类似于C语言，比如：let result = 34 * 56;不过，乘法操作符在处理特殊

值时也有一些特殊的行为。如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如

果ECMAScript不能表示乘积，则返回Infinity 或 -Infinity 。如果有任一操作数是 NaN ，则返回 NaN 。如果是 Infinity 乘以0，则返回 NaN 。如果是 Infinity 乘以

非0的有限数值，则根据第二个操作数的符号返回 Infinity 或 -Infinity 。如果是 Infinity 乘以 Infinity ，则返回Infinity 。如果有不是数值的操作数，则先在后台用 

Number() 将其转换为数值，然后再应用上述规则。



**除法操作符**

除法操作符由一个斜杠（ / ）表示，用于计算第一个操作数除以第二个操作数的商，比如：let result = 66 / 11;跟乘法操作符一样，除法操作符针对特殊值也有一

些特殊的行为。如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript

不能表示商，则返回 Infinity 或 -Infinity 。如果有任一操作数是 NaN ，则返回 NaN 。如果是 Infinity 除以 Infinity ，则返回 NaN 。如果是0除以0，则返回 

NaN。如果是非0的有限值除以0，则根据第一个操作数的符号返回Infinity 或 -Infinity 。如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或 

-Infinity 。如果有不是数值的操作数，则先在后台用 Number() 函数将其转换为数值，然后再应用上述规则。



**指数操作符**

ECMAScript 7新增了指数操作符， Math.pow() 现在有了自己的操作符 ** ，结果是一样的：



**加性操作符**

加性操作符，即加法和减法操作符，一般都是编程语言中最简单的操作符。不过，在ECMAScript中，这两个操作符拥有一些特殊的行为。与乘性操作

符类似，加性操作符在后台会发生不同数据类型的转换。只不过对这两个操作符来说，转换规则不是那么直观。



##### 2021-01-25阅读文章总结	

**Array**

**数组空位**

使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript会将逗号之间相应索引位置的值当成空位，ES6规范重新定义了该如何处理这

些空位。可以像下面这样创建一个空位数组

```js
const options = [,,,,,]; // 创建包含5个元素的数组
console.log(options.length); // 5
console.log(options); // [,,,,,]
```

**数组索引**

要取得或设置数组的值，需要使用中括号并提供相应值的数字索引

```js
let colors = ["red", "blue", "green"]; // 定义一个字符串数组
alert(colors[0]); // 显示第一项
colors[2] = "black"; // 修改第三项
colors[3] = "brown"; // 添加第四项
```

**检测数组**

一个经典的ECMAScript问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符。

```js
if (value instanceof Array){ // 操作数组
}
```

**迭代器方法 **

在ES6中， Array 的原型上暴露了3个用于检索数组内容的方法：keys() 、 values() 和 entries() 。 keys() 返回数组索引的迭代器， values() 返回数组元素的迭代

器，而 entries() 返回索引/值对的迭代器：

```js
const a = ["foo", "bar", "baz", "qux"]; // 因为这些方法都返回迭代器，所以可以将它们的内容
// 通过Array.from()直接转换为数组实例
const aKeys = Array.from(a.keys()); const aValues = Array.from(a.values()); const aEntries = Array.from(a.entries()); console.log(aKeys); // [0, 1, 2, 3] console.log(aValues); // ["foo", "bar", "baz", "qux"] console.log(aEntries); // [[0, "foo"], [1, "bar"],
[2, "baz"], [3, "qux"]]


使用ES6的解构可以非常容易地在循环中拆分键/值对：
const a = ["foo", "bar", "baz", "qux"];
for (const [idx, element] of a.entries()) [
    alert(idx);
    alert(element);
}
// 0 
// foo
// 1 
// bar 
// 2 
// baz 
// 3
// qux
```



**复制和填充方法**

ES6新增了两个方法：批量复制方法 fill() ，以及填充数组方法copyWithin() 。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索

引，不包含结束索引。使用这个方法创建的数组不能缩放。使用 fill() 方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，

它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引：

```js
const zeroes = [0, 0, 0, 0, 0]; // 用5填充整个数组
zeroes.fill(5); console.log(zeroes); // [5, 5, 5, 5, 5] zeroes.fill(0); // 重置
// 用6填充索引大于等于3的元素
zeroes.fill(6, 3); console.log(zeroes); // [0, 0, 0, 6, 6] zeroes.fill(0); // 重置
// 用7填充索引大于等于1且小于3的元素
zeroes.fill(7, 1, 3); console.log(zeroes); // [0, 7, 7, 0, 0]; zeroes.fill(0); // 重置
// 用8填充索引大于等于1且小于4的元素
// (-4 + zeroes.length = 1)
// (-1 + zeroes.length = 4)
zeroes.fill(8, -4, -1); console.log(zeroes); // [0, 8, 8, 8, 0];
```

fill() 静默忽略超出数组边界、零长度及方向相反的索引范围：

```js
const zeroes = [0, 0, 0, 0, 0]; // 索引过低，忽略
zeroes.fill(1, -10, -6); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引过高，忽略
zeroes.fill(1, 10, 15); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引反向，忽略
zeroes.fill(2, 4, 2);
console.log(zeroes); // [0, 0, 0, 0, 0] // 索引部分可用，填充可用部分 zeroes.fill(4, 3, 10) console.log(zeroes); // [0, 0, 0, 4, 4]
```

**转换方法**

前面提到过，所有对象都有 toLocaleString() 、 toString() 和 valueOf() 方法。其中， valueOf() 返回的还是数组本身。而toString() 返回由数组中每个值的等效字

符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其 toString() 方法，以得到最终的字符串。

```js
let colors = ["red", "blue", "green"]; // 创建一个包含
3个字符串的数组
alert(colors.toString()); 

// red,blue,green alert(colors.valueOf()); 
// red,blue,green alert(colors);
// red,blue,green
```

**栈方法**

ECMAScript给数组提供几个方法，让它看起来像是另外一种数据结构。数组对象可以像栈一样，也就是一种限制插入和删除项的数据结构。栈是一种后进先出

（LIFO，Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个地方发生，即栈

顶。ECMAScript数组提供了 push() 和 pop() 方法，以实现类似栈的行为。push() 方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。 

pop() 方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。

```js
let colors = new Array(); // 创建一个
数组
let count = colors.push("red", "green"); // 推入两项
alert(count); // 2 count = colors.push("black"); // 再推入一项
alert(count); // 3 let item = colors.pop(); // 取得最后一项
alert(item); // black alert(colors.length);
```

**队列方法**

就像栈是以LIFO形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。

因为有了在数据末尾添加数据的 push() 方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫shift() ，它会删除数组的第一项并返回

它，然后数组长度减1。使用shift() 和 push() ，可以把数组当成队列来使用：

```js
let colors = new Array(); // 创建一个
数组
let count = colors.push("red", "green"); // 推入两项
alert(count); // 2 count = colors.push("black"); // 再推入一项
alert(count); // 3 let item = colors.shift(); // 取得第一项
alert(item); // red alert(colors.length); // 2
```

**排序方法**

数组有两个方法可以用来对元素重新排序： reverse() 和 sort() 。顾名思义， reverse() 方法就是将数组元素反向排列。

```js
let values = [1, 2, 3, 4, 5]; 
values.reverse(); 
alert(values); // 5,4,3,2,1
```

**基本API**

使用 new 关键字和 Map 构造函数可以创建一个空映射：const m = new Map();如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需

要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中：

```js
// 使用嵌套数组初始化映射
const m1 = new Map([ ["key1", "val1"], ["key2", "val2"], ["key3", "val3"] ]); alert(m1.size); // 3 // 使用自定义迭代器初始化映射 const m2 = new Map({ [Symbol.iterator]: function*() { yield ["key1", "val1"]; yield ["key2", "val2"]; yield ["key3", "val3"]; } }); alert(m2.size); // 3
// 映射期待的键/值对，无论是否提供
const m3 = new Map([[]]); alert(m3.has(undefined)); // true alert(m3.get(undefined)); // undefined
```

**顺序与迭代 **

与 Object 类型的一个主要差异是， Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。映射实例可以提供一个迭代器（ Iterator ），能以

插入顺序生成[key, value] 形式的数组。可以通过 entries() 方法（或者Symbol.iterator 属性，它引用 entries() ）取得这个迭代器：

```js
const m = new Map([ ["key1", "val1"], ["key2", "val2"], ["key3", "val3"]
]); alert(m.entries === m[Symbol.iterator]); // true for (let pair of m.entries()) { alert(pair); }// [key1,val1] // [key2,val2] // [key3,val3] for (let pair of m[Symbol.iterator]()) { alert(pair); }// [key1,val1] // [key2,val2] // [key3,val3]
```

**弱键 **

WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱

地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。

```js
const wm = new WeakMap();
wm.set({}, "val");
```

**顺序与迭代 **

Set 会维护值插入时的顺序，因此支持按顺序迭代。集合实例可以提供一个迭代器（ Iterator ），能以插入顺序生成集合内容。可以通过 values() 方法及其别名方

法 keys() （或者Symbol.iterator 属性，它引用 values() ）

```js
const s = new Set(["val1", "val2", "val3"]); alert(s.values === s[Symbol.iterator]); // true alert(s.keys === s[Symbol.iterator]); // true for (let value of s.values()) { alert(value); }// val1 // val2
// val3 for (let value of s[Symbol.iterator]()) { alert(value); }// val1 // val2 // val3
```



