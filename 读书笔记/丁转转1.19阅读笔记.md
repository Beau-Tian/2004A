## 一。变量、作用域与内存

#### 1、什么是作用域

一段代码在程序中起作用的范围。分为全局作用域和局部作用域。

#### 2、变量的作用域链

根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。 当内部函数访问变量时就形在了作用域链，查找变量时优先查找函数内部的变量，如果找到了就使用该变量，如果找不到向父级查找，最后找到window,如果window没有这个变量，则报错

#### 3、 垃圾回收机制的方式及内存管理

​      1、标记清除

​     2、引用计数

​     内存管理：1.全局变量和全局对象通过解除引用回收

​                          2.局部变量离开执行环境时自动回收

###  js执行上下文栈/作用域

自己理解的：

代码执行或函数调用生成执行上下文(只有当前执行上下文有执行权),该执行上下文内只能访问当前执行上下文的变量、函数和上一级执行上下文中的变量、函数,激活下一个执行上下文的时候执行权转移到新的执行上下文,“形成执行上下文栈。作用域是当前执行上下文中能访问的变量、函数的集合,执行上下文中只能访问当前作用域和其上执行上下文的作用域,由此形成作用域链

上下文栈：1.代码执行或函数调用生成执行上下文栈

​     2.该执行上下文栈只能访问本栈和上一个栈

​     3.激活新栈，执行权转移新栈，这样就形成了执行上下文栈

作用域：

1.根据在内部函数可以访问外部函数变量的这种机制，当内部函数访问	变量时就形在了作用域链

2.查找变量时优先查找函数内部的变量，如果找到了就使用该变量，如	果找不到向父级查找

3.最后找到window,如果window没有这个变量，则报错

### 1.原始值与引用值

ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（referencevalue）则是由多个值构成的对象。在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。上一章讨论了6种原始值： Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。引用值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。

**注意：在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。**

### 2.动态属性

在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来

### 3.传递参数

ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用ECMAScript的话说，就是 arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。（这在ECMAScript中是不可能的。

### 4.确定类型

typeof 操作符最适合用来判断一个变量是否为原

始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔

值或 undefined 的最好方式。如果值是对象或 null ，那么

typeof 返回 "object" ，如下面的例子所示：

```java
let s = "Nicholas"; 
let b = true;
let i = 22;
let u; 

let n = null; 

let o = new Object(); 

console.log(typeof s); *// string* 

console.log(typeof i); *// number* 

console.log(typeof b); *// boolean* 

console.log(typeof u); *// undefined* 

console.log(typeof n); *// object* 

console.log(typeof o); *// object* 
```

### 5.变量

var：使用 var 的函数作用域声明在使用 var 声明变量时，变量会被自动添加到最接近的上下

文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文

let：ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号 {} 界定。换句话说， if 块、 while 块、function

块，甚至连单独的块也是 let 声明变量的作用域。let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出SyntaxError

const：除了 let ，ES6同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值，const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制，由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。

#### 6.变量提升和暂时性死区

变量提升现象：即变量可以在声明之前使用，值为undefined。
var 命令会发生“变量提升”现象；let 命令不存在“变量提升”。

```json
// var 的情况
console.log(foo);  // 输出 undefined
var foo = 2;
// let 的情况
console.log(bar); // 输出 ReferenceError
let bar = 2;

```

暂时性死区：ES6 明确规定，如果区块中存在 let 和 const 命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前使用这些变量，就会报错。这种语法称为“暂时性死区”（temporal dead zone，简称TDZ）。

```
var tmp = 123;
if (true) {
	// TDZ 开始
	tmp = 'abc';   // ReferenceError
	let tmp;   // TDZ 结束
}
```

#### 7.var、let、const的区别

1.var声明的变量存在变量提升，值为：undefined。允许重复声明变量，var和let可以修改已经声明的变量
2.let和const不存在变量提升。但是存在暂时性死区和块级作用域
（暂时性死区：在代码块内，let命令声明之前，该变量都是不可用的）
（块级作用域是由{ }包裹的，if语句和for语句里的{ }也属于块作用域）
3.const声明一个只读的常量，值不能改变。（引用数据类型可以改变内部的值）

## 总结

JavaScript变量可以保存两种类型的值：原始值和引用值。

原始值可能是以下6种原始数据类型之一： Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有以下特点。

原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。

引用值是对象，存储在堆内存上。包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。

从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。

typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。

任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。

执行上下文分全局上下文、函数上下文和块级上下文。

代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。

函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。

全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。

变量的执行上下文用于确定什么时候释放内存。JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript的垃圾回收程序可以总结如下。

离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。

引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。

JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素）。

引用计数在代码中存在循环引用时会出现问题。

解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。