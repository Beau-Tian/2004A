## 什么是JavaScript

```
     1995年，JavaScript问世,那时候主要是代替Perl等服务端语言处理输入验证,网景公司希望通过在其Navigator浏览器中加入JavaScript来改变这个局面,JavaScript逐渐成为市面上所有主流浏览器的标配。如今，JavaScript的应用也不再局限于据验证，而是渗透到浏览器窗口及其内容的方方面面。JavaScript已被公认为主流的编程语言，能够实现复杂的计算与交互，括闭包、匿名（lambda）函数，甚至元编程等特性。不仅是桌面浏览器，手机浏览器和屏幕阅读器也支持JavaScript，其重要性可见一斑。就连拥有自家客户端脚本语言VBScript的微软公司，也在其Internet Explorer（以下简称IE）浏览器最初的版本中包含了自己的JavaScript实现。
    javascript实现包含以下几个部分:  核心(ECMAScript)  文档对象模型(DOM)  浏览器对象模型(BOM)
    JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。ECMAScript:由ECMA-262定义并提供核心功能。文档对象模型（DOM）：提供与网页内容交互的方法和接口。浏览器对象模型（BOM）：提供与浏览器交互的方法和接口。
    JavaScript的这三个部分得到了五大Web浏览器（IE、Firefox、Chrome、Safari和Opera）不同程度的支持。所有浏览器基本上对ES5（ECMAScript 5）提供了完善的支持，而对ES6（ECMAScript 6）和ES7（ECMAScript 7）的支持度也在不断提升。这些浏览器对DOM的支持各不相同，但对Level 3的支持日益趋于规范。HTML5中收录的BOM会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共特性。
```

### <script> 元素

```
将JavaScript插入HTML的主要方法是使用 <script> 元素。这个元素是由网景公司创造出来，并最早在Netscape Navigator 2中实现的。后来，这个元素被正式加入到HTML规范。 <script> 元素有下列8个属性:
     1.async ：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。
     2.charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
     3.crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin="anonymous" 配置文件请求不必设置凭据标志。crossorigin="use-credentials" 设置凭据标志，意味着出站请求会包含凭据。
	4.defer ：可选。表示在文档解析和显示完成后再执行脚本是没有问题的。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。
	5.integrity ：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Intergrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。
	6.language ：废弃。最初用于表示代码块中的脚本语言（如 "JavaScript" 、 "JavaScript1.2" 或 "VBScript" ）。大多数浏览器都会忽略这个属性，不应该再使用它。
	7.src ：可选。表示包含要执行的代码的外部文件。
	8.type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。按照惯例，这个值始终都是 "text/javascript" ，尽管 "text/javascript" 和 "text/ecmascript" 都已经废弃。
```



```
   JavaScript是通过<script>元素插入到HTML页面中的。这个元素可用于把JavaScript代码嵌入到HTML页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的JavaScript。
   本章的重点可以总结如下。要包含外部JavaScript文件，必须将src属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。所有<script>元素会依照它们在网页中出现的次序被解释。在不使用defer和async属性的情况下，包含在<script>元素中的代码必须严格按次序解释。对不推迟执行的脚本，浏览器必须解释完位于<script>元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把<script>元素放到页面末尾，介于主内容之后及</body>标签之前。
   可以使用defer属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本总是按照它们被列出的次序执行。可以使用async属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。
   通过使用<noscript>元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则<noscript>元素中的任何内容都不会被渲染。
```

```
	JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没有提供获得输入和产生输出的机制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的关键。
	下面总结一下ECMAScript中的基本元素。ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number、String和Symbol。与其他语言不同，ECMAScript不区分整数和浮点值，只有Number一种数值数据类型。Object是一种复杂数据类型，它是这门语言中所有对象的基类。严格模式为这门语言中某些容易出错的部分施加了限制。
	ECMAScript提供了C语言和类C语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如if语句、for语句和switch语句等。			ECMAScript中的函数与其他语言中的函数不一样。不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。不指定返回值的函数实际上会返回特殊值undefined。
```

### 区分大小写：

```
首先要知道的是，ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量test和变量Test是两个不同的变量。类似地，typeof不能作为函数名，因为它是一个关键字（后面会介绍）。但Typeof是一个完全有效的函数名。
```

### 标识符：

```
  	所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：第一个字符必须是一个字母、下划线（_）或美元符号（$）；剩下的其他字符可以是字母、下划线、美元符号或数字。
注意关键字、保留字、true、false和null不能作为标识符。
```

### 注释：

```
单行注释：块注释以一个斜杠和一个星号（/*）开头，以它们的反向组合（*/）结尾
多行注释：/*这是多行注释*/
```

### 严格模式：

```
	严格模式是一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行："usestrict"; 
	所有现代浏览器都支持严格模式。
```

### 语句：

```
ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾
	if之类的控制语句只在执行多条语句时要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即使要执行的只有一条语句
	在控制语句中使用代码块可以让内容更清晰，在需要修改代码时也可以减少出错的可能性。
```

### 变量：

```
	每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：var、const和let。其中，var在ECMAScript的所有版本中都可以使用，而const和let只能在ECMAScript 6及更晚的版本中使用。
	
var关键字：
	要定义变量，可以使用var操作符（注意var是一个关键字），后跟变量名（即标识符，如前所述）：varmessage;
	var声明作用域：使用var操作符定义的变量会成为包含它的函数的局部变量。比如，使用var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁
	在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出ReferenceError。
	 var声明提升：使用var时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部
	---------------------------------------------------------------
let声明：
	let跟var的作用差不多，但有着非常重要的区别。最明显的区别是，let声明的范围是块作用域，而var声明的范围是函数作用域。let也不允许同一个块作用域中出现冗余声明。这样会导致报错
对声明冗余报错不会因混用let和var而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。
====================================================
	暂时性死区let与var的另一个重要的区别，就是let声明的变量不会在作用域中被提升。
====================================================
	全局声明与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）。
	let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。
	
	 条件声明在使用var声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为let的作用域是块，所以不可能检查前面是否已经使用let声明过同名变量，同时也就不可能在没有声明的情况下声明它。
	 使用try/catch语句或typeof操作符也不能解决，因为条件块中let声明的作用域仅限于该块。
------------------------------------------------------------------	 
	 for循环中的let声明在let出现之前，for循环定义的迭代变量会渗透到循环体外部
------------------------------------------------------------------ 
	 const声明：
	 const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误。
	 const声明的限制只适用于它指向的变量的引用。换句话说，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制。
	 即使JavaScript引擎会为for循环中的let声明分别创建独立的变量实例，而且const变量跟let变量很相似，也不能用const来声明迭代变量（因为迭代变量会自增）

总结：1. 不使用var有了let和const，大多数开发者会发现自己不再需要var了。限制自己只使用let和const有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。2. const优先，let次之使用const声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用const来声明变量，只在提前知道未来会有修改时，再使用let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。
```

## 数据类型：

```
ECMAScript有6种简单数据类型（也称为原始类型）
	Undefined、Null、Boolean、Number、String和Symbol。Symbol（符号）是ECMAScript 6新增的。
	还有一种复杂数据类型叫Object（对象）。Object是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用
```

### typeof操作符：

```
	因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。对一个值使用typeof操作符会返回下列字符串之一
	"undefined"表示值未定义；"boolean"表示值为布尔值；"string"表示值为字符串；"number"表示值为数值；"object"表示值为对象（而不是函数）或null；"function"表示值为函数；"symbol"表示值为符号。
	注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeofnull返回的是"object"。这是因为特殊值null被认为是一个对空对象的引用。
	函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象。
```

### 操作符：

```
	描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。
	一元操作符只操作一个值的操作符叫一元操作符（unary operator）。一元操作符是ECMAScript中最简单的操作符。
	递增/递减操作符递增和递减操作符直接照搬自C语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加1，把两个加号（++）放到变量前头即可
	================================
	一元加和减一元加和减操作符对大多数开发者来说并不陌生，它们在ECMAScript中跟在高中数学中的用途一样。一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响：如果将一元减应用到非数值，则会执行与使用Number()转型函数一样的类型转换：布尔值false和true转换为0和1，字符串根据特殊规则进行解析，对象会调用它们的valueOf()和/或toString()方法以得到可以转换的值。
```

### if语句：

```
		这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript会自动调用Boolean()函数将这个表达式的值转换为布尔值。如果条件求值为true，则执行语句statement1；如果条件求值为false，则执行语句statement2。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。
```

### do-while语句：

```
do-while语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。
```

### while语句：

```
	while语句是一种先测试：循环语句，即先检测退出条件，再执行循环体内的代码。因此，while循环体内的代码有可能不会执行。
```

### for语句：

```
	for语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式
```

### for-in语句：

```
	for-in语句是一种严格的迭代语句，用于枚举对象中的非符号键属性			ECMAScript中对象的属性是无序的，因此for-in语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。如果for-in循环要迭代的变量是null或undefined，则不执行循环体。
```

### for-of语句：

```
for-of语句是一种严格的迭代语句，用于遍历可迭代对象的元素
for-of循环会按照可迭代对象的next()方法产生值的顺序迭代元素。关于可迭代对象
```

### 标签语句：

```
	标签语句用于给语句加标签，语法如下：label:statement下面是一个例子：start:for(leti=0;i<count;i++){console.log(i);}在这个例子中，start是一个标签，可以在后面通过break或continue语句引用。标签语句的典型应用场景是嵌套循环。
```

### break和continue语句：

```
	break和continue语句为执行循环代码提供了更严格的控制手段。其中，break语句用于立即退出循环，强制执行循环后的下一条语句。而continue语句也用于立即退出循环，但会再次从循环顶部开始执行。
	outermost标签标识的是第一个for语句。正常情况下，每个循环执行10次，意味着num++语句会执行100次，而循环结束时console.log的结果应该是100。但是，break语句带来了一个变数，即要退出到的标签。添加标签不仅让break退出（使用变量j的）内部循环，也会退出（使用变量i）的外部循环。当执行到i和j都等于5时，循环停止执行，此时num的值是55。continue语句也可以使用标签
	
	组合使用标签语句和break、continue能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。
```

### with语句：

```
	ith语句的用途是将代码作用域设置为特定的对象，其语法是：with(expression)statement;使用with语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利
	with语句用于连接location对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索location对象，看它是否有一个同名的属性。如果有，则该变量会被求值为location对象的属性。
	
	严格模式不允许使用with语句，否则会抛出错误。
```

### switch语句：

```
	switch语句是与if语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript中switch语句跟C语言中switch语句的语法非常相似
	switch(expression){casevalue1:statementbreak;casevalue2:statementbreak;casevalue3:statementbreak;casevalue4:statementbreak;default:statement}
	
	为避免不必要的条件判断，最好给每个条件后面都加上break语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了break
```

### 函数：

```
	函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript中的函数使用function关键字声明，后跟一组参数，然后是函数体。
	
	基本语法：functionfunctionName(arg0,arg1,...,argN){statements}
	
	可以通过函数名来调用函数，要传给函数的参数放在括号里（如果有多个参数，则用逗号隔开）。
	ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用return语句来返回函数的值，用法是后跟要返回的值。
	要注意的是，只要碰到return语句，函数就会立即停止执行并退出。因此，return语句后面的代码不会被执行。
	
	严格模式对函数也有一些限制：函数不能以eval或arguments作为名称；函数的参数不能叫eval或arguments；两个函数的参数不能叫同一个名称。如果违反上述规则，则会导致语法错误，代码也不会执行。
```

### 小结：

```
	JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没有提供获得输入和产生输出的机制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的关键。下面总结一下ECMAScript中的基本元素。ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number、String和Symbol。
	与其他语言不同，ECMAScript不区分整数和浮点值，只有Number一种数值数据类型。Object是一种复杂数据类型，它是这门语言中所有对象的基类。严格模式为这门语言中某些容易出错的部分施加了限制。ECMAScript提供了C语言和类C语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如if语句、for语句和switch语句等。ECMAScript中的函数与其他语言中的函数不一样。不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。不指定返回值的函数实际上会返回特殊值undefined。
```

## 变量、作用域与内存：

### 原始值与引用值：

```
	变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（referencevalue）则是由多个值构成的对象。
	引用值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。
	只有引用值可以动态添加后面可以使用的属性。
	原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个Object类型的实例，但其行为类似原始值。
```

### 复制值：

```
	把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来
```

### 传递参数：

```
	ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。
	ECMAScript中函数的参数就是局部变量。
```

### 确定类型：

```
	typeof操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined的最好方式。如果值是对象或null，那么typeof返回"object"，
	-------------------------------------------------------------------------------------------------
	typeof虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript提供了instanceof操作符
				result=variableinstanceofconstructor
-------------------------------------------------------------------------------------
	typeof操作符在用于检测函数时也会返回"function"。当在Safari（直到Safari 5）和Chrome（直到Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回"function"。ECMA-262规定，任何实现内部[[Call]]方法的对象都应该在typeof检测时返回"function"。因为上述浏览器中的正则表达式实现了这个方法，所以typeof对正则表达式也返回"function"。在IE和Firefox中，typeof对正则表达式返回"object"。
```

### 执行上下文与作用域：

```
	执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object）
	每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。
	上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。
	代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activationobject）用作变量对象。
	函数changeColor()的作用域链包含两个对象：一个是它自己的变量对象（就是定义arguments对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在作用域链中找到它。
	函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。
```

## 第5章基本引用类型

```
理解对象:引用值或对象是某个特定引用类型的实例，在ECMASscipt中，引用类型是吧数据和功能组织到一起的结构，经常被人错误的称作为“类”。引用类型虽然有点像类，但跟类并不是一个概念。
```

### Date：

```
	第一点要创建日期对象，就使用new操作符来调用Date构造函数，
	第二点在不给Date构造函数传参数的情况下，创建的对象将保存当前日期和时间。
	Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。
	Date.parse()应该支持的日期格式，填充了第3版遗留的空白。所有实现都必须支持下列日期格式
	注意：ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如2019-05-23T00:00:00（只适用于兼容ES5的实现）。
	如果传给Date.parse()的字符串并不表示日期，则该方法会返回NaN。如果直接把表示日期的字符串传给Date构造函数，那么Date会在后台调用Date.parse()。
	
	继承的方法：
	Date类型的toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。
```

### 日期格式化方法：

```
Date类型有几个专门用于格式化日期的方法，它们都会返回字符串:
toDateString()显示日期中的周几、月、日、年（格式特定于实现）；
toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；
toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；
toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现）；
toUTCString()显示完整的UTC日期（格式特定于实现）。
------------------------
还有一个方法叫toGMTString()，这个方法跟toUTCString()是一样的，目的是为了向后兼容。不过，规范建议新代码使用toUTCString()。
```

#### 获取日期对象的方法

   -    getFullYear()	从 Date 对象以四位数字返回年份。
        - getMonth()	从 Date 对象返回月份 (0 ~ 11)。
        - getDate()	从 Date 对象返回一个月中的某一天 (1 ~ 31)。
        - getDay()	从 Date 对象返回一周中的某一天 (0 ~ 6)。 
        - getHours()	返回 Date 对象的小时 (0 ~ 23)。
        - getMinutes()	返回 Date 对象的分钟 (0 ~ 59)。
        - getSeconds()	返回 Date 对象的秒数 (0 ~ 59)。 
        - getMilliseconds()	返回 Date 对象的毫秒(0 ~ 999)。 煤勒赛啃滋
        - getTime()	 返回 1970 年 1 月 1 日 至今的毫秒数。

​     

#### 设置日期对象的方法

   - setFullYear()	设置 Date 对象中的年份（四位数字）。
   - setMonth()	设置 Date 对象中月份 (0 ~ 11)。
   - setDate()	设置 Date 对象中月的某一天 (1 ~ 31)。
   - setHours()	设置 Date 对象中的小时 (0 ~ 23)。
   - setMinutes()	设置 Date 对象中的分钟 (0 ~ 59)。
   - setSeconds()	设置 Date 对象中的秒钟 (0 ~ 59)。
   - setMilliseconds()	设置 Date 对象中的毫秒 (0 ~ 999)。
   - setTime() 方法以毫秒设置 Date 对象。

#### 日期对象转换为字符串的方法

   - toLocaleString()	   据本地时间格式，把 Date 对象转换为字符串。
   - toString()	          把 Date 对象转换为字符串。

#### 定时器 

```
setInterval()  //间歇调用；就是每隔一段时间调用一次-间隙性计时器
   // 按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。

    setTimeout()   //延迟调用；指定的时间后调用一次，只调用一次   在指定的毫秒数后调用函数或计算表达式。一次性计时器    
    
    清除计时器的方法
        clearInterval("要清除的定时器名")
        clearTimeout("要清除的定时器名")

    语法：setInterval(code,millisec,lang)     
		 setTimeout(code,millisec,lang)
   code	    //必需。要调用的函数或要执行的代码串。
   millisec	//必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。
   lang	    //可选。 JScript | VBScript | JavaScript
```



## 正则：

#### -- 基本概念

- 字符串匹配，查询，替换的一种模式，外表风骚，内功强大。
- 表达式的结构
- 正则表达式结构/修饰符` 比如 `/\d{12}/g`
- g 全局匹配 global  hello world
- i 忽略大小写 ignore

### -- 正则的创建方法

字面量方式 

```
var rep = /^1[34578]\d{9}$/
```

构造函数形式

```
 var rep = new RegExp("表达式","修饰符")
 //比如下面匹配一个手机号
 var rep = new RegExp("^1[34578]\d{9}$");
```

JS 字符串中可以使用正则表达式的三个函数

```js
 string.replace("正则表达式","要替换的对象")
 string.match("正则表达式")
 string.search("正则表达式")
```

test方法（用来验证）

```js
  var rep = /正则表达式/g
  rep.test(要验证的字符串); //结构返回true或者false
```

exec方法（用来验证）

```js
var rep = /正则表达式/g
rep.test(要验证的字符串) //结构返回true或false
```

常用的元字符：

```js
 [abc] //匹配方框号中的任意一个字符
            [^abc] //除了abc以外的所有的字符
            [0-9] //匹配0-9之间数字
            [a-z] //匹配所有的大写字母
            [0-9a-zA-Z] //匹配大小写字母和数字
            [A-z] //匹配所有的大小写字母  [A-Za-z]
            (红色|蓝色|绿色)  //匹配红色，蓝色绿色
            [\u4e00-\u9fa5] //中文汉字
             
            .  //匹配任意字符
            \w //匹配任意字母数字下划线 或 [A-Za-z0-9_]
            \W //匹配非字母数字下划线
            \d //匹配所有数字  [0-9]
            \D //匹配非数字
            \s //匹配空格字符
            \S //匹配非空格字符
```

常用的(写好的)

```js
   1.只能是中文 长度为2-7位
		 /^([\u4e00-\u9fa5]){2,7}$/
        2.长度为8到18位的小写大写字母或数字或下划线 【重要】
            /^[a-zA-Z0-9_]{8,18}$/
        3.正确的邮箱格式 【重要】
            /^\w+@[a-z0-9]{2,5}\.(com|cn|net|org)$/
            /^[A-z0-9_-]+@[a-z0-9]{2,5}\.[a-z]{2,3}$/
        4.正确的手机号【重要】
            /^1(3|4|5|7|8)\d{9}$/
        5.正确的身份证号:
            /^\d{15}|\d{17}([0-9]|x)/
            /^[1-9][0-9]{16}[0-9x]$/
        6.正确的qq号
            /[1-9][0-9]{4,}/
        7.正确的电话号码格式 【重要】
            /^0[0-9]{2}-[0-9]{8}|0[0-9]{3}-[0-9]{7}$/
            
        8. 过滤空白 /\s+/g
        9. 过滤首尾空格  str.trim()
        10. 匹配任意8-18之间的大小写字母数字构成的密码
            /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,18}$/
```

## 第6章集合引用类型

### 本章内容

```
##### 对象

##### 数组与定型数组

##### Map、WeakMap、Set以及WeakSet类型
```

### Object

```js
	显式地创建Object的实例有两种方式。第一种是使用new操作符和Object构造函数
letperson=newObject();
person.name="Nicholas";
person.age=29;
	另一种方式是使用对象字面量（object literal）表示法:
letperson={name:"Nicholas",age:29};数值属性会自动转换为字符串。
	对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：
    letperson={};//与newObject()相同person.name="Nicholas";person.age=29;

总结：
	虽然使用哪种方式创建Object实例都可以，但实际上开发者更倾向于使用对象字面量表示法。这是因为对象字面量代码更少，看起来也更有封装所有相关数据的感觉。
<<<<<<< HEAD
```

### Array

```
	数组一般是由中括号包裹，元素之间使用逗号分隔，数组的长度也就是数组中元素的个数使用length获取，数组中具有索引下标，它们是
  从0开始的，通过对应的索引下标可以取到元素中对应的值。
  数组中的元素可以是js中任意数据类型的值
  当数组对象指定长度时，我们也可以存储多余这个长度的元素
```

数组的创建方式：

```js
1. 使用字面量的方式创建  
 var arr = [10,20.30,true,"Hello",new Date(),function(){},[12,12,34],Math.random(),null,undefined]
 2. 使用new关键字来创建一个对象   
  var arr = new Array(12,34,"hello")                           var arr = new Array(5);
```

```js
 数组定义的两种方式
     var  arr = [1,2,3];
     var  arr1 = new Array(1,2,3);

数组的属性：length 设置或返回数组中元素的数目；
max-最大的  min-最小的  average-平均  sort-排序(从左往右-从小到大) 
#### 访问数组
  - 数组名[下标]
  - 关于下标： 下标从0开始，到arr.length-1
  - 读取数组中的元素  console.log(arr[下标])
  - 修改数组中的元素  arr[下标] = 'xxxx';
#### 数组的属性 length
长度  返回数组中元素的个数   - 具体有几个元素
max-最大的  min-最小的  average-平均  sort-排序(从左往右-从小到大) 
```

```js
数组的遍历:
-----for    
for (var i = 0; i < arr.length; i++) 
     {
       console.log(arr[i]) 
     }

-----for/in   
 for(var i in arr)
       { 
          console.log(arr[i]) 
       
       }
```

```js
   向数组中添加和删除的方法：
    
    push()向数组的末尾添加一个或更多元素，并返回新的数组长度。
    unshift()向数组的开头添加一个或更多元素，并返回新的长度
    shift()删除并返回数组的第一个元素。  //无参数    
    pop()删除数组的最后一个元素并返回删除的元素。 // 无参数
    splice()从数组中添加或删除元素 或者替换元素
           参数1： 下标    
           参数2： 数量
           参数3...4...5 添加的元素
           // 返回的是删除的元素---数组
    注意：添加和删除的方法，改变了原数组的长度和元素
    
    
concat()拼接一个或多个数组;返回拼接后的数组    
join()根据指定的分隔符（seperator）进行切割，返回一个字符串,参数缺省以逗号作为分隔符 (数组连接成字符串)
slice()选取数组的的一部分，并返回一个新数组 获取数组中部分元素并返回：  不会影响原数组(截取)

  // 以上三个方法不会影响原数组


与索引相关的方法： 
indexOf()匹配要查找的元素在数组中第一次出现的索引位置 ,array.indexOf(item,start)
lastIndexOf()  匹配要查找的元素在数组中最后一次出现的索引位置 
   注意：以上两个方法去查找元素，如果找不到，返回-1
   //  第二个参数默认省略, 如果有，下标
includes()  包含 数组中是否包含某个值   true   false

//不会影响原数组
reverse() 反转数组的元素顺序 ; 改变了原数组的顺序  (原来的数组发生变化)
sort()//排序 ---  影响原数组   默认升序


1. instanceof   arr instanceof Array
2. isArray()    Array.isArray(arr)   //// 如果是数组返回结果是true ,否则false 
=======
```

 new操作符

```js
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29;
```

### Array

```
	数组一般是由中括号包裹，元素之间使用逗号分隔，数组的长度也就是数组中元素的个数使用length获取，数组中具有索引下标，它们是
  从0开始的，通过对应的索引下标可以取到元素中对应的值。
  数组中的元素可以是js中任意数据类型的值
  当数组对象指定长度时，我们也可以存储多余这个长度的元素
```

数组的创建方式：

```js
1. 使用字面量的方式创建  
 var arr = [10,20.30,true,"Hello",new Date(),function(){},[12,12,34],Math.random(),null,undefined]
 2. 使用new关键字来创建一个对象   
  var arr = new Array(12,34,"hello")                           var arr = new Array(5);
```

```js
 数组定义的两种方式
     var  arr = [1,2,3];
     var  arr1 = new Array(1,2,3);

数组的属性：length 设置或返回数组中元素的数目；
max-最大的  min-最小的  average-平均  sort-排序(从左往右-从小到大) 
#### 访问数组
  - 数组名[下标]
  - 关于下标： 下标从0开始，到arr.length-1
  - 读取数组中的元素  console.log(arr[下标])
  - 修改数组中的元素  arr[下标] = 'xxxx';
#### 数组的属性 length
长度  返回数组中元素的个数   - 具体有几个元素
max-最大的  min-最小的  average-平均  sort-排序(从左往右-从小到大) 
```

```js
数组的遍历:
-----for    
for (var i = 0; i < arr.length; i++) 
     {
       console.log(arr[i]) 
     }

-----for/in   
 for(var i in arr)
       { 
          console.log(arr[i]) 
       
       }
```

```js
   向数组中添加和删除的方法：
    
    push()向数组的末尾添加一个或更多元素，并返回新的数组长度。
    unshift()向数组的开头添加一个或更多元素，并返回新的长度
    shift()删除并返回数组的第一个元素。  //无参数    
    pop()删除数组的最后一个元素并返回删除的元素。 // 无参数
    splice()从数组中添加或删除元素 或者替换元素
           参数1： 下标    
           参数2： 数量
           参数3...4...5 添加的元素
           // 返回的是删除的元素---数组
    注意：添加和删除的方法，改变了原数组的长度和元素
    
    
concat()拼接一个或多个数组;返回拼接后的数组    
join()根据指定的分隔符（seperator）进行切割，返回一个字符串,参数缺省以逗号作为分隔符 (数组连接成字符串)
slice()选取数组的的一部分，并返回一个新数组 获取数组中部分元素并返回：  不会影响原数组(截取)

  // 以上三个方法不会影响原数组


与索引相关的方法： 
indexOf()匹配要查找的元素在数组中第一次出现的索引位置 ,array.indexOf(item,start)
lastIndexOf()  匹配要查找的元素在数组中最后一次出现的索引位置 
   注意：以上两个方法去查找元素，如果找不到，返回-1
   //  第二个参数默认省略, 如果有，下标
includes()  包含 数组中是否包含某个值   true   false

//不会影响原数组
reverse() 反转数组的元素顺序 ; 改变了原数组的顺序  (原来的数组发生变化)
sort()//排序 ---  影响原数组   默认升序


1. instanceof   arr instanceof Array
2. isArray()    Array.isArray(arr)   //// 如果是数组返回结果是true ,否则false 

```

基本排序算法其核心思想是指对一组数据按照一定的顺序重新排列。
    重新排列时用到的技术是一组嵌套的for循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。

这些算法非常逼真的模拟了人类在现实生活中对数据的排序，例如纸牌玩家在处理手中的纸牌时对纸牌进行排序，
或者教师按照字母顺序或者分数对试卷进行排序。

#####  冒泡排序：

最慢的排序算法之一，也是最容易实现的排序算法

数组值会像气泡一样从数组的一端漂浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小的值 则会浮动到数组的左侧。

原因是因为算法会多次在数组中移动，比较相邻的数据，当左侧值大于右侧值时它们进行互换。

#####  选择排序算法 

​      选择排序从数组的开头开始，将第一个元素和其他元素进行比较。
​      检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从第二个位置继续。这个过程一直进行，
​      当进行到数组的倒数第二个位置时所有的数组便完成了排序。

## 第8章对象、类与面向对象编程

本章内容:

```
1理解对象
2理解对象创建过程
3理解继承
4理解类
```

### 理解对象

```
	举个栗子，比如一台笔记本电脑，我们将它视为一个对象无非是为了能够更加抽象地描述它，这在编程的过程中很重要，来看看它有哪些需要抽象出来的特性吧~
    在生活中大家应该很熟悉，当你在买一台新的笔记本电脑时，主要考虑的是什么？———笔记本电脑的屏幕大小、屏幕形状、机身总重量、硬盘空间、CPU频率、操作系统……这些都是“笔记本电脑”这个对象所固有的一些性能或制造的参数，这些可以标识出这台笔记本电脑是否受到顾客的欢迎。
    但是，对于现实世界中的一台洗衣机，要考虑的特性就完全不是上面的那些参数和特性了，更多的是会去关注它的容积、耗电量、噪音大小等。还有，对于一架航天飞机，它要考虑的特性会更多，对于一支钢笔，一把伞，针对它们要考虑的就会相对要少一些……从这些例子来看，世间万物的复杂程度不同，我们对它们的关心方面就不同，相应地从它们这些具体事物中抽象出的对象也会各有差别。
```

### 创建对象：

```js
	虽然使用Object构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。
	
1、 new 操作符 + Object 创建对象
var person = new Object();
    person.name = "lisi";
    person.age = 21;
    person.family = ["lida","lier","wangwu"];
    person.say = function(){
        alert(this.name);
    }

2、字面式创建对象
var person ={
        name: "lisi",
        age: 21,
        family: ["lida","lier","wangwu"],
        say: function(){
            alert(this.name);
        }
    };

3、工厂模式
function createPerson(name,age,family) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.family = family;
    o.say = function(){
        alert(this.name);
    }
    return o;
}

var person1 =  createPerson("lisi",21,["lida","lier","wangwu"]);   //instanceof无法判断它是谁的实例，只能判断他是对象，构造函数都可以判断出
var person2 =  createPerson("wangwu",18,["lida","lier","lisi"]);
console.log(person1 instanceof Object);                           //true

4、构造函数模式
function Person(name,age,family) {
    this.name = name;
    this.age = age;
    this.family = family;
    this.say = function(){
        alert(this.name);
    }
}
var person1 = new Person("lisi",21,["lida","lier","wangwu"]);
var person2 = new Person("lisi",21,["lida","lier","lisi"]);
console.log(person1 instanceof Object); //true
console.log(person1 instanceof Person); //true
console.log(person2 instanceof Object); //true
console.log(person2 instanceof Person); //true
console.log(person1.constructor);      //constructor 属性返回对创建此对象的数组、函数的引用

5、原型模式
function Person() {
}

Person.prototype.name = "lisi";
Person.prototype.age = 21;
Person.prototype.family = ["lida","lier","wangwu"];
Person.prototype.say = function(){
    alert(this.name);
};
console.log(Person.prototype);   //Object{name: 'lisi', age: 21, family: Array[3]}

var person1 = new Person();        //创建一个实例person1
console.log(person1.name);        //lisi

var person2 = new Person();        //创建实例person2
person2.name = "wangwu";
person2.family = ["lida","lier","lisi"];
console.log(person2);            //Person {name: "wangwu", family: Array[3]}
// console.log(person2.prototype.name);         //报错
console.log(person2.age);              //21

6、混合模式（构造函数模式+原型模式）
function Person(name,age,family){
    this.name = name;
    this.age = age;
    this.family = family;
}

Person.prototype = {
    constructor: Person,  //每个函数都有prototype属性，指向该函数原型对象，原型对象都有constructor属性，这是一个指向prototype属性所在函数的指针
    say: function(){
        alert(this.name);
    }
}

var person1 = new Person("lisi",21,["lida","lier","wangwu"]);
console.log(person1);
var person2 = new Person("wangwu",21,["lida","lier","lisi"]);
console.log(person2);
```

### 继承

```
　一、原型链继承
　重点：让新实例的原型等于父类的实例。
　　　　特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）
　　　　缺点：1、新实例无法向父类构造函数传参。
　　　　　　　2、继承单一。
　　　　　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）
　　　　　　　
　二、借用构造函数继承　
　　重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））
　　　　特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　　　　　2、解决了原型链继承缺点1、2、3。
　　　　　　　3、可以继承多个构造函数属性（call多个）。
　　　　　　　4、在子实例中可向父实例传参。
　　　　缺点：1、只能继承父类构造函数的属性。
　　　　　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　　　　　3、每个新实例都有父类构造函数的副本，臃肿。
　　　　　　　
　三、组合继承（组合原型链继承和借用构造函数继承）（常用）
　重点：结合了两种模式的优点，传参和复用
　　　　特点：1、可以继承父类原型上的属性，可以传参，可复用。
　　　　　　　2、每个新实例引入的构造函数属性是私有的。
　　　　缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。
　　　　
　四、原型式继承
　　重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。
　　　　特点：类似于复制一个对象，用函数来包装。
　　　　缺点：1、所有实例都会继承原型上的属性。
　　　　　　　2、无法实现复用。（新实例属性都是后面添加的）
　　　　　　　
　五、寄生式继承
　　重点：就是给原型式继承外面套了个壳子。
　　　　优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。
　　　　缺点：没用到原型，无法复用。
　
　六、寄生组合式继承（常用）
　寄生：在函数内返回对象然后调用
　　　　组合：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数，可传参　
　　　　　重点：修复了组合继承的问题

　　　　继承这些知识点与其说是对象的继承，更像是函数的功能用法，如何用函数做到复用，组合，这些和使用继承的思考是一样的。上述几个继承的方法都可以手动修复他们的缺点，但就是多了这个手动修复就变成了另一种继承模式。
　　　　这些继承模式的学习重点是学它们的思想，不然你会在coding书本上的例子的时候，会觉得明明可以直接继承为什么还要搞这么麻烦。就像原型式继承它用函数复制了内部对象的一个副本，这样不仅可以继承内部对象的属性，还能把函数（对象，来源内部对象的返回）随意调用，给它们添加属性，改个参数就可以改变原型对象，而这些新增的属性也不会相互影响。
```

### 类

```js
类声明:
定义类有2中方式，类声明和类表达式：
// 类声明
class Student {}
// 类表达式
const Student = class {}

为什么说它是语法糖
因为类实际上它是一个function，区别在于构造函数是函数作用域，类是块级作用域，类中的方法，都是定义在类的prototype上面，所以文章开头说它还是构造函数和原型的概念

类包含的属性和方法
类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。

类的构造函数
类的构造函数关键字是constructor，它同等于原型中的prototype.constructor。
如果没有写constructor函数，那么会默认有一个空的constructor函数。
```

### 5.2 作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

函数有一个内部属性`[scope]`，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解`[scope]`就是所有父变量对象的层级链。

```js
function foo() {
    function bar() {
        //更多代码
    }
}
```

函数创建时，各自的`[scope]`为：

```js
foo.[scope] = [
  globalContext.VO
];

bar.[scope] = [
    fooContext.AO,
    globalContext.VO
];
```

子作用域可以访问父作用域的变量，父作用域不能访问子作用域的变量（只能自下往上查找，不能自上往下查找）。

```js
function parent() {
    var a = 1;
    function child() {
        var b = 2;
        console.log(a); //可以访问到parent中的a
    }
    console.log(b);     //报错，因为访问不到child中的b
}
```

## 5.3 this

前面已经提到`javascript`采用的是静态作用域，但是`this`算是模仿了动态作用域，`this`是在执行阶段时确定的。

### 5.3.1 默认绑定

不带任何修饰的函数进行调用的，只能采用默认绑定，`this`指向全局。严格模式下不能将全局对象用于默认绑定，因此`this`会绑定到`undefined`。

```js
function foo () {
    console.log(this);	//window
    console.log(this.a);
}
var a = 12;
foo();  //12
```

```js
function a() {
    console.log('a', this);	//'a' window
}
function b() {
    a();
    console.log('b', this);	//'b' window
}
function c() {
    b();
    console.log('c', this);	//'c' window
}
c();
```

### 5.3.2 隐式绑定

对象内部包含一个指向函数的属性，并通过这个属性间接引用这个函数，从而把`this`间接（隐式）绑定到这个对象上。

+ 无论是直接在`obj`中定义还是再添加为引用属性，这个函数严格来说都不属于`obj`对象。

```js
function foo() {
    console.log(this);	//{a: 2, foo: ƒ}
    console.log(this.a);	//2
}
>>>>>>> f40588e0b6432d77a46744363122d2c18d0f3ae2

var obj = {
    a: 2,
    foo: foo
}
obj.foo();

var obj = {
    a: 2,
    foo: function() {
        console.log(this);	//{a: 2, foo: ƒ}
        console.log(this.a);	//2
    }
}
obj.foo();
```

<<<<<<< HEAD
基本排序算法其核心思想是指对一组数据按照一定的顺序重新排列。
    重新排列时用到的技术是一组嵌套的for循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。

这些算法非常逼真的模拟了人类在现实生活中对数据的排序，例如纸牌玩家在处理手中的纸牌时对纸牌进行排序，
或者教师按照字母顺序或者分数对试卷进行排序。

#####  冒泡排序：

最慢的排序算法之一，也是最容易实现的排序算法

数组值会像气泡一样从数组的一端漂浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小的值 则会浮动到数组的左侧。

原因是因为算法会多次在数组中移动，比较相邻的数据，当左侧值大于右侧值时它们进行互换。

#####  选择排序算法 

​      选择排序从数组的开头开始，将第一个元素和其他元素进行比较。
​      检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从第二个位置继续。这个过程一直进行，
​      当进行到数组的倒数第二个位置时所有的数组便完成了排序。

## 第8章对象、类与面向对象编程

本章内容:

```
1理解对象
2理解对象创建过程
3理解继承
4理解类
```

### 理解对象

```
	举个栗子，比如一台笔记本电脑，我们将它视为一个对象无非是为了能够更加抽象地描述它，这在编程的过程中很重要，来看看它有哪些需要抽象出来的特性吧~
    在生活中大家应该很熟悉，当你在买一台新的笔记本电脑时，主要考虑的是什么？———笔记本电脑的屏幕大小、屏幕形状、机身总重量、硬盘空间、CPU频率、操作系统……这些都是“笔记本电脑”这个对象所固有的一些性能或制造的参数，这些可以标识出这台笔记本电脑是否受到顾客的欢迎。
    但是，对于现实世界中的一台洗衣机，要考虑的特性就完全不是上面的那些参数和特性了，更多的是会去关注它的容积、耗电量、噪音大小等。还有，对于一架航天飞机，它要考虑的特性会更多，对于一支钢笔，一把伞，针对它们要考虑的就会相对要少一些……从这些例子来看，世间万物的复杂程度不同，我们对它们的关心方面就不同，相应地从它们这些具体事物中抽象出的对象也会各有差别。
```

### 创建对象：

```js
	虽然使用Object构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。
	
1、 new 操作符 + Object 创建对象
var person = new Object();
    person.name = "lisi";
    person.age = 21;
    person.family = ["lida","lier","wangwu"];
    person.say = function(){
        alert(this.name);
    }

2、字面式创建对象
var person ={
        name: "lisi",
        age: 21,
        family: ["lida","lier","wangwu"],
        say: function(){
            alert(this.name);
        }
    };

3、工厂模式
function createPerson(name,age,family) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.family = family;
    o.say = function(){
        alert(this.name);
    }
    return o;
}

var person1 =  createPerson("lisi",21,["lida","lier","wangwu"]);   //instanceof无法判断它是谁的实例，只能判断他是对象，构造函数都可以判断出
var person2 =  createPerson("wangwu",18,["lida","lier","lisi"]);
console.log(person1 instanceof Object);                           //true

4、构造函数模式
function Person(name,age,family) {
    this.name = name;
    this.age = age;
    this.family = family;
    this.say = function(){
        alert(this.name);
    }
}
var person1 = new Person("lisi",21,["lida","lier","wangwu"]);
var person2 = new Person("lisi",21,["lida","lier","lisi"]);
console.log(person1 instanceof Object); //true
console.log(person1 instanceof Person); //true
console.log(person2 instanceof Object); //true
console.log(person2 instanceof Person); //true
console.log(person1.constructor);      //constructor 属性返回对创建此对象的数组、函数的引用

5、原型模式
function Person() {
}

Person.prototype.name = "lisi";
Person.prototype.age = 21;
Person.prototype.family = ["lida","lier","wangwu"];
Person.prototype.say = function(){
    alert(this.name);
};
console.log(Person.prototype);   //Object{name: 'lisi', age: 21, family: Array[3]}

var person1 = new Person();        //创建一个实例person1
console.log(person1.name);        //lisi

var person2 = new Person();        //创建实例person2
person2.name = "wangwu";
person2.family = ["lida","lier","lisi"];
console.log(person2);            //Person {name: "wangwu", family: Array[3]}
// console.log(person2.prototype.name);         //报错
console.log(person2.age);              //21

6、混合模式（构造函数模式+原型模式）
function Person(name,age,family){
    this.name = name;
    this.age = age;
    this.family = family;
}

Person.prototype = {
    constructor: Person,  //每个函数都有prototype属性，指向该函数原型对象，原型对象都有constructor属性，这是一个指向prototype属性所在函数的指针
    say: function(){
        alert(this.name);
    }
}

var person1 = new Person("lisi",21,["lida","lier","wangwu"]);
console.log(person1);
var person2 = new Person("wangwu",21,["lida","lier","lisi"]);
console.log(person2);
```

### 继承

```
　一、原型链继承
　重点：让新实例的原型等于父类的实例。
　　　　特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）
　　　　缺点：1、新实例无法向父类构造函数传参。
　　　　　　　2、继承单一。
　　　　　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）
　　　　　　　
　二、借用构造函数继承　
　　重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））
　　　　特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　　　　　2、解决了原型链继承缺点1、2、3。
　　　　　　　3、可以继承多个构造函数属性（call多个）。
　　　　　　　4、在子实例中可向父实例传参。
　　　　缺点：1、只能继承父类构造函数的属性。
　　　　　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　　　　　3、每个新实例都有父类构造函数的副本，臃肿。
　　　　　　　
　三、组合继承（组合原型链继承和借用构造函数继承）（常用）
　重点：结合了两种模式的优点，传参和复用
　　　　特点：1、可以继承父类原型上的属性，可以传参，可复用。
　　　　　　　2、每个新实例引入的构造函数属性是私有的。
　　　　缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。
　　　　
　四、原型式继承
　　重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。
　　　　特点：类似于复制一个对象，用函数来包装。
　　　　缺点：1、所有实例都会继承原型上的属性。
　　　　　　　2、无法实现复用。（新实例属性都是后面添加的）
　　　　　　　
　五、寄生式继承
　　重点：就是给原型式继承外面套了个壳子。
　　　　优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。
　　　　缺点：没用到原型，无法复用。
　
　六、寄生组合式继承（常用）
　寄生：在函数内返回对象然后调用
　　　　组合：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数，可传参　
　　　　　重点：修复了组合继承的问题

　　　　继承这些知识点与其说是对象的继承，更像是函数的功能用法，如何用函数做到复用，组合，这些和使用继承的思考是一样的。上述几个继承的方法都可以手动修复他们的缺点，但就是多了这个手动修复就变成了另一种继承模式。
　　　　这些继承模式的学习重点是学它们的思想，不然你会在coding书本上的例子的时候，会觉得明明可以直接继承为什么还要搞这么麻烦。就像原型式继承它用函数复制了内部对象的一个副本，这样不仅可以继承内部对象的属性，还能把函数（对象，来源内部对象的返回）随意调用，给它们添加属性，改个参数就可以改变原型对象，而这些新增的属性也不会相互影响。
```

### 类

```js
类声明:
定义类有2中方式，类声明和类表达式：
// 类声明
class Student {}
// 类表达式
const Student = class {}

为什么说它是语法糖
因为类实际上它是一个function，区别在于构造函数是函数作用域，类是块级作用域，类中的方法，都是定义在类的prototype上面，所以文章开头说它还是构造函数和原型的概念

类包含的属性和方法
类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。

类的构造函数
类的构造函数关键字是constructor，它同等于原型中的prototype.constructor。
如果没有写constructor函数，那么会默认有一个空的constructor函数。
```
=======
+ 调用位置会使用`obj`上下文来引用函数，因此你可以说函数被调用时`obj`对象“拥有”或者“包含”函数引用。当`foo()`被调用时，它的前面确实加上了对`obj`的引用，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的`this`绑定到这个上下文对象。因此调用`foo()`时`this`被绑定到`obj`，因此在函数中执行`this.a`和`obj.a`是一样的。
+ 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。

```js
function foo() {
    console.log(this.a);
}

var obj2 = {
    a: 1,
    foo: foo
}

var obj1 = {
    a: 2,
    obj2: obj2
}
obj1.obj2.foo();    //1

var obj3 = {
    a: 3,
    obj1: obj1
}
obj3.obj1.obj2.foo();	//1
```

### 5.3.3 显示绑定

`call`,`apply`,`bind`都属于显式绑定一类，显示绑定后`this`便无法再修改。

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.call(obj);
```

### 5.3.4 new绑定

实例化一个新对象后，会将实例对象绑定到函数调用中的`this`上。

```js
function foo(a) {
    console.log(this);	//foo {}
    this.a = a;
    console.log(this.a);	//2
}
var bar = new foo(2);
console.log(bar.a); //2
console.log(a);	//Uncaught ReferenceError: a is not defined
```

### 5.3.5 箭头函数

`es6`新增的`()=>`箭头函数中，`this`在分析阶段时就确定了（跟函数中的`this`在执行阶段时确定相反），绑定的是父作用域中的`this`，指向永远不变。其实总结起来就两点：

+ 外层有函数：外层函数的`this`就是箭头函数的`this`。

```js
function ab() {
    var b = () => {
        console.log(this);
    };
    b();
}
ab();   //window，因为外层函数的this采用了默认绑定规则
```

```js
var obj = {
    a: 1,
    foo() {
        var fn = () => {
            console.log(this.a);
        };
        fn();
    }
}
obj.foo();  //1，外层函数的this采用了隐式绑定规则
```

外层没有函数：箭头函数的`this`就是`window`。

```js
var a = 123;
var obj = {
    a: 1,
    foo: () => {
        console.log(this.a);
    }
}
obj.foo();  //123
```

## 5.4 总结
>>>>>>> f40588e0b6432d77a46744363122d2c18d0f3ae2

到目前为止还不知道执行上下文的结构。接下来通过例子讲解。

``` js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

1. 全局上下文初始化。

```js
globalContext = {
    VO: [global],	//window是暴露出来的一个指向全局变量对象的属性
    Scope: [globalContext.VO],
    this: globalContext.VO
}
```

2. 初始化的同时，`checkscope`函数被创建，保存作用域链到函数的内部属性`[scope]`。

``` js
checkscope.[scope] = [
  globalContext.VO
];
```

3. 执行`checkscope`函数，创建`checkscope`函数执行上下文并初始化。

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope: undefined,
        f: reference to function f(){}
    },
    Scope: [AO, globalContext.VO],
    this: undefined
}
```

4. 执行`f`函数，创建`f`函数执行上下文并初始化。

```js
fContext = {
    AO: {
        arguments: {
            length: 0
        }
    },
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
    this: undefined
}
```
