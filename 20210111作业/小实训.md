一，git仓库
	（1）获取到另一个人的仓库内的内容，克隆传到自己的仓库，
   只需要获取对方的用户链接地址，点击需要的文件，
   在右上角有一个Fork（从一个仓库克隆到拎一个仓库）点击以后就克隆完毕，传递到你自己的仓库内

  	（2）但本地是没有克隆后的文件的，要克隆到本地，需要新建文件夹，打开cmd ，
输入指令 git klone 。。。。（在仓库内点击获取http版的克隆地址，添加到后面，回车即可）
就可以在本地获取到仓库内容

	（3）需要将自己新创建的文件上传到仓库，穿给老师，需要打开git编辑器，输入指令 git add .
回车，然后在输入（git commit -m "提交”{这段是在仓库内显示的创建的内容名}）回车，
然后将自己的这个文件推送到自己的仓库
输入指令（git push.......在仓库内获取到的地址）如果没有分支，
直接点击回车即可，这样，新的文件就传到自己的仓库内，这时还未传到老师仓库内，还需要点击Pull requests(拉请求)，![1610363176155](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\1610363176155.png)
然后点击新建一个Pull requests 跳转以后在直接点击![1610363323791](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\1610363323791.png)

绿色按钮，然后写上自己的名称，要传输的理由内容，点击确定，然后就传输到对方的仓库，请求对方的接受![1610363447801](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\1610363447801.png)

将对方的节点跟新到自己的仓库，输入指令如下，第一个origins是自己的内容，第2个是对方的，然后将对方的仓库的分支，跟新到本地的分支，如果有更新那么就可以更新到自己的仓库，在输入指令，git push origin,就可以将更新后的节点，存到自己的仓库内![1610363919469](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\1610363919469.png)



二，原型

1.  每个函数都有一个prototype属性，被称为显示原型 
2.  每个实例对象都会有`_ _proto_ _`属性,其被称为隐式原型
3.  每一个实例对象的隐式原型`_ _proto_ _`属性指向自身构造函数的显式原型prototype
4.  每个prototype原型都有一个constructor属性，指向它关联的构造函数。

1.原型链
原型链： 每个实例化对象都有一个__proto__属性，这个属性指向函数的原型，
当我们访问对象中的属性的时候，先从当前对象找，如果找不到的话，从当前原型中查找，
=》 当前函数的继承对象中查找，最后如果没有找到返回 undefined

JavaScript：数据类型和分别的功效；

有undefind , null , object , string , number , boolean , Symbol 

运算符 ：

![1610370193525](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\1610370193525.png)

![1610370238549](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\1610370238549.png)

 typeof 能有效检测基本类型，检测引用类型都返回object,其中null属于特殊的引用类型返回object,function属于特殊引用类型类型不用于存储数据，typeof检测返回function 

2. instanceof

   instanceof运算符需要指定一个构造函数，或者说指定一个特定的类型，它用来判断这个构造函数的原型是否在给定对象的原型链上。 

3. **constructor** 

   constructor是prototype对象上的属性，指向构造函数。根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用constructor属性的。 



三，git的基本流程
  概念：git是一个分布式版本管理控制系统 缩写VCS），
它可以在任何时间点，将文档的状态作为更新记录保存起来，
也可以在任何时间点，将更新记录恢复回来。

git的基本工作流程
 1.首先我们创建一个远程仓库
 2.然后在git本地目录里面写我们的代码
 3.然后在把代码上传到暂存区
 4.最后上传到git远程仓库

1.2 人为维护文档版本的问题

   文档数量多且命名不清晰导致文档版本混乱

    每次编辑文档需要复制，不方便
    
    多人同时编辑同一个文档，容易产生覆盖

  二.
    Git是目前世界上最先进的分布式版本控制系统，
    在处理各种项目时都十分高效，而且非常的高大上。

   SVN是集中式版本控制系统，版本库是集中放在中央服务器的，
   而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，
    然后干活，干完后，需要把自己做完的活推送到中央服务器。
而且集中式版本控制系统是必须联网才能工作。

     Git是分布式版本控制系统，它就没有中央服务器的，每个人的电脑就是一个完整的版本库，
这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。

例子：当你用Word文档写过长篇大论，那大家都有一定这样的经历，
想删除一个段落，又怕删除后找不回来，然后就只能先另存为，
在修改，然后在另存为，过了一段时间又想找回被删除的段落，但又记不清在哪里保存的了
还有时，需要和同学（同事），帮助填写，于是把文件copy给他，
然后继续修改，过段时间，同学（同事）把文件给你，
你又得想想自己哪里修改了，把自己的修改和同事的部分合并，很困难。
但是git的诞生解决了大家的这一困扰，不但能帮大家记录每次文件的改动，
换可以与同事协作编辑，这样就不需要自己多次操作，和文件传来传去，
如果需要改动，只需要在软件里瞄一眼就可以，非常方便。

//区别
先说集中式版本控制系统，版本库是集中存放在中央服务器的，
而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，
然后开始干活，干完活了，再把自己的活推送给中央服务器。
中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，
然后回到家自己改，改完了，再放回图书馆。


2，let，const ,var
     let声明的的变量，只在块级作用域下有效,let不允许重复声明变量的，不存在变量提升，暂时性死区
    const 声明常量  声明了就要赋值  不可改变的变量  ==>规范，命名都是大写 其他和let差不多
    var 是变量，可以重复声明 变量提升


4. 作用域
全局作用域  函数作用域
js中首先有一个最外层的作用域，全局作用域；
js中可以通过函数来创建一个独立作用域称为函数作用域，函数可以嵌套，所以作用域也可以嵌套；
es6中新增了块级作用域 es6作业域一般只适用const let 

5. 闭包的概念
在函数内部声明一个局部变量 外部函数正常情况下无法访问这个变量，这个时候就需要用到闭包，
只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。
应用的一些场景
优点： 外部函数的变量会存储在内存中，可以避免全局变量的污染
缺点： 容易造成内存泄露，每调用一次都会产生一个新的闭包 内存消耗很大




