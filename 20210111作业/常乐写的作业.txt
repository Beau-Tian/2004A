每个函数都有一个原型prototyp显示原型，
每个构造函数都有--proto--属性隐示原型，指向原型prototyp显示原型，
每个prototype都包含一个constructor属性，指向构造函数本身

原型链是先从当前对象中查找属性和方法，如果没有就从原型中查找，
没有，就从继承的对象中找，如果没有就返回undefined1.写出自己理解的原型和原型链
每个函数都有一个原型prototyp显示原型，
每个构造函数都有--proto--属性隐示原型，指向原型prototyp显示原型，
每个prototype都包含一个constructor属性，指向构造函数本身

原型链是先从当前对象中查找属性和方法，如果没有就从原型中查找，
没有，就从继承的对象中找，如果没有就返回undefined

基本都是死记硬背的。。。。。

2.function y(num) {
    console.log(num);
    var num = 1;
    console.log(num);
    console.log(fn);
    var fn = function() {
       console.log(1);
   }
   console.log(fn);
   function fn(){
       console.log(2);
   }
   console.log(fn);
}
y(2);
请写出最终答案。

3.function y() {
    console.log(num);
    var num = 1;
    console.log(num);
    function num() { console.log(3); }
    function num() { console.log(5); }
    console.log(num);
}
y();
请写出最终答案。

4.function y() {    
    var num = 1;
    console.log(num);
    function num() { console.log(3); }
    console.log(num);
}
y();

5.for(var i = 0;i<10;i++){ 
	setTimeout(()=>{ console.log(i); },100);
 }
//写出三种能正常打印0-9的方法

6.密码必须为6-15位的数字、字母、_-的组合。请使用正则表达式验证。

7.//注意审题
function A() {}
function B() {}
B.prototype = Object.create(A.prototype);
B.prototype.constructor = B;
function C() {}
C.prototype = Object.create(B.prototype);
C.prototype.constructor = C;

var c1 = new C();
c1.prototype === C1.prototype ?
c1.__proto__ === C.protoype?
c1.__proto__.prototype === C__proto__.prototype?
c1.__proto__.__proto__ === B.prototype?
c1.__proto__.__proto__.__proto__ ===  A.prototype
c1.__proto__.constructor === C?
c1.__proto__.constructor.prototype === C.prototype?
c1.__proto__.constructor.prototype.constructor === C?
C.prototype.constructor ===C ?
C.prototype.constructor.prototype === C.prototype?
C.prototype.constructor.prototype.constructor ===C ?
C.prototype.__proto__ ===B.prototype ?