1.写出自己理解的原型和原型链
原型:
①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象 
②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象 
③所有引用类型的__proto__属性指向它构造函数的prototype
每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，
这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值
原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。


原型链：
当访问一个对象的某个属性时，会先在这个对象本身属性上查找，
如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，
如果还没有找到就会再在构造函数的prototype的__proto__中查找，
这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

2.function y(num) {
    console.log(num);
    var num = 1;
    console.log(num);
    console.log(fn);
    var fn = function() {
       console.log(1);
   }
   console.log(fn);
   function fn(){
       console.log(2);
   }
   console.log(fn);
}
y(2);
请写出最终答案。
    2  1  2  1  1

3.function y() {
    console.log(num);
    var num = 1;
    console.log(num);
    function num() { console.log(3); }
    function num() { console.log(5); }
    console.log(num);
}
y();
请写出最终答案。
       5 1 1

4.function y() {    
    var num = 1;
    console.log(num);
    function num() { console.log(3); }
    console.log(num);
}
y();
      1   1
5.for(var i = 0;i<10;i++){ 
	setTimeout(()=>{ console.log(i); },100);
 }
//写出三种能正常打印0-9的方法

for (var i = 0; i < 10; i++) {
            (function (j) {
                setTimeout(() => {
                    console.log(j);
                }, 100);
            })(i);
        }

for (let i = 1; i <10; i++) {
            setTimeout(() => {
                console.log(i);
            }, 100);
        }

for (var i = 1; i < 10; i++) {
            timer(i);
        }

        function timer(i) {
            setTimeout(() => {
                console.log(i);
            }, 100);
        }

6.密码必须为6-15位的数字、字母、_-的组合。请使用正则表达式验证。

/^(?!^[\d]+$)(?!^[-]+$)(?!^[_]+$)(?!^[a-zA-Z]+$)[\w-]{6,15}$/

7.//注意审题
function A() {}
function B() {}
B.prototype = Object.create(A.prototype);
B.prototype.constructor = B;
function C() {}
C.prototype = Object.create(B.prototype);
C.prototype.constructor = C;

var c1 = new C();
c1.prototype === undefined
c1.__proto__ ===  C.prototype
c1.__proto__.prototype === undefined
c1.__proto__.__proto__ === B.prototype
c1.__proto__.__proto__.__proto__ ===  A.prototype
c1.__proto__.constructor ===C.prototype.constructor
c1.__proto__.constructor.prototype === C.prototype
c1.__proto__.constructor.prototype.constructor === C.prototype.constructor
C.prototype.constructor === c1.__proto__.constructor.prototype.constructor
C.prototype.constructor.prototype === c1.__proto__.constructor.prototype
C.prototype.constructor.prototype.constructor === c1.__proto__.constructor.prototype.constructor
C.prototype.__proto__ === B.prototype

